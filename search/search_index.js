var __index = {"config":{"lang":["tr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"NixOS","text":"<p>Distrowatch sitesine bakacak olursak y\u00fczlerce Linux da\u011f\u0131t\u0131m\u0131 oldu\u011funu g\u00f6rebiliriz. Bunlardan biri de ad\u0131n\u0131 son zamanlarda daha s\u0131k duydu\u011fumuz NixOS.</p> <p></p> <p>NixOS i\u015fletim sistemi e\u011fer Nix dilini ve Nix Paket Y\u00f6neticisini anlayabilirsek mevzunun belki de en basit k\u0131sm\u0131. \u015eimdi biraz ekosistemi anlamaya \u00e7al\u0131\u015fal\u0131m.</p> <p>Nix, Eelco Dolstra taraf\u0131ndan akademik bir proje olarak ba\u015flad\u0131.<sup>1</sup> Dolstra'n\u0131n amac\u0131, geleneksel paket y\u00f6netimi sistemlerinin kar\u015f\u0131la\u015ft\u0131\u011f\u0131 sorunlar\u0131 \u00e7\u00f6zmek ve daha tutarl\u0131 bir sistem y\u00f6netimi sa\u011flamakt\u0131. Bu hedef do\u011frultusunda, fonksiyonel programlama prensiplerine dayanan bir dil olan Nix Expression Language (Nix) tasarland\u0131.</p> <ul> <li>2003-2006: Nix'in erken d\u00f6nemleri. Temel fonksiyonel prensiplerle paket y\u00f6netimi geli\u015ftirildi.</li> <li>2006: \u0130lk kararl\u0131 s\u00fcr\u00fcm olan Nix 0.8.1 yay\u0131mland\u0131. Bu s\u00fcr\u00fcm, temel \u00f6zellikleri i\u00e7eriyordu ve kullan\u0131c\u0131lar\u0131na deklaratif paket y\u00f6netimi sunuyordu.</li> <li>2008-2012: NixOS, Nix'in bir t\u00fcrevidir. NixOS, Nix'in paket y\u00f6netimi yeteneklerini temel alarak bir t\u00fcm i\u015fletim sistemini y\u00f6netmek i\u00e7in tasarland\u0131.</li> <li>2018: Nix, bir dizi geli\u015ftirme ve iyile\u015ftirmeyle Nix 2.0 s\u00fcr\u00fcm\u00fcne ula\u015ft\u0131. Bu s\u00fcr\u00fcm, kullan\u0131c\u0131 dostu ara\u00e7lar, yeni \u00f6zellikler ve performans iyile\u015ftirmeleri i\u00e7eriyordu.</li> </ul>"},{"location":"index.html#nix-dili-paket-yoneticisi-nixos-ve-nixops-nedir","title":"Nix Dili, Paket Y\u00f6neticisi, NixOS ve NixOps Nedir?","text":"<p>Nix'in bu kadar karma\u015f\u0131k olmas\u0131n\u0131n belki en \u00f6nemli sebeplerinden biri geli\u015fimi s\u0131ras\u0131nda farkl\u0131 ihtiya\u00e7lara da cevap bulmas\u0131ndan dolay\u0131 bir \u00e7ok ara\u00e7 ve teknik de geli\u015ftirmi\u015f olmas\u0131d\u0131r diyebiliriz.</p> <p>Ba\u015fta sadece bir deployment dili olarak ortaya \u00e7\u0131km\u0131\u015fken \u015fimdi cloud ortamlar\u0131 i\u00e7in makine deployment arac\u0131 olarak bile kullan\u0131labiliyor. NixOS'un pop\u00fcler olmas\u0131yla birlikte kullanmak isteyen herkes Nix dilinin karma\u015fas\u0131yla y\u00fczle\u015fmek zorunda.</p> <p>Nix, temel olarak d\u00f6rt ana bile\u015fenden olu\u015fur: Nix Dili, Nix Paket Y\u00f6neticisi, NixOS ve NixOps.</p> <p><sup>2</sup></p> <ol> <li>Nix Dili: Nix Dili, paketlerin ve sistem konfig\u00fcrasyonlar\u0131n\u0131n ifade edildi\u011fi fonksiyonel bir programlama dilidir. Nix dilindeki ifadeler, bir paketin veya sistem konfig\u00fcrasyonunun nas\u0131l olu\u015fturulaca\u011f\u0131n\u0131 belirler.</li> <li>Nix Paket Y\u00f6neticisi: Nix Paket Y\u00f6neticisi, sistemlere yaz\u0131l\u0131m paketlerini y\u00f6netmek i\u00e7in kullan\u0131lan bir ara\u00e7t\u0131r. Bu, Nix Dilini kullanarak ifade edilen paketleri indirip y\u00fckler. Kullan\u0131c\u0131lar, Nix Paket Y\u00f6neticisi ile paketleri kurabilir, g\u00fcncelleyebilir ve kald\u0131rabilir. Yani Nix dili ile yaz\u0131lm\u0131\u015f paketlerimiz ve bir de paket y\u00f6neticimiz var. E\u011fer amac\u0131m\u0131z paket geli\u015ftirmek de\u011filse en az\u0131ndan paketleri kurup \u00e7al\u0131\u015ft\u0131racak kadar Nix CLI komutlar\u0131n\u0131 bilmek gerekiyor. Linux kullanan hemen hemen hi\u00e7 kimse hayat\u0131nca bir kez test ama\u00e7l\u0131 bile olsa paket yazmam\u0131\u015ft\u0131r herhalde. Yani ka\u00e7\u0131m\u0131z her hangi bir Linux distrosu paket y\u00f6neticisi i\u00e7in geli\u015ftirme yapm\u0131\u015f\u0131zd\u0131r ki?</li> <li>NixOS: Nix'in bir t\u00fcrevidir ve tamamen Nix Dili ile konfig\u00fcre edilebilen bir i\u015fletim sistemidir. Geleneksel da\u011f\u0131t\u0131mlar\u0131n aksine, NixOS'un t\u00fcm sistem konfig\u00fcrasyonu bir dosya i\u00e7inde deklare edilir. Kullan\u0131c\u0131lar, NixOS kullanarak bir bilgisayar\u0131n veya sunucunun t\u00fcm konfig\u00fcrasyonunu belirleyebilir. Bu, daha tutarl\u0131 ve tekrarlanabilir sistem y\u00f6netimi sa\u011flar. Asl\u0131nda Nix Dilinin temel amac\u0131 b\u00fct\u00fcn Linux distrolar\u0131 i\u00e7in merkezi bir paket y\u00f6neticisi olu\u015fturmak ve bu paket y\u00f6neticisini deklaratif bir \u015fekilde y\u00f6netmekti. NixOS ise bu Dilin ve paket y\u00f6neticisinin yetenekleri \u00fczerine ortaya \u00e7\u0131km\u0131\u015f bir i\u015fletim sistemi. Yani NixOS'u kullanmak i\u00e7in Nix Dili ve Nix Paket Y\u00f6neticisini bilmek gerekiyor. Ancak tekrar s\u00f6ylemek istiyorum e\u011fer paket yazmayacaksan\u0131z Nix Dilini \u00e7ok iyi kullanmak zorunda de\u011filsiniz. Sadece konfig\u00fcrasyonu de\u011fi\u015ftirebilecek kadar bilmek yeterli.</li> <li>NixOps: NixOps, Nix dilini ve Nix paketlerini kullanarak bulut altyap\u0131s\u0131nda ve sanal makinelerde da\u011f\u0131t\u0131lm\u0131\u015f sistemleri y\u00f6neten bir ara\u00e7t\u0131r. Kullan\u0131c\u0131lar, NixOps'u kullanarak belirli bir bulut sa\u011flay\u0131c\u0131s\u0131nda veya sanal makineler \u00fczerinde NixOS konfig\u00fcrasyonlar\u0131n\u0131 otomatik olarak da\u011f\u0131tabilir ve y\u00f6netebilir. Bu durumda e\u011fer cloud ile i\u015finiz yoksa veya \u00f6zellikle bir NixOS sistemini da\u011f\u0131tmay\u0131 veya uzak sistemlere deploy etmeyi d\u00fc\u015f\u00fcnm\u00fcyorsan\u0131z NixOps'u \u00f6\u011frenmenize gerek yok.</li> </ol> <p>Tersten gidecek olursak NixOps i\u00e7in NixOS'u, NixOS i\u00e7in Nix Paket Y\u00f6neticisini, Nix Paket y\u00f6neticisi i\u00e7in de Nix Dilini bilmek gerekiyor.</p> <p>Ara\u015ft\u0131rma yaparken \u00c7ince bir sitede g\u00f6rd\u00fc\u011f\u00fcm g\u00f6rsel \u00e7ok ho\u015fuma gitti. NixOps, NixOS ve Nix Paket Y\u00f6neticisi aras\u0131ndaki ili\u015fkiyi \u00e7ok g\u00fczel \u00f6zetliyor.</p> <p>Bu grafik asl\u0131nda Hristiyanl\u0131ktaki \u00fc\u00e7leme karma\u015fas\u0131n\u0131 anlatabilmek i\u00e7in kullan\u0131l\u0131yor. Burada da Nix karma\u015fas\u0131n\u0131 anlatmak i\u00e7in g\u00fczel bir benzetme olmu\u015f.</p> <p><sup>3</sup></p>"},{"location":"index.html#declarative-imperative-kavramlar","title":"Declarative, Imperative Kavramlar\u0131","text":"<p>Nix Dili ve NixOS i\u00e7in deklaratif demi\u015ftik. Deklaratif olmayan versiyona da imperatif diyoruz. Peki aras\u0131ndaki farklar nedir?</p> <p>\"Declarative\" (deklaratif) ve \"Imperative\" (emir kipinde) terimleri, programlama dilleri, konfig\u00fcrasyon y\u00f6netimi ve sistem tasar\u0131m\u0131 gibi bir\u00e7ok ba\u011flamda kullan\u0131lan iki temel yakla\u015f\u0131m\u0131 tan\u0131mlar.</p> <ul> <li>Deklaratif (Bildirimsel):</li> <li>Deklaratif yakla\u015f\u0131m, bir sistemi veya i\u015flemi nas\u0131l elde edilece\u011fi yerine ne elde edilmek istendi\u011fiyle tan\u0131mlar. Yani, bir hedefin a\u00e7\u0131klamas\u0131d\u0131r.</li> <li>Kullan\u0131c\u0131, bir durumu belirtir ve sistem bu durumu sa\u011flamak i\u00e7in gerekli ad\u0131mlar\u0131 otomatik olarak ger\u00e7ekle\u015ftirir. Kullan\u0131c\u0131, i\u015flemin detaylar\u0131na odaklanmak yerine nihai durumu tan\u0131mlar.</li> <li>SQL, HTML ve NixOS konfig\u00fcrasyon dosyalar\u0131 gibi deklaratif \u00f6rnekler vard\u0131r. SQL'de bir veri setinin nas\u0131l al\u0131naca\u011f\u0131n\u0131 de\u011fil, al\u0131nan veri setinin ne olmas\u0131 gerekti\u011fini belirtirsiniz.</li> <li>Daha kolay anla\u015f\u0131l\u0131r ve bak\u0131m\u0131 yap\u0131labilir.</li> <li> <p>Yap\u0131land\u0131rma dosyalar\u0131 ve sistem konfig\u00fcrasyonlar\u0131 genellikle daha k\u0131sa ve a\u00e7\u0131k olabilir.</p> </li> <li> <p>Emir Kipi (Imperative):</p> </li> <li>Imperative yakla\u015f\u0131m, bir sistemi veya i\u015flemi ad\u0131m ad\u0131m nas\u0131l ger\u00e7ekle\u015ftirece\u011fimizi belirtir. Yani, bir i\u015flemi ad\u0131m ad\u0131m a\u00e7\u0131klar ve her ad\u0131m\u0131 belirli bir s\u0131rayla y\u00fcr\u00fct\u00fcr.</li> <li>Kullan\u0131c\u0131, i\u015flemin her ad\u0131m\u0131n\u0131 belirtir ve her ad\u0131m\u0131n nas\u0131l ger\u00e7ekle\u015ftirilece\u011fini ayr\u0131nt\u0131l\u0131 olarak a\u00e7\u0131klar.</li> <li>Bir\u00e7ok programlama dilindeki genel programlama mant\u0131\u011f\u0131 emir kipindedir. \u00d6rne\u011fin, bir d\u00f6ng\u00fc i\u00e7inde ad\u0131m ad\u0131m bir i\u015flemin nas\u0131l ger\u00e7ekle\u015ftirilece\u011fini belirlemeniz gerekir.</li> <li> <p>Daha fazla kontrol sa\u011flar, \u00f6zellikle belirli bir s\u0131ra veya ko\u015ful durumu gerektiren durumlarda.</p> </li> <li> <p>Deklaratif ve Imperatif Aras\u0131ndaki Ana Fark: Deklaratif, ne yap\u0131lmas\u0131 gerekti\u011fini belirtirken, emir kipinde olan nas\u0131l yap\u0131lmas\u0131 gerekti\u011fini belirtir.</p> </li> <li>Kullan\u0131m Ba\u011flam\u0131: Deklaratif genellikle yap\u0131land\u0131rma dosyalar\u0131, sorgu dilleri ve sistem konfig\u00fcrasyonlar\u0131 gibi tan\u0131mlay\u0131c\u0131 ba\u011flamlarda kullan\u0131l\u0131rken, emir kipinde genellikle genel programlama ve ad\u0131m ad\u0131m kontrol gerektiren durumlarda kullan\u0131l\u0131r.</li> </ul> <p>Yani \u00f6zet olarak normal bir Linux distrosunda \u00f6rne\u011fin Ubuntu'da bir uygulamay\u0131 kurmak i\u00e7in <code>sudo apt install uygulama_adi</code> komutunu veririz. Bu bir komuttur yani bir dilden bahsetmiyoruz veya bir konfig\u00fcrasyondan da bahsetmiyoruz. Ancak NixOS \u00fczerinde konfig\u00fcrasyon dosyas\u0131na uygulaman\u0131n ad\u0131n\u0131 yazmam\u0131z yeterli. Yani bir komut yazm\u0131yoruz sadece ad\u0131n\u0131 yaz\u0131yoruz. Tek bir uygulama i\u00e7in bu dedi\u011fim etkileyici olmayabilir ancak onlarca uygulama ad\u0131n\u0131 yaz\u0131p tek seferde hapsini kurabiliyor olmak \u00e7ok etkileyici. Ayr\u0131ca bu konfig\u00fcrasyon dosyas\u0131n\u0131 ba\u015fka bir sistemde de kullan\u0131rsak ayn\u0131 sistemi tekrar aya\u011fa kald\u0131rabiliriz. Bu haliyle ciddi \u015fekilde deklaratif bir yap\u0131ya sahip. Yani elimizdeki tek bir dosya ile y\u00fczlerce sistemi aya\u011fa kald\u0131rabiliriz.</p>"},{"location":"index.html#yetenekleri-nelerdir","title":"Yetenekleri Nelerdir?","text":"<p>\u015eimdi b\u00fct\u00fcn bu ara\u00e7lar\u0131n neler yapabilece\u011fine bakal\u0131m.</p> <ul> <li>Diyelimki bir terminal a\u00e7t\u0131n\u0131z ve o terminal i\u00e7inde bir uygulamay\u0131 kullan\u0131p sistemde hi\u00e7 bir iz b\u0131rakmadan kald\u0131rmak istiyorsunuz. Terminalinizi kapatt\u0131\u011f\u0131n\u0131zda sistem otomatik olarak her\u015feyi temizlesin istiyorsunuz. Bunu Nix paket y\u00f6neticisi ile yapabilirsiniz.</li> <li>Birden fazla proje klas\u00f6r\u00fcn\u00fcz var ve her birinde farkl\u0131 programlama dilleri ile geli\u015ftirme yap\u0131yorsunuz veya program kullan\u0131yorsunuz diyelim. \u0130lla programlama yapmak zorunda de\u011filsiniz herhangi bir program olabilir. \u0130lgili klas\u00f6rde \u00e7al\u0131\u015faca\u011f\u0131n\u0131z zaman sisteminizde gerekli programlar kurulsun ve siz i\u015finizi bitirdi\u011finizde sistemden kald\u0131r\u0131ls\u0131n istiyorsunuz. Bunu Nix paket y\u00f6neticisi ile yapabilirsiniz.</li> <li>Tamamen s\u0131f\u0131rdan bir docker image olu\u015fturabilirsiniz.</li> <li>\u0130\u00e7inde istedi\u011finiz programlar\u0131n oldu\u011fu kuruluma haz\u0131r bir ISO olu\u015fturabilirsiniz.</li> <li>Elinizdeki konfig\u00fcrasyon dosyas\u0131n\u0131 kullanarak cloud ortam\u0131nda veya uzak bir makinede NixOS'u kurabilirsiniz.</li> <li>Kendi ki\u015fisel masa\u00fcst\u00fc ortam\u0131n\u0131z\u0131 deklaratif bir \u015fekilde olu\u015fturabilirsiniz. Yani \u00f6rne\u011fin KDE/Plasma kullanacaks\u0131n\u0131z ve bir \u00e7ok custom de\u011fi\u015fiklik yapt\u0131n\u0131z tekrar kurulum yapt\u0131\u011f\u0131n\u0131z b\u00fct\u00fcn ayarlar\u0131n\u0131z\u0131 Nix ile bir dosyaya kaydedebilirsiniz.</li> <li>B\u00fct\u00fcn bir i\u015fletim sistemi kurulumunu ve ayarlar\u0131n\u0131z\u0131 3-5 adet dosyaya s\u0131\u011fd\u0131rabilirsiniz ve bunu bir git reposunda saklayabilirsiniz.</li> <li>Bir uygulaman\u0131 farkl\u0131 versiyonlar\u0131n\u0131 ayn\u0131 anda kurabilir ve istedi\u011finiz versiyonu \u00e7al\u0131\u015ft\u0131rabilirsiniz.</li> <li>Tek bir konfig\u00fcrasyonu kullanarak nix-generator arac\u0131 ile alttaki b\u00fct\u00fcn ortamlara \u00e7\u0131kt\u0131 \u00fcretebilirsiniz.</li> <li>Nix paket y\u00f6neticisi ile ilgili s\u00f6yledi\u011fim her \u015fey NixOS olmaks\u0131z\u0131n t\u00fcm Linux da\u011f\u0131t\u0131mlar\u0131nda, macOS'de ve Windows WSL'de \u00e7al\u0131\u015f\u0131yor.</li> </ul> format description amazon Amazon EC2 image azure Microsoft azure image (Generation 1 / VHD) cloudstack qcow2 image for cloudstack do Digital Ocean image docker Docker image (uses systemd to run, probably only works in podman) gce Google Compute image hyperv Hyper-V Image (Generation 2 / VHDX) install-iso Installer ISO install-iso-hyperv Installer ISO with enabled hyper-v support iso ISO kexec kexec tarball (extract to / and run /kexec_nixos) kexec-bundle same as before, but it's just an executable kubevirt KubeVirt image linode Linode image lxc create a tarball which is importable as an lxc container, use together with lxc-metadata lxc-metadata the necessary metadata for the lxc image to start, usage: <code>lxc image import $(nixos-generate -f lxc-metadata) $(nixos-generate -f lxc)</code> openstack qcow2 image for openstack proxmox VMA file for proxmox proxmox-lxc LXC template for proxmox qcow qcow2 image raw raw image with bios/mbr. for physical hardware, see the 'raw and raw-efi' section raw-efi raw image with efi support. for physical hardware, see the 'raw and raw-efi' section sd-aarch64 Like sd-aarch64-installer, but does not use default installer image config. sd-aarch64-installer create an installer sd card for aarch64. For cross compiling use <code>--system aarch64-linux</code> and read the cross-compile section. vagrant-virtualbox VirtualBox image for Vagrant virtualbox virtualbox VM vm only used as a qemu-kvm runner vm-bootloader same as vm, but uses a real bootloader instead of netbooting vm-nogui same as vm, but without a GUI vmware VMWare image (VMDK) <p><sup>4</sup></p>"},{"location":"index.html#infrastructure-as-code-iac-sistemlerinden-ve-hashicorp-packerdan-fark-nedir","title":"Infrastructure as Code (IaC) Sistemlerinden ve HashiCorp Packer'dan Fark\u0131 Nedir?","text":"<p>\u015eimdi akl\u0131m\u0131za \u015fu gelebilir, zaten bir \u00e7ok ara\u00e7 var neden Nix'i \u00f6\u011frenelim? IoC ara\u00e7lar\u0131n\u0131n temel amac\u0131 asl\u0131nda do\u011frudan tek bir makine de\u011fil belki binlerce sunucuyu y\u00f6netmek. Hatta belki \u015fu bile denilebilir gerekli plugin'lerle birlikte ekosistemi (farkl\u0131 i\u015fletim sistemleri, network cihazlar\u0131 vb) y\u00f6netmek. Nix'in temel amac\u0131 deklaratif olarak bir makinenin bir dok\u00fcman \u00fczerinden her zaman ayn\u0131 sonucu vermesini sa\u011flamak. Bu ba\u011flamda asl\u0131nda Infrustracture as Code sistemleri NixOS'un \u00fczerinde bir yap\u0131d\u0131r. \u00d6rne\u011fin Chef veya Puppet ile bi NixOS'u y\u00f6netebilirsiniz. Binlerce NixOS sunucunu aya\u011fa kald\u0131r\u0131p y\u00f6netebilirsiniz. Bunu yaparken de NixOS konfig\u00fcrasyon dosyas\u0131n\u0131 kullanabilirsiniz. Ayr\u0131ca tabii ki bu ara\u00e7lar\u0131n bir paket y\u00f6neticisi yok. Dolay\u0131s\u0131yla i\u015fletim sistemei seviyesindeki bir i\u015fi daha \u00fcst seviyede i\u015f yapan bir araca yapt\u0131rm\u0131\u015f oluyoruz.</p> <p>HashiCorp Packer'\u0131n temel amac\u0131 farkl\u0131 ortamlar i\u00e7in is\u015fetim sistemi image'lar\u0131 olu\u015fturmak. Bunu yaparken deklaratif bir yol izlemiyoruz daha \u00e7ok prosed\u00fcrel olarak bir birini takip eden ad\u0131mlarla bir image olu\u015fturuyoruz. Nix en temelinde bir cross-platform bir paket y\u00f6neticisi olmaya \u00e7al\u0131\u015f\u0131yor. Asl\u0131nda NixOS, NixOps ve nix-generetor gibi ara\u00e7lar paket y\u00f6netcisive Nix dilinini yetenekleri \u00fczere sonradan geli\u015ftirilmi\u015f ara\u00e7lar. Bu ara\u00e7lardan \u00f6rne\u011fin nix-generator ve NixOps kullanarak Packer'\u0131n yapt\u0131\u011f\u0131n\u0131 yapabilir hale geliyoruz. Ancak bunu sadece NixOS i\u015fletim sistemi i\u00e7in yapabiliyoruz. Ama\u00e7 Packer'\u0131n yerini almak de\u011fil zaten. Hatta packer NixOS'u da kullanabilir. Ayr\u0131ca Packer'\u0131n bir paket y\u00f6netici olmad\u0131\u011f\u0131n\u0131 tekrar hat\u0131rlat\u0131yorum</p> <p>Packer, \u00f6nceden yap\u0131land\u0131r\u0131lm\u0131\u015f bir yap\u0131y\u0131 al\u0131r ve bu yap\u0131 \u00fczerinde bir dizi ad\u0131m\u0131 (\u00f6rne\u011fin, kurulum, yap\u0131land\u0131rma, paket y\u00fckleme) ger\u00e7ekle\u015ftirerek sonu\u00e7 olarak bir sanal makine g\u00f6r\u00fcnt\u00fcs\u00fc veya konteyner g\u00f6r\u00fcnt\u00fcs\u00fc olu\u015fturur. NixOS ise tamamen beyaz kutu bir yakla\u015f\u0131m benimser. Kullan\u0131c\u0131lar, Nix ifadeleriyle i\u015fletim sisteminin her y\u00f6n\u00fcn\u00fc a\u00e7\u0131k\u00e7a belirtirler. Bu, her \u015feyin tam olarak nas\u0131l yap\u0131land\u0131r\u0131laca\u011f\u0131n\u0131 kontrol etmelerine olanak tan\u0131r. Bu sayede Nix dok\u00fcmanlar\u0131n\u0131z Packer dok\u00fcmanlar\u0131n\u0131zdan farkl\u0131 olarak canl\u0131d\u0131r. Yani sistem \u00e7al\u0131\u015f\u0131rken bile konfig\u00fcrasyonu de\u011fi\u015ftirebilir ve tekrar \u00e7al\u0131\u015ft\u0131rabilirsiniz.</p>"},{"location":"index.html#neden-nixos-kullanmamalyz","title":"Neden NixOS Kullanmamal\u0131y\u0131z?","text":"<p>Sadece paket y\u00f6neticisindeki paketleri kurar \u00e7al\u0131\u015ft\u0131r\u0131r\u0131m geriyle ilgilenmiyorum diyen bir son kullan\u0131c\u0131ysan\u0131z bir sat\u0131r komutla t\u00fcm sisteminizi kurabilirsiniz. B\u00fcy\u00fck ihtimal bir uygulama NixOS paket y\u00f6neticisinde yoksa ba\u015fka bir yerde yoktur.</p> <p>Linux da\u011f\u0131t\u0131mlar\u0131n\u0131n istatistiklerinin yay\u0131nland\u0131\u011f\u0131 Repology sayfas\u0131ndaki rakamlara g\u00f6re Nix paket reposunda en yak\u0131n Arch Linux'un AUR paket y\u00f6neticisinden farkl\u0131 17 bin adet daha fazla paket var. Buna tabi Nix'in resmi paket y\u00f6neticisinde olmayan Github, Gitlab, hatta bir FTP adresi veya bir URL \u00fczerinden de y\u00fckleyebilece\u011finiz Nix paketleri hari\u00e7. Nix paket y\u00f6neticisi ile yaz\u0131lm\u0131\u015f bir paketi do\u011frudan herhangi bir adresten y\u00fckeyebilirsiniz. Paket y\u00f6netcisi bunu cache sunucular\u0131nda bulamazsa local sistemde build alabilir.</p> <p> </p> <p>Ayr\u0131ca sisteme bir \u015fey kurdum patlad\u0131 gibi bir durumda rollback yapmak m\u00fcmk\u00fcn. Dolay\u0131s\u0131yla bu tarz bir son kullan\u0131c\u0131ysan\u0131z sadece bir uygulaman\u0131n ad\u0131n\u0131 yazman\u0131z yeterli kurulum i\u00e7in. Hatta onlarca yeni uygulaman\u0131n ad\u0131n\u0131 listeye ekleyip, baz\u0131lar\u0131n listeden silip veya baz\u0131lar\u0131 \u00fczerinde de\u011fi\u015fiklik yap\u0131p tek seferde b\u00fct\u00fcn de\u011fi\u015fikli\u011fi sisteminize uygulayabilirsiniz.</p> <p>Yani ki\u015fisel hayat\u0131n\u0131zda uzman olsan\u0131z da olmasan\u0131z da zevkle kullanabilece\u011finiz bir i\u015fletim sistemi. E\u011fer i\u015f bilgisayar\u0131n\u0131zda kullanacaksan\u0131z ufak tefek problem \u00e7\u00f6zebilecek kadar NixOS'a hakim olman\u0131z gerekebilir.</p> <p>Ancak e\u011fer amac\u0131n\u0131z hakikaten sistemin uzman\u0131 olmak ve profesyonel olarak i\u015f hayat\u0131n\u0131zda da kullanmaksa altta s\u0131ralayaca\u011f\u0131m maddeleri dikkate alman\u0131zda fayda var.</p> <ul> <li>\u00c7ok b\u00fcy\u00fck faydalar\u0131 olmas\u0131na ra\u011fmen konfor alan\u0131n\u0131zdan uzakla\u015f\u0131p yorucu bir \u00f6\u011frenme s\u00fcrecine girmeniz gerekiyor. Mevzuya hakim olmak i\u00e7in en az\u0131ndan fonksiyonel bir dil olan Nix'i \u00f6\u011frenmeniz gerekiyor.</li> <li>\u00d6\u011frenme s\u00fcresince y\u00fczlerce kez deneme yan\u0131lma yapmak zorunda kalacaks\u0131n\u0131z. Bak\u0131\u015f a\u00e7\u0131m\u0131z\u0131 de\u011fi\u015ftirmemiz gerekiyor ancak dok\u00fcmanlar yetersiz ayr\u0131ca topluluk da herkese yeti\u015femiyor. Toplulu\u011fun verdi\u011fi \u00f6rnekler ya \u00e7ok basit veya tarihi ge\u00e7mi\u015f \u00e7ok karma\u015f\u0131k \u00f6rnekler.</li> <li>Bir\u00e7ok durumu ilk kez ya\u015f\u0131yor olacaks\u0131n\u0131z ve bunlar Google i\u00e7in de yeni olacak.</li> <li>Declarative, immutable gibi kavramlar sizin i\u00e7in hi\u00e7 bir \u015fey ifade etmiyorsa b\u00fcy\u00fck yanl\u0131\u015f bir yolda olabilirsiniz.</li> <li>Ki\u015fisel olarak kullanmayacaksan\u0131z, tamamen i\u015f ortam\u0131n\u0131zda NixOS'un avantajlar\u0131ndan faydalanmak i\u00e7in \u00f6\u011frenecekseniz ve ortam\u0131n\u0131zda 3-5 makine varsa att\u0131\u011f\u0131n\u0131z ta\u015f \u00fcrk\u00fctt\u00fc\u011f\u00fcn\u00fcz kurba\u011faya de\u011fmeyebilir.</li> <li>Nix paket y\u00f6neticisini ve NixOS'u inceledi\u011finizde ihtiyac\u0131n\u0131z olup olmad\u0131\u011f\u0131n\u0131 kendiniz anlayam\u0131yorsan\u0131z veya karar vremiyorsan\u0131z NixOS'a bula\u015fman\u0131za gerek olmayabilir.</li> </ul> <p>Ancak hi\u00e7 kullanmayacaksan\u0131z bile kendi kulland\u0131\u011f\u0131n\u0131z da\u011f\u0131t\u0131ma Nix paket y\u00f6neticisini kurman\u0131z\u0131 kesinlikle tavsiye ederim. \u00d6zellikle geli\u015ftirici olarak \u00e7al\u0131\u015f\u0131yorsan\u0131z internette Nix paket y\u00f6neticisi \u00fczerine kurulu bir \u00e7ok ara\u00e7 var. Hatta illa geli\u015ftirici olman\u0131za gerek yok ayn\u0131 anda bir uygulaman\u0131n birden faza versiyonunu kullan\u0131yorsan\u0131z da tercih edebilirsiniz. \u0130lerleyen yaz\u0131larda bu konuya de\u011finiyoruz ama yine de altta en \u00e7ok kullan\u0131lanlar\u0131 ekledim.</p> <p>\u00d6rne\u011fin Python, NodeJS, Java, Dotnet vb programlama dillerinin biri veya bir ka\u00e7\u0131nda fakl\u0131 versiyonlarda uygulama geli\u015ftiriyorsunuz diyelim. Bu durumda \u00f6rne\u011fin NodeJS i\u00e7in nvm, Python i\u00e7in virtualenv benzeri ara\u00e7lar kullanabilirsiniz. Ancak programlama dilleri d\u0131\u015f\u0131ndaki uygulamalar\u0131n b\u00f6yle bir yetene\u011fi yok. Ayr\u0131ca her biri i\u00e7in ayr\u0131 ayr\u0131 uygulama y\u00f6netmektense declarative olarak y\u00f6netebilece\u011finiz tek bir ara\u00e7 daha mant\u0131kl\u0131 g\u00f6r\u00fcn\u00fcyor. Di\u011fer bir sebepte Nix paket y\u00f6neticisi bilgisayar\u0131n\u0131z kirletmeden sandbox olarak bunu y\u00f6netiyor.</p> <ul> <li>devbox: Aralar\u0131nda en \u00e7ok kullan\u0131lan ve en \u00e7ok y\u0131ld\u0131z alan proje bu. \u0130ncelemenizi kesinlikle tavsiye ederim. Dockerhub benzeri nixhub ad\u0131nda bir paket deposu var. Burada arama yapabiliyorsunuz. Go dili ile yaz\u0131lm\u0131\u015f bir cli'\u0131 var. Quickstart i\u00e7in \u015fu sayfay\u0131 ziyaret edebilirsiniz.</li> <li>devshell</li> <li>devpacks</li> <li>devenv</li> </ul> <p>K\u0131sa bir giri\u015f yapt\u0131k. Amac\u0131m Nix Paket y\u00f6neticisine ve NiXOS'a ilgi uyand\u0131rmakt\u0131. E\u011fer ilginizi \u00e7ektiyse makale serisine devam edebilirsiniz.</p> <p>Umar\u0131m faydal\u0131 olmu\u015ftur.</p>"},{"location":"index.html#referanslar","title":"Referanslar","text":"<ul> <li>https://nix-community.github.io/awesome-nix/</li> <li>https://en.wikipedia.org/wiki/NixOS</li> <li>https://nixos.wiki/wiki/Nix_Ecosystem</li> <li>https://github.com/hlissner/dotfiles#frequently-asked-questions</li> </ul> <ol> <li> <p>Nix: A Safe and Policy-Free System for Software Deployment \u21a9</p> </li> <li> <p>NixOS Stack \u21a9</p> </li> <li> <p>Resim Kayna\u011f\u0131 \u21a9</p> </li> <li> <p>Tablo Kaynak \u21a9</p> </li> </ol>"},{"location":"module_ve_option_kullanimi.html","title":"Module ve Option Kullan\u0131m\u0131","text":"<p>Bu yaz\u0131 b\u00fcy\u00fck ihtimal serinin en uzun yaz\u0131s\u0131 olacak. Konuyu b\u00fcy\u00fck ihtimal tek seferde okuyup bitirmek isteyeceksiniz. Belki en \u00e7ok git gel yapaca\u011f\u0131n\u0131z yaz\u0131 da bu olacak.</p> <p>Bu yaz\u0131da ilk yaz\u0131lar\u0131m\u0131zda s\u0131k\u00e7a kulland\u0131\u011f\u0131m\u0131z <code>nix repl</code> arac\u0131n\u0131 bol bol kullanaca\u011f\u0131z. Module yazarken s\u0131k\u00e7a yap\u0131lan hatalar\u0131 inceleyece\u011fiz. Bu yaz\u0131da amac\u0131m\u0131z do\u011frudan \u00e7al\u0131\u015fabilir module yazmak de\u011fil. ONu da bir sonraki yaz\u0131m\u0131zda yapaca\u011f\u0131z. Yani Orta halli bir NixOS konfig\u00fcrasyonu yapaca\u011f\u0131z. Orada ihtiyac\u0131m\u0131z olan bir ka\u00e7 mod\u00fcl\u00fc de yazm\u0131\u015f olaca\u011f\u0131z.</p> <p>\u0130lk yaz\u0131lar\u0131m\u0131zda <code>nix repl</code> arac\u0131n\u0131 s\u0131k s\u0131k kullanm\u0131\u015ft\u0131k. Ancak do\u011frudan bu sayfaya gelenler veya unutmu\u015f olanlar i\u00e7in ufak bir bahsedelim.</p> <p>Terminalden <code>nix repl</code> dedi\u011fimizde cli a\u00e7\u0131lacakt\u0131r. Burada ama\u00e7 developer'lar i\u00e7in kodlar\u0131n\u0131 tet edebilecekleri hatalar\u0131n\u0131 g\u00f6rebilecekleri bir ara\u00e7 sunmak. <code>:?</code> komutu ile alttaki yard\u0131m metnine ula\u015fabilirsiniz.</p> <pre><code>The following commands are available:\n\n  &lt;expr&gt;                       Evaluate and print expression\n  &lt;x&gt; = &lt;expr&gt;                 Bind expression to variable\n  :a, :add &lt;expr&gt;              Add attributes from resulting set to scope\n  :b &lt;expr&gt;                    Build a derivation\n  :bl &lt;expr&gt;                   Build a derivation, creating GC roots in the\n                               working directory\n  :e, :edit &lt;expr&gt;             Open package or function in $EDITOR\n  :i &lt;expr&gt;                    Build derivation, then install result into\n                               current profile\n  :l, :load &lt;path&gt;             Load Nix expression and add it to scope\n  :lf, :load-flake &lt;ref&gt;       Load Nix flake and add it to scope\n  :p, :print &lt;expr&gt;            Evaluate and print expression recursively\n  :q, :quit                    Exit nix-repl\n  :r, :reload                  Reload all files\n  :sh &lt;expr&gt;                   Build dependencies of derivation, then start\n                               nix-shell\n  :t &lt;expr&gt;                    Describe result of evaluation\n  :u &lt;expr&gt;                    Build derivation, then start nix-shell\n  :doc &lt;expr&gt;                  Show documentation of a builtin function\n  :log &lt;expr&gt;                  Show logs for a derivation\n  :te, :trace-enable [bool]    Enable, disable or toggle showing traces for\n                               errors\n  :?, :help                    Brings up this help menu\n</code></pre> <p>Nix dosyalar\u0131na yazd\u0131\u011f\u0131m\u0131z expression'lar\u0131 do\u011frudan repl i\u00e7ine yaz\u0131p \u00e7a\u011f\u0131rabiliriz ya da bir nix dosyas\u0131n\u0131 load (:l) komutu ile repl i\u00e7ine y\u00fckleyebiliriz. Olu\u015fan verileri de print (:p) komutu ile g\u00f6rebiliriz.</p> <pre><code>nix-repl&gt; a = [1 2 3 4]\n\nnix-repl&gt; a\n#[ 1 2 3 4 ]\n\nnix-repl&gt; :p a\n#[ 1 2 3 4 ]\n\nnix-repl&gt; b = {a=1;b=2;c=3;}\n\nnix-repl&gt; :p b\n#{ a = 1; b = 2; c = 3; }\n\nnix-repl&gt; func = a: b: a + b\n\nnix-repl&gt; result = func 1 2\n\nnix-repl&gt; :p result\n#3\n</code></pre> <p>Biraz kurcalayarak rahatl\u0131kla uzman\u0131 olabilirsiniz. Ancak tabi Nix dilinin uzman\u0131 olmak biraz vakit alabilir. Bunun i\u00e7in ilk yaz\u0131lar\u0131m\u0131z\u0131 okuyabilirsiniz. Repl hakk\u0131nda daha fazla bilgi almak i\u00e7in \u015fu sayfay\u0131 da ziyaret edebilirsiniz.</p> <p>Di\u011fer bir yararl\u0131 ara\u00e7 da <code>nix eval</code> komutu. Bu komut ile bir nix dosyas\u0131n\u0131 \u00e7al\u0131\u015ft\u0131rabilir ve sonucunu g\u00f6rebilirsiniz.</p> <pre><code>nix eval --raw nixpkgs#lib.version\n#24.05.20240223.48b75eb%\n\n\nnix eval --raw nixpkgs#hello\n#/nix/store/63l345l7dgcfz789w1y93j1540czafqh-hello-2.12.1%\n\n\nnix eval --write-to ./out --expr '{ foo = \"bar\"; subdir.bla = \"123\"; }'\ncat ./out/foo\n# bar\ncat ./out/subdir/bla\n#123\n</code></pre> <p>Module yap\u0131s\u0131 ile ilgili t\u00fcm gerekenler lib k\u00fct\u00fcphanesi i\u00e7inde yer al\u0131yor. Resmi sayfas\u0131nda lib klas\u00f6r\u00fcndeki default.nix dosyas\u0131na bakacak olursan\u0131z alttaki sat\u0131lar\u0131 g\u00f6rebilirsiniz. Modules dosyas\u0131nda mod\u00fcllerle ilgili fonksiyonlar yer al\u0131rken options dosyas\u0131nda ise option'larla ilgili fonksiyonlar yer al\u0131r. Tabi ben b\u00f6yle yaz\u0131nca mant\u0131kl\u0131 geliyor :) zaten \u00f6yle olmamal\u0131 m\u0131yd\u0131? diyebilirsiniz. Ancak kod yazarken \u00f6zellikle bir module yazarken bu ayr\u0131m\u0131 yapmak bazen zor olabiliyor. Kafan\u0131z kar\u0131\u015ft\u0131\u011f\u0131nda dedi\u011fimi hat\u0131rlars\u0131n\u0131z.</p> <pre><code># k\u0131salt\u0131ld\u0131\n\n    # module system\n    modules = callLibs ./modules.nix;\n    options = callLibs ./options.nix;\n    types = callLibs ./types.nix;\n\n# k\u0131salt\u0131ld\u0131\n</code></pre> <p>Bazen hata bulmak veya ne yapaca\u011f\u0131n\u0131z\u0131 anlayabilmek i\u00e7in bu dosyalara bakmam\u0131z gerekebilir.</p> <p>Modules dosyas\u0131nda bir \u00e7ok fonksiyon bulunuyor ancak bizim \u00e7ok iyi bilmemiz gerekenler kal\u0131n olarak i\u015faretlediklerim.</p> evalModules filterOverrides filterOverrides' fixMergeModules fixupOptionType # should be private? importJSON importTOML mergeDefinitions mergeAttrDefinitionsWithPrio mergeOptionDecls mkAfter mkAliasAndWrapDefinitions mkAliasAndWrapDefsWithPriority mkAliasDefinitions mkAliasIfDef mkAliasOptionModule mkAliasOptionModuleMD mkAssert mkBefore mkChangedOptionModule mkDefault mkDerivedConfig mkFixStrictness mkForce mkIf mkImageMediaOverride mkMerge mkMergedOptionModule mkOptionDefault mkOrder mkOverride mkRemovedOptionModule mkRenamedOptionModule mkRenamedOptionModuleWith mkVMOverride setDefaultModuleLocation sortProperties; <p>Options Doyas\u0131na bakacak olursak alttaki gibi bir liste ile kar\u015f\u0131la\u015f\u0131yoruz. Burada da yine iyi bilmemiz gerekenleri kal\u0131n olarak i\u015faretledim.</p> isOption mkOption mkEnableOption mkPackageOption mkPackageOptionMD mergeDefaultOption mergeOneOption mergeUniqueOption mergeEqualOption getValues getFiles optionAttrSetToDocList scrubOptionValue renderOptionValue literalExpression mdDoc literalMD showOption showFiles showDefs <p>types dosyas\u0131nda ise alttaki tiplerin tan\u0131m\u0131n g\u00f6rebiliriz.</p> bool true, false boolByOr e\u011fer iki tan\u0131mlama da true ise sonu\u00e7 true'dur. path path tan\u0131mlamak i\u00e7in kullan\u0131l\u0131r. e\u011fer paket tan\u0131m\u0131/adresi kullan\u0131lacaksa, yani ama\u00e7 bir paketse package tipi kullan\u0131lmal\u0131 package bir derivation veya flake i\u00e7eren path pathInStore nix store i\u00e7eren bir path anything tip bilinmedi\u011finde kullan\u0131labilir raw e\u011fer tip checking, merging veya nested evaluation yapm\u0131yorsa kullan\u0131labilir. pkgs paket seti int tam say\u0131 ints tam say\u0131 seti ints.positive pozitif tam say\u0131lar port port numaras\u0131 float noktal\u0131 say\u0131 number float veya int olabilir str metin ifadesi lines sat\u0131rlardan olu\u015fan string ifade commas virg\u00fcl ile birle\u015ftirilmi\u015f metinler envVar iki nokta \u00fcst \u00fcste (\\:) ile birle\u015ftirilmi\u015f metinler strmathing regular expression ile e\u015fle\u015fen metin. Ayr\u0131 de\u011ferler tekrarlamaz submodule, submoduleWith bir ba\u015fka module'u ifade eden tip listOf t t tipinde liste attrOf t value de\u011ferlerinin tipi t olan set nullOr t null veya t tipi uniq t t tipi sadece bir kez ifade edilebilir. Birden fazla de\u011fer merge edilemez oneOf [ t1 t2 \u2026 ] tiplerden biri either t1 t2 t1 tipi veya t2 tipi coercedTo from f to from tipinde bir tip al\u0131p to tipini d\u00f6nd\u00fcren bir fonksiyon <p>Submodule tipi i\u00e7in bir ka\u00e7 a\u00e7\u0131klama yapmam\u0131z gerekiyor.</p>"},{"location":"module_ve_option_kullanimi.html#custom-type","title":"Custom Type","text":"<p>Bunu i\u00e7in mkOptionType fonksiyonu kullan\u0131l\u0131r. Resmi dok\u00fcmanlar\u0131nda da denildi\u011fi gibi custom yip yazmak biraz \u00e7etrefilli bir i\u015f. Ben de zaten giri\u015f mahiyetinde bir \u015feyler yazaca\u011f\u0131m.</p> <p>Amac\u0131m\u0131z kullanaca\u011f\u0131m\u0131z option ve mod\u00fcllerde ge\u00e7en terim ve tabirlere de a\u015fina olmak.</p> <p>Gerekli parametreler</p> <ul> <li>name : Tipin ad\u0131</li> <li>description: Tipin a\u00e7\u0131klamas\u0131</li> <li>check: Tipin i\u00e7in type check fonksiyonu. True ve false d\u00f6nd\u00fcrmelidir.</li> <li>merge: Birden fazla de\u011fer merge edilirken kullan\u0131lacak fonksiyon. Bir tip i\u00e7in birden fazla de\u011fer farkl\u0131 yerlerde atanm\u0131\u015f olabilir. Bunlar\u0131n merge edilirken nas\u0131l birle\u015ftirilece\u011fini belirler. Sonu\u00e7ta nihai bir de\u011fer elde etmek i\u00e7in kullan\u0131l\u0131r.</li> <li>getSubModules: Submodule tipleri \u00fcretmek i\u00e7in gereklidir.</li> <li>getSubOptions: B\u00fct\u00fcn submodule'lerin option'lar\u0131na eri\u015fmek i\u00e7in kullan\u0131l\u0131r.</li> <li>substSubModules: Bir mod\u00fcl\u00fc parametre olarak al\u0131r ve geriye mod\u00fcl\u00fcn parametrelerini de\u011fi\u015ftirerek d\u00f6nd\u00fcr\u00fcr.</li> </ul> <p>\u00d6zet olarak tipleri kullan\u0131rken bu ba\u015fl\u0131ktan \u00e7\u0131kartaca\u011f\u0131m\u0131z sonu\u00e7lar</p> <ul> <li>tiplerin t\u00fcr\u00fc \u00f6nemli</li> <li>ve tiplerini merge edilmesi gibi bir durum var bu nedenle do\u011fru de\u011ferlerle ve \u00f6ncelikle do\u011fru belirlenerek kullan\u0131lmalar\u0131 gerekiyor.</li> </ul>"},{"location":"module_ve_option_kullanimi.html#module-ve-option-kullanm_1","title":"Module ve Option Kullan\u0131m\u0131","text":"<p>\u015eimdi \u00f6rneklerle mevzuyu anlamaya \u00e7al\u0131\u015fal\u0131m. \u00d6zellikle belirtmedi\u011fim s\u00fcrece bu yaz\u0131da yapt\u0131klar\u0131m\u0131 Nix kurulu herhangi bir sistemde yapabilirsiniz.</p> <p>Alttaki gibi basit bir module (default.nix) yazal\u0131m.</p> <pre><code># default.nix\n { lib, ... }: {\n\n    options = {\n      scripts.output = lib.mkOption {\n        type = lib.types.lines;\n      };\n    };\n\n }\n</code></pre> <p>Daha sonra yazd\u0131\u011f\u0131m\u0131z mod\u00fcl\u00fcn\u00fc do\u011frulama i\u00e7in evaluate fonksiyonunda ge\u00e7irelim. Bu fonksiyon Nix dili i\u00e7inde bulunan ve mod\u00fcl dosyalar\u0131n\u0131 de\u011ferlendirmek i\u00e7in kullan\u0131lan bir fonksiyondur. Bu fonksiyon, bir veya birden fazla Nix mod\u00fcl dosyas\u0131n\u0131 y\u00fckler, de\u011ferlendirir ve sonu\u00e7lar\u0131 birle\u015ftirir.</p> <pre><code># eval.nix\nlet\n  system = \"x86_64-linux\";\n  pkgs = import &lt;nixpkgs&gt; {inherit system; config = {allowUnfree = true;}; overlays = []; };\nin\npkgs.lib.evalModules {\n  modules = [\n    ./default.nix\n  ];\n}\n</code></pre> <p>evalModules fonksiyonunun i\u00e7eri\u011fini g\u00f6rmek i\u00e7in repl i\u00e7inde alttaki komutlar\u0131 \u00e7al\u0131\u015ft\u0131rabilirsiniz. G\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere tek zorunlu parametre modules. Di\u011fer parametreler ise opsiyonel.</p> <pre><code># nix paket koleksiyonunu indiriyoruz\n:l &lt;nixpkgs&gt;\n\n# evalModules i\u00e7er\u011fini editleme modunda a\u00e7\u0131yoruz.\n# \u00e7\u0131kmak i\u00e7in ctrl+q yapmal\u0131s\u0131n\u0131z.\n:e lib.evalModules\n\n# k\u0131salt\u0131ld\u0131\n# evalModules = evalModulesArgs@\n#                 { modules\n#                 , prefix ? []\n#                 , specialArgs ? {}\n#                 , class ? null\n#                 , args ? {}\n#                 , check ? true\n#                 }:\n#     let\n#       withWarnings = x:\n# k\u0131salt\u0131ld\u0131\n</code></pre> <p>\u015eimdi kodumuzu test edelim.</p> <pre><code>nix eval -f eval.nix\n\n# error: The option `scripts.output' is used but not defined.\n</code></pre> <p>Sonu\u00e7 olarak bir option tan\u0131mlad\u0131\u011f\u0131m\u0131z\u0131 ancak kullanmad\u0131\u011f\u0131m\u0131z belirten bir hata ald\u0131k.</p> <p>Ayn\u0131 testi repl i\u00e7inde de yapabiliriz.</p> <pre><code>myModule = import ./eval.nix\n:p myModule\n# error: The option `scripts.output' is used but not defined.\u00bb; }; }; }; type = \u00abrepeated\u00bb; }\n</code></pre> <p>Benzer bi hata ald\u0131k.</p> <p>O zaman config blo\u011fumuzu tan\u0131mlayal\u0131m. default.nix dosyam\u0131z\u0131 alttaki gibi de\u011fi\u015ftirelim.</p> <pre><code># default.nix\n { lib, ... }: {\n\n    options = {\n      scripts.output = lib.mkOption {\n        type = lib.types.lines;\n      };\n    };\n\n    config = {\n     scripts.output = 42;\n    };\n }\n</code></pre> <p>\u015eimdi tekrar test edelim.</p> <pre><code>nix eval -f eval.nix\n\n# error: A definition for option `scripts.output' is not of type `strings concatenated with \"\\n\"'. Definition values:\n# - In `/home/.../.../default.nix': 42\n</code></pre> <p>Evet gayet mant\u0131kl\u0131 bir hata ald\u0131k. \u00c7\u00fcnk\u00fc bizim tan\u0131mlad\u0131\u011f\u0131m\u0131z tip lines iken biz bir say\u0131 tan\u0131mlad\u0131k.</p> <pre><code># default.nix\n { lib, ... }: {\n\n    options = {\n      scripts.output = lib.mkOption {\n        type = lib.types.lines;\n      };\n    };\n\n    config = {\n     scripts.output = \"wget https://www.google.com -O /etc/test.txt\";\n    };\n }\n</code></pre> <p>\u015eimdi test etti\u011fimizde ise alttaki gibi bir durum g\u00f6rd\u00fck. Bu durum belki siz bakt\u0131\u011f\u0131n\u0131zda d\u00fczelmi\u015f olabilir. Bu yaz\u0131 dizisinde tamamen yeni teknolojiye uygun komutlar\u0131n g\u00f6rece\u011fimizden bahsetmi\u015ftim ancak ilk kez burada t\u0131kand\u0131k. Temel sebebi ise Nix Github sayfas\u0131ndan da takip edebilece\u011finiz \u00fczere halen bir \u00e7ok komutun stabil olmamas\u0131. Yani bu vakte kadar kullan\u0131mda bir problem ya\u015famad\u0131k ki sadece ben de\u011fil internette de g\u00f6rebilece\u011finiz \u00fczere bir\u00e7ok ki\u015fi son s\u00fcr\u00fcm komutlar\u0131 kullan\u0131yor. Zaten bu ya\u015fad\u0131\u011f\u0131m\u0131z durumda \u00e7al\u0131\u015fmas\u0131na engel bir durum de\u011fil. <code>evalModule</code> fonksiyonu bildi\u011fimiz \u00fczere ger\u00e7ekten kodlar\u0131 \u00e7al\u0131\u015ft\u0131rm\u0131yor. Bu nedenle \u00f6zel durumlar\u0131 y\u00f6netmek \u00fczere dizayn edilmemi\u015f. Ancak burada ya\u015fanan durumu <code>nix eval</code> komutu handle etmeliydi ancak o da en az\u0131ndan bu durumu y\u00f6netemiyor. Bu nedenle eski komutlardan biri olan <code>nix-instantiate</code> komutunu kullanarak test edebiliriz.</p> <pre><code>nix eval -f eval.nix\n\n# trace: warning: Use `stdenv.tests` instead. `passthru` is a `mkDerivation` detail.\n# trace: warning: Use `stdenv.tests` instead. `passthru` is a `mkDerivation` detail.\n# trace: warning: Use `stdenv.tests` instead. `passthru` is a `mkDerivation` detail.\n# trace: warning: Use `stdenv.tests` instead. `passthru` is a `mkDerivation` detail.\n# trace: warning: Use `stdenv.tests` instead. `passthru` is a `mkDerivation` detail.\n# trace: warning: Use `stdenv.tests` instead. `passthru` is a `mkDerivation` detail.\n</code></pre> <p><code>nix-instantiate</code> ile test etmek i\u00e7in de alttaki komutu kullanabiliriz. Komut ile eval.nix dosyas\u0131n\u0131 config blo\u011funun \u00fcretti\u011fi sonu\u00e7lar\u0131 \u00e7a\u011f\u0131rabiliyoruz.</p> <pre><code>nix-instantiate --eval eval.nix -A config.scripts.output\n# \"wget https://www.google.com -O /etc/test.txt\"\n</code></pre> <p>\u015eimdi paket \u00fcreten bir option tan\u0131mlayal\u0131m. Amac\u0131m\u0131z nixpkgs koleksiyonundan bir paketi kullanarak bir shell script'i yaz\u0131p bunu paket olarak option olarak mod\u00fclle ayarlamak. Bunu yaparken de script'i daha \u00f6nce olu\u015fturdu\u011fumuz <code>scripts.output</code> option'\u0131ndan alaca\u011f\u0131z.</p> <p>Bu i\u015flemleri yapabilmemiz i\u00e7in default.nix dosyam\u0131za pkgs ve config parametrelerini eklememiz gerekiyor. Hat\u0131rlarsan\u0131z yukar\u0131da ayn\u0131 mod\u00fcl i\u00e7inde dahi olsalar bir option'a do\u011frudan de\u011fil merkezi config setinden eri\u015fmemiz gerekiyor demi\u015ftik. <code>script.paket</code> option de\u011ferini atad\u0131\u011f\u0131m\u0131z yerde <code>config.scripts.output</code> de\u011ferini kulland\u0131\u011f\u0131m\u0131za dikkat edin.</p> <pre><code># default.nix\n\n{ lib, pkgs,config,... }: {\n\n    options = {\n      scripts.paket = lib.mkOption {\n        type = lib.types.lines;\n      };\n\n       scripts.output = lib.mkOption {\n         type = lib.types.package;\n       };\n\n    };\n\n    config = {\n      scripts.output = \"wget https://www.google.com -O /etc/test.txt\";\n\n      scripts.paket = pkgs.writeShellApplication {\n                 name = \"create-etc\";\n                 runtimeInputs = with pkgs; [ wget ];\n                 text = config.scripts.output;\n     };\n\n    };\n }\n</code></pre> <p>Eval.nix dosyam\u0131z\u0131 da alttaki gibi de\u011fi\u015ftirelim. Mod\u00fcl\u00fcm\u00fcz art\u0131k pkgs ve config parametrelerini de istiyor. Ancak biz sadece pkgs parametresini haz\u0131rlasak yeterli olacakt\u0131r. \u00c7\u00fcnk\u00fc config ve lib parametresi mod\u00fcl\u00fcn i\u00e7ine mod\u00fcl eko-sistemi/kurgusu taraf\u0131ndan otomatik olarak ekleniyor.</p> <pre><code>#eval.nix\n\nlet\n\n  system = \"x86_64-linux\";\n  pkgs = import &lt;nixpkgs&gt; {inherit system; config = {allowUnfree = true;}; overlays = []; };\n\n\n\nin\n  pkgs.lib.evalModules {\n\n    modules = [\n              # alttaki sat\u0131r\u0131 kapat\u0131p specialArg'\u0131 kulland\u0131k. Burada asl\u0131nda anonymous foksiyon a\u00e7l\u0131\u015ft\u0131r\u0131p bir mod\u00fcl d\u00f6nd\u00fcr\u00fcyoruz  asl\u0131nda.\n              # bu mod\u00fclde ba\u011fl\u0131 oldu\u011fu mod\u00fcn bir arg\u00fcman\u0131n\u0131 dolduruyor.\n              # specialArgs ise do\u011frudan mod\u00fcl\u00fcn argumanlar\u0131n\u0131 ekliyor.\n              #({ config, ... }: { config._module.args = { pkgs = pkgs; }; })\n               ./default.nix\n              ];\n                specialArgs = {pkgs = pkgs; };\n\n  }\n</code></pre> <pre><code>nix-instantiate --eval eval.nix -A config.scripts.paket\n\n# sonu\u00e7 olarak elimizde bir paketin attribute'lar\u0131 listelenmi\u015f oldu.\n# { __ignoreNulls = true; __structuredAttrs = false; all = &lt;CODE&gt;; allowSubstitutes = true; args = &lt;CODE&gt;; buildCommand = &lt;CODE&gt;; buildInputs = &lt;CODE&gt;; builder = &lt;CODE&gt;; checkPhase = &lt;CODE&gt;; cmakeFlags = &lt;CODE&gt;; configureFlags = &lt;CODE&gt;; depsBuildBuild = &lt;CODE&gt;; depsBuildBuildPropagated = &lt;CODE&gt;;\n</code></pre>"},{"location":"module_ve_option_kullanimi.html#bir-modulu-baska-bir-module-eklemek","title":"Bir Mod\u00fcl\u00fc Ba\u015fka Bir Mod\u00fcle Eklemek","text":"<p>Bir mod\u00fcl i\u00e7ine ba\u015fka mod\u00fcl de ekleyebiliriz. \u00d6rne\u011fin alttaki gibi bir mod\u00fcl (my-module.nix) yazal\u0131m. Config blo\u011fu i\u00e7inde <code>scripts.output</code> ile default alt\u0131ndaki config'de de yapt\u0131\u011f\u0131m\u0131z ataman\u0131n ayn \u0131s\u0131n\u0131 yapt\u0131k. Yani ayn\u0131 konfig\u00fcrasyon farkl\u0131 mod\u00fcllerde tekrar yap\u0131ld\u0131 yani.</p> <pre><code># my-module.nix\n{ lib, pkgs,config,... }: {\n\n    options = {\n\n      apps.message = lib.mkOption {\n        type = lib.types.package;\n      };\n\n    };\n\n    config = {\n              apps.message = pkgs.writeShellApplication {\n                                      name = \"hello-app\";\n                                      runtimeInputs = with pkgs; [ cowsay ];\n                                      text = ''\n                                                cowsay ${config.scripts.output}\n                                              '';\n                    };\n              scripts.output = ''\n                      sample script\n                      '';\n                    };\n              };\n}\n</code></pre> <p>Bu mod\u00fcl\u00fc default.nix dosyas\u0131na imports listesi ekleyebiliriz ekleyelim.</p> <pre><code>{ lib, pkgs,config,... }:{\n    imports = [\n      ./my-module.nix\n    ];\n\n    options = {\n      scripts.output = lib.mkOption {\n          type = lib.types.lines;\n      };\n\n      scripts.paket = lib.mkOption {\n          type = lib.types.package;\n      };\n\n    };\n\n    config = {\n      scripts.output = ''\n                      wget https://www.google.com -O /etc/test.txt\n                      '';\n\n      scripts.paket = pkgs.writeShellApplication {\n                                      name = \"create-etc\";\n                                      runtimeInputs = with pkgs; [ wget ];\n                                      text = config.scripts.output;\n      };\n\n  };\n}\n</code></pre>"},{"location":"module_ve_option_kullanimi.html#submodule-kullanm","title":"Submodule Kullan\u0131m\u0131","text":"<p>Bir tip tan\u0131m\u0131 i\u00e7in let ve in bloklar\u0131n\u0131 kullanmam\u0131z gerekiyor. Burada bir submodule tipi olu\u015fturduk ancak bunu haz\u0131r tipleri kullanarak yapt\u0131k. Submodule'den kas\u0131t bir \u00f6nceki \u00f6rnekte g\u00f6rd\u00fc\u011f\u00fcm\u00fcz gibi bir mod\u00fcl\u00fc ba\u015fka bir mod\u00fcl\u00fcn i\u00e7ine eklemek de\u011fildir. Burada asl\u0131nda bir module ve i\u00e7indeki option'lar\u0131 birle\u015ftiren bir tip tan\u0131m\u0131 (subModuleType) yapm\u0131\u015f oluyoruz.</p> <p>\u0130lgin\u00e7 olan bu tipi kullanarak olu\u015fturdu\u011fumuz mymodules option'unun tipinin daha \u00f6nce olu\u015fturdu\u011fumuz submodule tipinde liste tutuyor olmas\u0131 <code>lib.types.listOf subModuleType;</code>.</p> <pre><code># default.nix\n{ lib, pkgs,config,... }:\n\nlet\n\n      # bir submodule tipi olu\u015fturduk ve i\u00e7erisine message ad\u0131nda bir opsiyon ekledik\n      subModuleType = lib.types.submodule {\n          options = {\n            message = lib.mkOption {\n              type = lib.types.nullOr lib.types.str;\n              default = null;\n            };\n          };\n      };\nin\n{\n    imports = [\n      ./my-module.nix\n    ];\n\n    options = {\n      scripts.output = lib.mkOption {\n          type = lib.types.lines;\n      };\n\n      scripts.paket = lib.mkOption {\n          type = lib.types.package;\n      };\n\n\n      mymodules = lib.mkOption {\n        # dikkat edilirse subModuleType submodule listesi isteyen bir tip tan\u0131m\u0131m\u0131z var\n        type = lib.types.listOf subModuleType;\n      };\n\n    };\n\n    config = {\n      scripts.output = ''\n                      wget https://www.google.com -O /etc/test.txt\n                      '';\n\n      scripts.paket = pkgs.writeShellApplication {\n                                      name = \"create-etc\";\n                                      runtimeInputs = with pkgs; [ wget ];\n                                      text = config.scripts.output;\n      };\n\n    mymodules = [\n      {message = \"Hello World!\";}\n      {message = \"how are you?\";}\n    ];\n\n    };\n}\n</code></pre> <p>\u015eimdi bu mod\u00fcl\u00fc test edelim. \u0130ki eleman ekledi\u011fimiz i\u00e7in sonu\u00e7ta iki eleman\u0131n da d\u00f6nd\u00fc\u011f\u00fcn\u00fc g\u00f6rece\u011fiz.</p> <pre><code>nix-instantiate --eval eval.nix -A config.mymodules\n# [ &lt;CODE&gt; &lt;CODE&gt; ]\n</code></pre> <p>Bu arada i\u00e7 i\u00e7e submodule tan\u0131mlamak da m\u00fcmk\u00fcn. Detaylar\u0131n\u0131 \u015fu sayfadan bakabilirsiniz.</p>"},{"location":"module_ve_option_kullanimi.html#mkif-mkmerge-mkforce-mkdefault-mkoverride-kullanm","title":"mkIf, mkMerge, mkForce, mkDefault, mkOverride Kullan\u0131m\u0131","text":"<p>Belki akl\u0131m\u0131za neden <code>if else</code> yap\u0131s\u0131 kullanm\u0131yoruz da mkIf fonksiyonu kullan\u0131yoruz sorusu akl\u0131m\u0131za gelebilir. Bunun sebebi normal <code>if else</code> kullan\u0131m\u0131n\u0131n bizi recursion hatas\u0131na g\u00f6t\u00fcrece\u011fi. Bu y\u00fczden mkIf fonksiyonu module kullan\u0131m\u0131 i\u00e7in yaz\u0131lm\u0131\u015f. A\u015fa\u011f\u0131da mkIf ile yapaca\u011f\u0131m\u0131z \u00f6rnekleri isterseniz <code>if else</code> yap\u0131s\u0131 ile de yapabilir ve sonucu g\u00f6rebilirsiniz.</p> <p><code>mkIf</code> fonksiyonunun kullan\u0131m\u0131 \u00e7ok basit.</p> <pre><code>mkIf 1=1 \"yes\"\n# veya di\u011fer \u00f6rnek\n\nmkIf !(1=2) \"no\"\n</code></pre> <p>Normalde mhIfElse gibi bir fonksiyon yok. Ancak forumlarda ara\u015ft\u0131r\u0131rsan\u0131z s\u0131kl\u0131kla alttaki gibi bir yap\u0131y\u0131 g\u00f6rebilirsiniz. Bu tarz bir fonksiyon yazarak if else yap\u0131s\u0131 olu\u015fturabilirsiniz.</p> <pre><code>mkIfElse = p: yes: no: mkMerge [\n  (mkIf p yes)\n  (mkIf (!p) no)\n];\n</code></pre> <p>mkMerge farkl\u0131 konfig\u00fcrasyonlar\u0131 birle\u015ftirmek i\u00e7in kullan\u0131l\u0131r. \u00d6rne\u011fin alttaki gibi bir kullan\u0131m yapabiliriz. <code>mkIf</code> ile bir ko\u015fula ba\u011fl\u0131 konfig\u00fcrasyon ba\u015fka bir grup konfig\u00fcrasyonla birle\u015ftirilebilir.</p> <pre><code>config = mkMerge\n  [ # Unconditional stuff.\n    { environment.systemPackages = [ ... ];\n    }\n    # Conditional stuff.\n    (mkIf config.services.bla.enable {\n      environment.systemPackages = [ ... ];\n    })\n  ];\n</code></pre> <p><code>my-module.nix</code> dosyam\u0131z\u0131 \u00e7al\u0131m ve alttaki de\u011fi\u015fiklikleri yapal\u0131m.</p> <pre><code>{ lib, pkgs, config,... }: {\n\n    options = {\n\n      apps.message.paket = lib.mkOption {\n        type = lib.types.package;\n      };\n\n      apps.message.iswebsiteBing = lib.mkOption {\n        type = lib.types.bool;\n        default = false;\n      };\n\n\n    };\n\n    config = lib.mkMerge [ {\n                              apps.message.paket = pkgs.writeShellApplication {\n                                      name = \"hello-app\";\n                                      runtimeInputs = with pkgs; [ cowsay ];\n                                      text = ''\n                                                cowsay ${config.scripts.output}\n                                              '';\n                                  };\n                              apps.message.iswebsiteBing = true;\n                        }\n\n\n                        (lib.mkIf config.apps.message.iswebsiteBing {\n                                              scripts.output = ''\n                                                          wget https://www.bing.com -O /etc/test.txt\n                                                                            ''; })\n                    ];\n}\n</code></pre> <p>\u00d6nceki versiyonunda hat\u0131rlarsan\u0131z zaten default.nix mod\u00fcl\u00fcm\u00fczde tan\u0131mland\u0131\u011f\u0131m\u0131z ve atamas\u0131 yap\u0131lm\u0131\u015f <code>scripts.output</code> opiton'\u0131n\u0131n\u0131 alttaki gibi <code>my-module.nix</code> dosyas\u0131nda tekrar tan\u0131mlam\u0131\u015ft\u0131k.</p> <pre><code>scripts.output = ''\n                wget https://www.google.com -O /etc/test.txt\n                '';\n</code></pre> <p>Yeni versiyonda ise <code>mkIf</code> fonksiyonu ile <code>apps.message.iswebsiteBing</code> option'\u0131na ba\u011fl\u0131 olarak <code>scripts.output</code> option'\u0131n\u0131 tekrar tan\u0131mlad\u0131k. Config blo\u011funu art\u0131k mkMerge ile farkl\u0131 kombinasyonlar\u0131 merge (birle\u015ftirecek) \u015fekilde tan\u0131mlad\u0131\u011f\u0131m\u0131za dikkat edin.</p> <p>\u015eimdi bu de\u011fi\u015fiklikten sonra tekrar test edelim.</p> <pre><code>nix-instantiate --eval eval.nix -A config.scripts.output\n# \"wget https://www.bing.com -O /etc/test.txt\\n\\nwget https://www.google.com -O /etc/test.txt\\n\"\n</code></pre> <p>Sonu\u00e7ta bir gariplik oldu\u011funu g\u00f6rebiliyoruz. Hem <code>default.nix</code> hem de <code>my-module.nix</code> dosyalar\u0131nda atad\u0131\u011f\u0131m\u0131z de\u011ferleri birle\u015ftirerek bize d\u00f6nd\u00fcrd\u00fc. E\u011fer bizim i\u00e7in <code>my-module.nix</code> mod\u00fcl\u00fcndeki atama di\u011fer b\u00fct\u00fcn mod\u00fcllerdeki atamalardan \u00f6nemliyse o zaman mkForce fonksiyonunu kullanmal\u0131y\u0131z. Kodu alttaki gibi d\u00fczenliyoruz.</p> <pre><code>                        (lib.mkIf config.apps.message.iswebsiteBing {\n                                              scripts.output = lib.mkForce ''\n                                                          wget https://www.bing.com -O /etc/test.txt\n                                                                            ''; })\n</code></pre> <p>Tekrar test etti\u011fimizde art\u0131k sonucun d\u00fczeldi\u011fini g\u00f6rebiliyoruz.</p> <pre><code>nix-instantiate --eval eval.nix -A config.scripts.output --show-trace\n# \"wget https://www.bing.com -O /etc/test.txt\\n\"\n</code></pre> <p><code>mkForce</code> fonksiyonunun nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 anlarsak di\u011ferlerini de \u00e7\u00f6zm\u00fc\u015f olaca\u011f\u0131z. Bunun i\u00e7in <code>lib.modules.nix</code> dosyas\u0131na bir g\u00f6z atal\u0131m. Kod blo\u011funa \u015fu linkten ula\u015fabilirsiniz.</p> <pre><code># modules.nix\n\n# K\u0131salt\u0131ld\u0131\n  mkOverride = priority: content:\n    { _type = \"override\";\n      inherit priority content;\n    };\n\n  mkOptionDefault = mkOverride 1500; # priority of option defaults\n  mkDefault = mkOverride 1000; # used in config sections of non-user modules to set a default\n  defaultOverridePriority = 100;\n  mkImageMediaOverride = mkOverride 60; # image media profiles can be derived by inclusion into host config, hence needing to override host config, but do allow user to mkForce\n  mkForce = mkOverride 50;\n  mkVMOverride = mkOverride 10; # used by \u2018nixos-rebuild build-vm\u2019\n\n  defaultPriority = lib.warnIf (lib.isInOldestRelease 2305) \"lib.modules.defaultPriority is deprecated, please use lib.modules.defaultOverridePriority instead.\" defaultOverridePriority;\n\n  mkFixStrictness = lib.warn \"lib.mkFixStrictness has no effect and will be removed. It returns its argument unmodified, so you can just remove any calls.\" id;\n\n  mkOrder = priority: content:\n    { _type = \"order\";\n      inherit priority content;\n    };\n\n  mkBefore = mkOrder 500;\n  defaultOrderPriority = 1000;\n  mkAfter = mkOrder 1500;\n# K\u0131salt\u0131ld\u0131\n</code></pre> <p><code>mkForce = mkOverride 50;</code> sat\u0131r\u0131na dikkat ederseniz mkOverride ile de\u011feri 50 olarak atanm\u0131\u015f. Burada d\u00fc\u015f\u00fck de\u011fer daha \u00fcstte bir de\u011fer. <code>mkDefault = mkOverride 1000;</code> sat\u0131r\u0131 ile default de\u011ferin 1000 oldu\u011funu g\u00f6rebiliyoruz. Dolay\u0131s\u0131yla <code>mkForce</code> fonksiyonu ile bir de\u011fer atad\u0131\u011f\u0131m\u0131zda bu de\u011fer di\u011fer b\u00fct\u00fcn de\u011ferlerden \u00f6ncelikli oluyor.</p> <p>Normal \u015fartlarda mod\u00fclleri import ederken s\u0131ralama yapmam\u0131za gerek yoktur. Hat\u0131rlarsan\u0131z <code>default.nix</code> dosyam\u0131zda imports diye mod\u00fcle adreslerinin listesini tutan bir de\u011fi\u015fkenimiz vard\u0131.Diyelim ki ayn\u0131 opiton'\u0131n de\u011ferini farkl\u0131 iki mod\u00fcle de\u011fi\u015ftiriyor olsun. Bu durumda bu iki module import edildi\u011finde ikinci import edilen birincideki de\u011feri ezecektir. Ancak conflict olu\u015fturan bir durum olursa bunu bizim \u00e7\u00f6zmemiz gerekir.</p> <p>Birde conflict durumunu \u00f6rnekleyelim. Ad\u0131<code>my-module-first.nix</code> olan bir dosya olu\u015ftural\u0131m. i\u00e7eri\u011fi de alttaki gibi olsun. Bu sefer <code>my-module.nix</code> i\u00e7inde olu\u015fturdu\u011fumuz ve atamas\u0131n\u0131 ad yapt\u0131\u011f\u0131m\u0131z <code>apps.message.iswebsiteBing</code> option'\u0131n\u0131n de\u011ferini bu sefer false olarak ayarlad\u0131k.</p> <pre><code>{ lib, config,... }: {config = { apps.message.iswebsiteBing = false; };}\n</code></pre> <p>Bu mod\u00fcl\u00fc <code>default.nix</code> dosyas\u0131ndaki imports listesine birinci ve di\u011fer mod\u00fcl de ikinci olarak ekleyelim. Yani alttaki gibi olacak.</p> <p>Olay\u0131 bi anlamaya \u00e7al\u0131\u015fal\u0131m. Normalde <code>default.nix</code> dosyas\u0131nda tan\u0131ml\u0131 olan <code>scripts.output</code> option'\u0131 google.com'a giderken biz onu iswebsiteBing option'\u0131 true olursa mkForce fonksiyonunu kullanarak bing.com'a gidecek \u015fekilde <code>my-module.nix</code> dosyam\u0131zda ayarlam\u0131\u015ft\u0131k.</p> <p>\u015eimdi yeni mod\u00fcl\u00fcm\u00fczde ise iswebsiteBing option'\u0131 false olarak ayarlad\u0131k. Bu durumda <code>default.nix</code> dosyas\u0131nda tan\u0131ml\u0131 olan <code>scripts.output</code> option'\u0131 google.com'a gidecek \u015fekilde ayarlanmas\u0131n\u0131 bekliyoruz.</p> <pre><code># default.nix\n    imports = [\n      ./my-module-first.nix\n      ./my-module.nix\n    ];\n</code></pre> <p>Bi test edelim bakal\u0131m.</p> <pre><code>nix-instantiate --eval eval.nix -A config.scripts.output --show-trace\n\n# error: The option `apps.message.iswebsiteBing' has conflicting definition values:\n#  - In `/home/.../tests/my-module.nix': true\n#  - In `/home/.../tests/my-module-first.nix': false\n#  Use `lib.mkForce value` or `lib.mkDefault value` to change the priority on any of these definitions.\n</code></pre> <p>Fakat conflict olu\u015ftu ve sebebi de gayet a\u00e7\u0131k. Biri true derken di\u011feri false diyor. Bu tarz bir durumu mesela lattaki gibi bir kod yazsayd\u0131k da ya\u015fayacakt\u0131k</p> <pre><code>{ lib, config,... }: {config = { apps.message.iswebsiteBing = lib.mkMerge [false true]; };}\n</code></pre> <p>i\u015fte bu tarz bi durumu y\u00f6netmek i\u00e7in de mkOverride fonksiyonu kullan\u0131labilir. <code>my-module-first.nix</code> dosyas\u0131n\u0131 alttaki gibi de\u011fi\u015ftirelim.</p> <pre><code>{ lib, config,... }: {config = { apps.message.iswebsiteBing = lib.mkOverride 50 false; };}\n</code></pre> <p>Tekrar test edelim.</p> <pre><code># nix-instantiate --eval eval.nix -A config.scripts.output --show-trace\n\"wget https://www.google.com -O /etc/test.txt\\n\"\n</code></pre> <p>Ve evet sonu\u00e7 istedi\u011fimiz gibi oldu. Yani sonradan y\u00fcklenen mod\u00fcl\u00fcn option de\u011feri daha \u00f6ncelikli olmas\u0131na ra\u011fmen onu mkOverride ile ezmi\u015f olduk. Yukar\u0131da g\u00f6rece\u011finiz \u00fczere mkForce fonksiyonu \u00f6nceli\u011fi 50 olarak ayarl\u0131yor ancak bir mkOverride ile daha 30 olarak ayarlad\u0131\u011f\u0131m\u0131z i\u00e7in sonu\u00e7ta mkOverride fonksiyonu daha \u00f6ncelikli oldu.</p>"},{"location":"module_ve_option_kullanimi.html#mkorder-mkbefore-ve-mkafter-kullanm","title":"mkOrder, mkBefore ve mkAfter Kullan\u0131m\u0131","text":"<p>Bazen de bir de\u011fer iki farkl\u0131 yerde atanabilir ancak conflict olu\u015fturmayabilir. Conflict durumlar\u0131 \u00e7o\u011funlukla scalar ve boolean de\u011ferlerde olur ki bu da gayet normal. Boolean'a \u00f6rnek olarak mesela bir \u015feye hem do\u011fru hem yanl\u0131\u015f diyemeyiz. Scalar'a \u00f6rnek olarak mesela bir ses seviyesine hem 50 hem de 100 diyemeyiz. Ama mesela bir isim listesini farkl\u0131 \u015fekillerde atayabiliriz. Yani her atamada farkl\u0131 isimler olabilir. Bu durumda conflict olu\u015fmaz.</p> <p>Conflict olu\u015fturmayan bu tip durumlarda bazen sonra eklenen mod\u00fcl \u00f6ncekini ezer yada \u00f6rne\u011fin bir liste ise bunlar birle\u015ftirilir ancak yine sonra gelen \u00f6ncekinden daha \u00f6nce listeye eklenir.. Ancak bu i\u015fimize gelmeyebilir. Yani biz \u00f6nce ekledi\u011fimiz mod\u00fcl\u00fcn sonrakinden daha \u00f6ncelikli olmas\u0131n\u0131 isteyebiliriz.</p> <p>Birde bunun i\u00e7in \u00f6rnek yapal\u0131m.</p> <p><code>my-module.nix</code> dosyas\u0131n\u0131 alttaki gibi de\u011fi\u015ftirelim. Str (metin) ti\u011finde liste tutan bir option ekleyip daha sonra<code>apps.message.list = [ \"test4\" \"test5\" \"test6\" ];</code> \u015feklinde de\u011ferler ekledik.</p> <pre><code>{ lib, pkgs, config,... }: {\n\n    options = {\n\n      apps.message.paket = lib.mkOption {\n        type = lib.types.package;\n      };\n\n      apps.message.iswebsiteBing = lib.mkOption {\n        type = lib.types.bool;\n        default = false;\n      };\n\n\n      apps.message.list = lib.mkOption {\n        type = lib.types.listOf lib.types.str;\n      };\n\n\n    };\n\n    config = lib.mkMerge [ {\n                              apps.message.paket = pkgs.writeShellApplication {\n                                      name = \"hello-app\";\n                                      runtimeInputs = with pkgs; [ cowsay ];\n                                      text = ''\n                                                cowsay ${config.scripts.output}\n                                              '';\n                                  };\n                              apps.message.iswebsiteBing = true;\n\n                              apps.message.list = [ \"test4\" \"test5\" \"test6\" ];\n\n\n                        }\n\n\n                        (lib.mkIf config.apps.message.iswebsiteBing {\n                                              scripts.output = lib.mkOverride 100 ''\n                                                          wget https://www.bing.com -O /etc/test.txt\n                                                                            ''; })\n\n\n                    ];\n}\n</code></pre> <p><code>my-module-first.nix</code> dosyas\u0131n\u0131 da alttaki gibi de\u011fi\u015ftirdik.</p> <pre><code>{ lib, config,... }: {\n  config = {\n    apps.message.iswebsiteBing = lib.mkOverride 50 false;\n    apps.message.list = [ \"test1\" \"test2\" \"test3\" ];\n    };\n  }\n</code></pre> <p><code>default.nix</code> dosyas\u0131nda ise <code>my-module-first.nix</code> mod\u00fcl\u00fcn\u00fc <code>my-module.nix</code> mod\u00fcl\u00fcnden \u00f6nce import etmi\u015ftik. Bu haliyle test edelim. Sonu string ve xmp parametreleriyle ald\u0131k \u00e7\u00fcnk\u00fc bunlar\u0131 koymad\u0131\u011f\u0131m\u0131zda sistem listedeki de\u011ferleri hesaplam\u0131yor.</p> <pre><code>nix-instantiate --eval eval.nix -A config.apps.message.list --xml --strict\n\n# &lt;?xml version='1.0' encoding='utf-8'?&gt;\n# &lt;expr&gt;\n#   &lt;list&gt;\n#     &lt;string value=\"test4\" /&gt;\n#     &lt;string value=\"test5\" /&gt;\n#     &lt;string value=\"test6\" /&gt;\n#     &lt;string value=\"test1\" /&gt;\n#     &lt;string value=\"test2\" /&gt;\n#     &lt;string value=\"test3\" /&gt;\n#   &lt;/list&gt;\n# &lt;/expr&gt;\n</code></pre> <p>G\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere sistem sonra eklenen mod\u00fcldeki de\u011ferleri listeye daha \u00f6nce ekledi mer ederken.Halbuki biz de\u011ferleri s\u0131ral\u0131 istiyorduk diyelim. Bu durumda <code>my-module-first.nix</code> mod\u00fcl\u00fcnde alttaki gibi de\u011fi\u015fiklik yap\u0131yoruz.</p> <pre><code>{ lib, config,... }: {\n\n  config = {\n    apps.message.iswebsiteBing = lib.mkOverride 50 false;\n    apps.message.list =lib.mkBefore [ \"test1\" \"test2\" \"test3\" ];\n    };\n\n  }\n</code></pre> <p>\u015eimdi test edelim. Evet sonu\u00e7 istedi\u011fimiz gibi oldu.</p> <pre><code>nix-instantiate --eval eval.nix -A config.apps.message.list --xml --strict\n# &lt;?xml version='1.0' encoding='utf-8'?&gt;\n# &lt;expr&gt;\n#   &lt;list&gt;\n#     &lt;string value=\"test1\" /&gt;\n#     &lt;string value=\"test2\" /&gt;\n#     &lt;string value=\"test3\" /&gt;\n#     &lt;string value=\"test4\" /&gt;\n#     &lt;string value=\"test5\" /&gt;\n#     &lt;string value=\"test6\" /&gt;\n#   &lt;/list&gt;\n# &lt;/expr&gt;\n</code></pre> <p>E\u011fer buradaki mod\u00fclden daha fazla yerde atama yapm\u0131\u015f olsayd\u0131k bu durumda mkOrder fonksiyonunu kullanacakt\u0131k. Her bir mod\u00fclde alttaki gibi bir s\u0131ra no verecektik.</p> <pre><code>{ lib, config,... }: {\n\n  config = {\n    apps.message.iswebsiteBing = lib.mkOverride 50 false;\n    apps.message.list =lib.mkOrder 10 [ \"test1\" \"test2\" \"test3\" ];\n    };\n\n  }\n</code></pre> <p>Evet bu yaz\u0131m\u0131z\u0131n da sonuna geldik. Bu yaz\u0131m\u0131zda somut olarak mod\u00fcl yazmad\u0131k. Amac\u0131m\u0131z yazarken nelere dikkat etmeliyiz ve nas\u0131l hata \u00e7\u00f6zebiliriz buna odaklanmakt\u0131. Bir sonraki yaz\u0131m\u0131zda art\u0131k somut olarak bir \u00f6nceki yaz\u0131m\u0131zda kurmu\u015f oldu\u011fumuz NixOS kurulumundan devam edece\u011fiz, home-manager'\u0131 inceleyece\u011fiz.</p>"},{"location":"module_ve_option_kullanimi.html#modul-ve-optionlar-daha-detayl-ogrenmek-icin-kaynaklar","title":"Mod\u00fcl ve Option'lar\u0131 Daha Detayl\u0131 \u00d6\u011frenmek \u0130\u00e7in Kaynaklar","text":"<ul> <li>NixOS manual</li> <li>NixOS Wiki</li> <li>Nix Language</li> <li>NixOS Non-Official</li> </ul>"},{"location":"module_ve_option_kullanimi.html#kaynaklar","title":"Kaynaklar","text":"<ul> <li>https://github.com/Misterio77/nix-starter-configs/tree/main</li> <li>https://nixos-and-flakes.thiscute.world/nixos-with-flakes/modularize-the-configuration</li> <li>https://www.tweag.io/blog/2020-07-31-nixos-flakes/</li> <li>https://jade.fyi/blog/flakes-arent-real/</li> <li>https://github.com/mikeroyal/NixOS-Guide</li> <li>https://nixos.wiki/wiki/NixOS_modules</li> <li>https://nix.dev/tutorials/module-system/module-system.html</li> <li>https://nixos.org/manual/nixos/stable/#sec-writing-modules</li> <li>https://dev.to/dooygoy/100-days-of-nixos-346e</li> <li>https://github.com/rasendubi/dotfiles</li> </ul>"},{"location":"nix_ile_nix_konfigurasyonu.html","title":"Nix ile NixOS Konfig\u00fcrasyonu","text":"<p>Bu yaz\u0131ya do\u011frudan NixOS i\u00e7in geldiyseniz yani ge\u00e7mi\u015f yaz\u0131lar\u0131 okumadan do\u011frudan NixOS hakk\u0131nda bir \u015feyler okumak i\u00e7in geldiyseniz ve NixOS hakk\u0131nda da hi\u00e7 bir bilginiz yoksa \u00f6ncelikle serinin ilk yaz\u0131s\u0131n\u0131 okuman\u0131z\u0131 tavsiye ederim.</p> <p>Girizgah\u0131 bir \u00f6nceki yaz\u0131dan kopyalayarak konuya giri\u015f yapal\u0131m.</p> <p>Konumuz NixOS, NixOS'a ge\u00e7i\u015f yapaca\u011f\u0131z ancak ilk etapta nas\u0131l kurulur konusuna girmeyece\u011fiz. \u00c7\u00fcnk\u00fc ilk kurulum i\u00e7in asl\u0131nda normal herhangi bir Linux da\u011f\u0131t\u0131m\u0131ndan farkl\u0131 kurulmuyor. Ancak elimizde bir Nix konfig\u00fcrasyonu varsa durum biraz de\u011fi\u015fiyor. Bu durumda sadece flake.nix dosyas\u0131n\u0131 da i\u00e7eren root dizini kurulum esnas\u0131nda g\u00f6stermemiz yeterli olacakt\u0131r.</p> <p>Yaz\u0131lar\u0131m\u0131 haz\u0131rlarken veya bir \u015feyler test ederken Hashicorp Vagrant \u00fcr\u00fcn\u00fcn\u00fc \u00e7ok s\u0131k kullan\u0131yorum. Kurulumu olduk\u00e7a basit ve kullan\u0131\u015fl\u0131. Vagrant ile 2-3 sat\u0131rl\u0131k bir komutla sanal makine aya\u011fa kald\u0131rabilirsiniz.</p> <p>Windows, Mac ve Linux i\u00e7in kurulum yap\u0131labiliyor. \u015eu linkten kurulumu yapabilirsiniz.</p> <p>Alttaki komutlar\u0131 terminalde veya powershell'de \u00e7al\u0131\u015ft\u0131rarak bir NixOS i\u015fletim sistemi aya\u011fa kald\u0131rabilirsiniz.</p> <pre><code>vagrant init hennersz/nixos-23.05-flakes\nvagrant up\n</code></pre> <p>Kurulum bittikten sonra ayr\u0131 terminal a\u00e7\u0131kken <code>vagrant ssh</code> komutu ile sanal makineye ba\u011flanabilirsiniz. \u0130leride de test etmek bir \u015fey denemek i\u00e7in kullanabilirsiniz.</p> <p>Ancak Vagrant'dan indirece\u011fimiz image \u00fczerinde baz\u0131 \u015feyler haz\u0131r geldi\u011fi i\u00e7in ben de s\u0131f\u0131r ISO indirip kuraca\u011f\u0131m. \u015eu sayfada \"NixOS: the Linux distribution\" ba\u015fl\u0131\u011f\u0131nda ISO dosyalar\u0131n\u0131 indirebilirsiniz. Download ederken ve kurulumda kolayl\u0131k olmas\u0131 i\u00e7in GUI i\u00e7eren bir versiyonu KDE ve GNOME tercih edece\u011fiz ancak kurulum s\u0131ras\u0131nda GUI se\u00e7mede yal\u0131n bir kurulum yapaca\u011f\u0131z.</p> <p></p> <p>ISO'yu indirdikten sonra herhangi bir sanalla\u015ft\u0131rma sistemiyle kurulum yapabilirsiniz. Bir kullan\u0131c\u0131 da VirtualBox oldu\u011fu i\u00e7in ben de onu tercih edece\u011fim. Zaman, \u00fclke ve klavye ayarlar\u0131n\u0131 T\u00fcrkiye olarak se\u00e7meyi unutmay\u0131n. Sanalla\u015ft\u0131rma sisteminizde verdi\u011finiz diskin de tamam\u0131n\u0131 otomatik b\u00f6l\u00fcmlendirebilirsiniz.</p> <p>Ben KDE ile devam ediyorum. Kurulum s\u0131ras\u0131ndaki ayarlar\u0131 g\u00f6steren ekran g\u00f6r\u00fcnt\u00fclerini altta veriyorum.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Kurulum bitti\u011finde sanal makineyi kapat\u0131p ISO dosyas\u0131n\u0131 \u00e7\u0131kart\u0131p tekrar ba\u015flat\u0131yoruz. Sistem a\u00e7\u0131ld\u0131\u011f\u0131nda login oluyoruz. \u0130lk olarak b\u00fcy\u00fck ihtimal sizin de ya\u015fayaca\u011f\u0131n\u0131z tahmin etti\u011fim ekran boyutu problemi ile kar\u015f\u0131la\u015faca\u011f\u0131z. Bunu \u00e7\u00f6zmeye u\u011fra\u015fmaya \u015fuan hi\u00e7 grek yok. Onun yerine SSH'\u0131 aktif edip ssh ile ba\u011flanaca\u011f\u0131z. Bunun i\u00e7in ileride bir \u00e7ok kez a\u00e7\u0131p detayl\u0131 olarak \u00e7al\u0131\u015faca\u011f\u0131m\u0131z <code>/etc/nixos/configuration.nix</code> dosyas\u0131n\u0131 nano ile a\u00e7\u0131yoruz. Nano dememin sebebi ise hen\u00fcz sistemde vim'in kurulu olmamas\u0131. Alttaki sat\u0131rlar\u0131 bulup a\u00e7\u0131klama sat\u0131r\u0131n\u0131 kapat\u0131yoruz. Yani openssh'\u0131 aktif edip firewall'\u0131 kapat\u0131yoruz.</p> <pre><code>  # Enable the OpenSSH daemon.\n   services.openssh.enable = true;\n\n  # Open ports in the firewall.\n  # networking.firewall.allowedTCPPorts = [ ... ];\n  # networking.firewall.allowedUDPPorts = [ ... ];\n  # Or disable the firewall altogether.\n   networking.firewall.enable = false;\n</code></pre> <p>Daha sonra terminal'den <code>sudo nixos-rebuild switch</code> komutu ile sistemi update ediyoruz. Asl\u0131nda yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fikli\u011fi sisteme uyguluyoruz. Art\u0131k ssh ile ba\u011flanabiliriz. Bunun i\u00e7in host makinenizde terminal a\u00e7\u0131p <code>ssh kullanici_adiniz@192.168.1.1</code> komutuyla ba\u011flanabilirsiniz. sanal makinenizin ip adresini ve kullan\u0131c\u0131 ad\u0131n\u0131z de\u011fi\u015ftirmeyi unutmazs\u0131n\u0131z ama ben yine de uyaray\u0131m :).</p> <p>Daha sonra flake'i enable etmeniz gerekiyor. Bunun i\u00e7in login olduktan sonra <code>/etc/nixos/configuration.nix</code> dosyas\u0131na <code>nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ];</code> ekliyoruz. Dosyan\u0131n en \u00fcst\u00fcne hardware-configuration.nix y\u00fcklendikten sonra ekleyebiliriz.</p> <pre><code># Edit this configuration file to define what should be installed on\n# your system.  Help is available in the configuration.nix(5) man page\n# and in the NixOS manual (accessible by running \u2018nixos-help\u2019).\n\n{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Include the results of the hardware scan.\n      ./hardware-configuration.nix\n    ];\n\n nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ];\n</code></pre> <p>Daha sonra <code>/etc/nixos/flake.nix</code> dosyas\u0131n\u0131 olu\u015fturup i\u00e7ine alttaki sat\u0131rlar\u0131 kopyal\u0131yoruz.</p> <pre><code>{\n  description = \"Murat Cabuk NixOS Configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.11\";\n  };\n\n  outputs = { self, nixpkgs, ... }@inputs: {\n\n    nixosConfigurations.nixos = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [\n        ./configuration.nix\n      ];\n    };\n  };\n}\n</code></pre> <p>Son olarak alttaki komutla komutu ile sistemi update ediyoruz. Nokta ile flake.nix dosyam\u0131z\u0131n ayn\u0131 dizinde oldu\u011funu, #nixos ile de flake.nix dosyas\u0131nda <code>nixosConfigurations.nixos = ...</code> sat\u0131r\u0131nda yazan konfig\u00fcrasyon ad\u0131n\u0131 yani burada nixos kelimesini girmi\u015f oluyoruz. E\u011fer de\u011fi\u015ftirmediyseniz nixos yaz\u0131yor olmas\u0131 laz\u0131m.</p> <pre><code>sudo nixos-rebuild switch --flake .#nixos\n</code></pre> <p>Evet art\u0131k Flake enable edilmi\u015f bir NixOS sistemine sahibiz. \u015eimdi biraz neler yapt\u0131k tam olarak ne d\u00f6n\u00fcyor onun \u00fczerine konu\u015fal\u0131m.</p> <p>Daha \u00f6nce de bahsetmi\u015ftik, bir flake output olarak alttakileri \u00fcretebilir.</p> <ul> <li>Nix Paketleri</li> <li>Nix Geli\u015ftirme Ortamlar\u0131</li> <li>NixOS Mod\u00fclleri (Nix Configuration)</li> <li>Nix Template'leri (haz\u0131r flake dosyalar\u0131)</li> </ul> <p>\u0130lk ikisini zaten g\u00f6rd\u00fck. \u015eimdi amac\u0131m\u0131z NixOS konfig\u00fcrasyon ve mod\u00fcllerini \u00fcretmek ve kullanmak. Sonuncusuna zaten hi\u00e7 girmeyece\u011fiz, en az\u0131ndan bu yaz\u0131 Nix \u00d6\u011freniyoruz serisinde girmeyece\u011fiz.</p> <p>Nix paketlerini olu\u015ftururken flake i\u00e7inde hat\u0131rlarsan\u0131z mkDerivation fonksiyonu kulland\u0131k. Geli\u015ftirme ortam\u0131 olu\u015fturmak i\u00e7in mkShell fonksiyonu kullanm\u0131\u015ft\u0131k. Konfig\u00fcrasyon olu\u015fturmak i\u00e7in de <code>nixpkgs.lib.nixosSystem</code> fonksiyonunu kullan\u0131yoruz, yukar\u0131da da kulland\u0131\u011f\u0131m\u0131z flake kodlar\u0131nda da g\u00f6rebilirsiniz.</p> <pre><code>{\n  description = \"Murat Cabuk NixOS Configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.11\";\n  };\n\n  outputs = { self, nixpkgs, ... }@inputs: {\n\n    nixosConfigurations.nixos = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [\n        ./configuration.nix\n      ];\n    };\n  };\n}\n</code></pre> <p>Burada en basit haliyle birden fazla konfig\u00fcrasyonu yay\u0131nlayabilece\u011fimizi de anlayabiliyoruz. Yani <code>nixosConfigurations.nixos</code> sat\u0131r\u0131ndaki nixos kelimesini de\u011fi\u015ftirip ba\u015fka bir konfig\u00fcrasyon olu\u015fturabiliriz. \u0130kinci anlayabilece\u011fimiz konu ise modules kavram\u0131. Configuration.nix dosyam\u0131z\u0131n bir module oldu\u011funu ve bir liste i\u00e7inde kullan\u0131ld\u0131\u011f\u0131ndan dolay\u0131 birden fazla mod\u00fcl\u00fc bir arada kullanabilece\u011fimizi anlayabiliyoruz.</p>"},{"location":"nix_ile_nix_konfigurasyonu.html#module-kavram","title":"Module Kavram\u0131","text":"<p>\u015eimdi Module kavram\u0131na biraz daha detayl\u0131 bakal\u0131m. Configuration dosyas\u0131n\u0131 incelemeye ba\u015flad\u0131\u011f\u0131m\u0131zda baz\u0131 kavramlar\u0131 teorik olsa da \u00f6\u011frenmemiz gerekiyor. \u00d6ncelikle buradaki module kavram\u0131n\u0131n Nix dilindeki module kavram\u0131yla bir ilgisi yok.Nix dilindeki module kavram\u0131 generic bir tan\u0131m. Herhangi bir nix dosyas\u0131n\u0131 import etmemiz module olarak adland\u0131r\u0131l\u0131yor. Buradaki module kavram\u0131 NixOS konfig\u00fcrasyonu i\u00e7in kullan\u0131lan bir kavram ve bir standard\u0131 var. Alttaki gibi tan\u0131m\u0131 var ancak ayr\u0131ca fonksiyon olarak da tan\u0131mlamak m\u00fcmk\u00fcn.</p> <pre><code>{\n  imports = [\n    # Di\u011fer mod\u00fcller\n  ];\n\n  options = {\n    # Option tan\u0131mlar\u0131.\n    # Kullan\u0131c\u0131lar\u0131n bu mod\u00fcl\u00fc nas\u0131l kullanabilece\u011fini tan\u0131mlar.\n\n  };\n\n  config = {\n    # Bu mod\u00fc\u00fcn ve import edilen di\u011fer mod\u00fcllerin option'lar\u0131n\u0131n ve di\u011fer konfig\u00fcrasyonalr\u0131n ayarlarnd\u0131\u011f\u0131 blok\n  };\n}\n</code></pre> <p>\u00c7o\u011funlukla options ve config bloklar\u0131na ihtiya\u00e7 olmaz bu durumda alttaki gibi bir kullan\u0131m\u0131 var.</p> <pre><code>{\n  imports = [\n      ./module.nix\n  ];\n\n  # \u00f6rnek bir option tan\u0131m\u0131. Bir servis i\u00e7indeki module enable edilmi\u015f.\n  services.othermodule.enable = true;\n  # Bu kullan\u0131mdan art\u0131k config blo\u011funa ihtiya\u00e7 yok.\n}\n</code></pre> <p>Mod\u00fclleri fonksiyon olarak da tan\u0131mlamak m\u00fcmk\u00fcn (ki) biraz b\u00fcy\u00fck \u00e7apl\u0131 konfig\u00fcrasyon yapt\u0131\u011f\u0131m\u0131zda buna \u00e7ok ihtiyac\u0131m\u0131z olacak. Burada ihtiyaca g\u00f6re config ve pkgs d\u0131\u015f\u0131nda parametreler de tan\u0131mlayabiliriz. Ayr\u0131ca iste\u011fe g\u00f6re config ve options tan\u0131mlar\u0131 da yap\u0131labilir. Ancak burada da bir a\u00e7\u0131klama yapay\u0131m parametre olarak gelen config ile i\u00e7eride tan\u0131mlanan config birbirinden farkl\u0131 \u015feyler. Parametre olarak fonksiyona gelen config mod\u00fcl sisteminin lazy de\u011ferlendirmesinin sonucunu tutar; bu de\u011ferlendirme, evalModules'e ge\u00e7irilen t\u00fcm mod\u00fclleri ve bunlar\u0131n import'lar\u0131n\u0131 i\u00e7inde tutar. Bu \u00fczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z module i\u00e7in de ge\u00e7erli. \u00dczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z mod\u00fcldeki config ise mod\u00fcl\u00fcn se\u00e7enek de\u011ferlerini mod\u00fcl sistemi i\u00e7in de\u011ferlendirmeye sunar.</p> <pre><code>{ config, pkgs, ... }:\n{\n  imports = [];\n  # ...\n}\n</code></pre>"},{"location":"nix_ile_nix_konfigurasyonu.html#option-ve-config-kavramlar","title":"Option ve Config Kavramlar\u0131","text":"<p>Peki option ve config tam olarak nedir? i\u00e7ine koyar\u0131z ona bakal\u0131m. OOP d\u00fcnyas\u0131ndan geliyorsan\u0131z bunu property kavram\u0131na benzetebiliriz. Amac\u0131m\u0131z yazd\u0131\u011f\u0131m\u0131z mod\u00fcl\u00fcn kullan\u0131c\u0131 taraf\u0131ndan nas\u0131l kullan\u0131laca\u011f\u0131n\u0131 belirlemek. \u00d6rne\u011fin bir servisi enable etmek istiyoruz. Bu servisin bize sundu\u011fu option yard\u0131m\u0131yla servisi aktif edebiliyoruz.</p> <pre><code>{\n  options = {\n    services.my-service.enable = {\n      type = types.bool;\n      default = false;\n      description = \"Enable my service\";\n    };\n  };\n}\n</code></pre> <p>Burada \u00f6nceli yaz\u0131lar\u0131 takip veya konuyu bilen arkada\u015flar\u0131n akl\u0131na \u015fu soru gelebilir. Neden parametre olarak ge\u00e7miyoruz da option diye bir tan\u0131mlama yap\u0131yoruz?</p> <ul> <li>\u00d6ncelikle karma\u015f\u0131k mod\u00fcllerde parametreleri y\u00f6netmek zorla\u015facakt\u0131r.</li> <li>Malum mod\u00fcller temelde bir i\u015fletim sistemini y\u00f6netmek i\u00e7in kullan\u0131l\u0131yor. Bu de\u011fi\u015fkenlerin tipleri ve de\u011ferleri bu durumda \u00f6nem arzediyor ve belli baz\u0131 kontrollerden ge\u00e7mesi gerekiyor.</li> <li>Son tahlilde b\u00fct\u00fcn kullan\u0131lacak mod\u00fcller tek bir sistemi ayarlamaya \u00e7al\u0131\u015f\u0131yor dolay\u0131s\u0131yla merkezi bir yap\u0131n\u0131n tutarl\u0131l\u0131k i\u00e7in kontrol etmesi gerekiyor.</li> <li>Birde bu option'lar\u0131n \u00f6nceliklerinin y\u00f6netimi s\u00f6z konusu olan yerlerde bu standart ve y\u00f6netimli yap\u0131 i\u015fi kolayla\u015ft\u0131r\u0131yor.</li> <li>Di\u011fer bir sebep de Nix fonksiyonel bir programlama dili ve tan\u0131mlanan bir de\u011fer bir daha de\u011fi\u015ftirilemez yani immutable. Bunu a\u015fmak i\u00e7in daha \u00f6nceki yaz\u0131lar\u0131m\u0131zdan da okuyabilece\u011finiz \u00fczere override mekanizmas\u0131 var. Ancak tabi override mekanizmas\u0131 bile ayn\u0131 de\u011fi\u015fkenin farkl\u0131 yerlerde de\u011fi\u015fimini kontrol edebilecek bir mekanizmaya sahip de\u011fil. Mesela nginx servisini bir mod\u00fclde enable ettiniz bir ba\u015fka mod\u00fclde ise disable ettiniz. Son tahlilde bunlardan bir tanesi ge\u00e7erli olmal\u0131. \u0130\u015fte bunu option'lar yard\u0131m\u0131yla yapabiliyoruz.</li> </ul> <p>Option tan\u0131mlamada belli bir standard\u0131n uygulan\u0131yor olmas\u0131 ve merkezi olarak y\u00f6netilmesi sayesinde bunlara eri\u015fim ve anlama da kolayla\u015fmaktad\u0131r. Herkes kafas\u0131na g\u00f6re fonksiyon yaz\u0131p argument isteyerek bu i\u015fi yapsayd\u0131 ortal\u0131\u011f\u0131n \u00e7ok kar\u0131\u015faca\u011f\u0131 kesin. Standardizasyon sayesinde resmi paket yap\u0131s\u0131ndaki b\u00fct\u00fcn optiion'lar\u0131 aray\u0131p nar\u0131l kullan\u0131lca\u011f\u0131 konusunda bilgi alabiliyoruz. (https://search.nixos.org/options)[https://search.nixos.org/options] adresinden eri\u015febilirsiniz. Mesela alttaki \u00f6rnekteki locate servisini aratt\u0131\u011f\u0131m\u0131zda alttaki gibi bir sonu\u00e7 g\u00f6rece\u011fiz.</p> <p></p> <p>Option tan\u0131mlamak \u015fematik olarak \u00e7ok kolay sadece mkOption fonksiyonunu \u00e7al\u0131\u015ft\u0131rmam\u0131z yeterli. Mesela NixOS manual sayfas\u0131ndan ald\u0131\u011f\u0131 alttaki \u00f6rne\u011fi inceleyelim.</p> <ul> <li>Locale servisini enable/disable etmek i\u00e7in ad\u0131 enable olan bir option tan\u0131mlanm\u0131\u015f.</li> <li>\u0130kinci option ise locate veritaban\u0131n\u0131n belli bir zamanda update edilmesi i\u00e7in tan\u0131mlanan interval option'\u0131.</li> </ul> <p>Ve bu iki option kullan\u0131larak da config blo\u011funda locate servisi ayarlanm\u0131\u015f. Dikkat ederseniz mod\u00fcl\u00fcn config tan\u0131mlamas\u0131nda yine mod\u00fcl\u00fcl\u00fcn option'lar\u0131 kullan\u0131lm\u0131\u015f. Ancak do\u011frudan eri\u015fmek yerine config.servisler.locate \u015feklinde eri\u015filmi\u015f. Sebebi ise yukar\u0131da bahsetti\u011fimiz merkezi yap\u0131y\u0131 korumak. Yani bir option kullan\u0131lacaksa veya de\u011fi\u015ftirilecekse bunun option ve config merkezi sistemi i\u00e7inde yap\u0131lmas\u0131 gerekiyor. Bu nedenle de option hangi servis i\u00e7in tan\u0131mland\u0131ysa o servis <code>cfg = config.services.locate;</code> sat\u0131r\u0131 ile bir de\u011fi\u015fkene atan\u0131yor ve bu de\u011fi\u015fken \u00fczerinden kullan\u0131l\u0131yor.</p> <p>Buradaki \u00f6rnek bir mod\u00fcl tan\u0131m\u0131 ve bu mod\u00fcl nixpkgs alt\u0131nda tan\u0131ml\u0131. Dolay\u0131s\u0131yla biz kendi konfig\u00fcrasyonumuzda interval de\u011ferini <code>services.locate.interval = zaman_de\u011feri</code> \u015feklinde de\u011fi\u015ftirebiliriz.</p> <pre><code>{ config, lib, pkgs, ... }:\n\nwith lib;\n\nlet\n  cfg = config.services.locate;\nin {\n  options.services.locate = {\n    enable = mkOption {\n      type = types.bool;\n      default = false;\n      description = ''\n        If enabled, NixOS will periodically update the database of\n        files used by the locate command.\n      '';\n    };\n\n    interval = mkOption {\n      type = types.str;\n      default = \"02:15\";\n      example = \"hourly\";\n      description = ''\n        Update the locate database at this interval. Updates by\n        default at 2:15 AM every day.\n\n        The format is described in\n        systemd.time(7).\n      '';\n    };\n\n    # Other options omitted for documentation\n  };\n\n  config = {\n    systemd.services.update-locatedb =\n      { description = \"Update Locate Database\";\n        path  = [ pkgs.su ];\n        script =\n          ''\n            mkdir -m 0755 -p $(dirname ${toString cfg.output})\n            exec updatedb \\\n              --localuser=${cfg.localuser} \\\n              ${optionalString (!cfg.includeStore) \"--prunepaths='/nix/store'\"} \\\n              --output=${toString cfg.output} ${concatStringsSep \" \" cfg.extraFlags}\n          '';\n      };\n\n    systemd.timers.update-locatedb = mkIf cfg.enable\n      { description = \"Update timer for locate database\";\n        partOf      = [ \"update-locatedb.service\" ];\n        wantedBy    = [ \"timers.target\" ];\n        timerConfig.OnCalendar = cfg.interval;\n      };\n  };\n}\n</code></pre> <p>mkOption fonksiyonunda kullan\u0131lan arg\u00fcmanlar</p> <ul> <li> <p>type: Option'\u0131n tipini belirtir. Kendi tipimizi de yazabiliriz (kaynak). Tan\u0131ml\u0131 tiplerin listesi i\u00e7in \u015fu sayfay\u0131 ziyaret ediniz.</p> </li> <li> <p>default: Option'\u0131n de\u011feri atanmam\u0131\u015fsa kullan\u0131lacak de\u011fer.</p> </li> <li> <p>defaultText: Karma\u015f\u0131k veriler i\u00e7in kullan\u0131\u015fl\u0131 bir \u00f6zellik. \u00d6zellikle expression yaz\u0131lacaksa veya ba\u015fka paket veya verilere ba\u011f\u0131ml\u0131ysa kullan\u0131\u015fl\u0131d\u0131r.</p> </li> <li> <p>example: NixOS manual dosyalar\u0131 i\u00e7in kullan\u0131l\u0131r.</p> </li> <li> <p>description: Markdown format\u0131nda description yaz\u0131labilir.</p> </li> </ul> <p>Config blo\u011fu ise se\u00e7eneklerin varsay\u0131lan de\u011ferlerini veya kullan\u0131c\u0131 taraf\u0131ndan yap\u0131land\u0131r\u0131lm\u0131\u015f de\u011ferlerini i\u00e7erir. Bu k\u0131s\u0131mda, se\u00e7eneklerin nas\u0131l ayarlanaca\u011f\u0131 veya de\u011fi\u015ftirilece\u011fi tan\u0131mlan\u0131r. Bu \u015fekilde, kullan\u0131c\u0131lar taraf\u0131ndan yap\u0131land\u0131r\u0131lan se\u00e7enekler config b\u00f6l\u00fcm\u00fcnde belirtilen de\u011ferlerle de\u011fi\u015ftirilir.</p> <p>Alttaki \u00e7al\u0131\u015fman\u0131n son halini de Github'daki repo \u00fczerinden inceleyebilirsiniz. Ad\u0131m ad\u0131m her de\u011fi\u015fimi ayr\u0131 bir branch olarak ekleyece\u011fim. Kod de\u011fi\u015fece\u011fi i\u00e7in geri d\u00f6n\u00fck takip edebilirsiniz kodu. Bu yaz\u0131da en son b\u0131rakt\u0131\u011f\u0131m\u0131z yeri base adl\u0131 branch'den bakabilirsiniz.</p>"},{"location":"nix_ile_nix_konfigurasyonu.html#configurationnix-dosyas-hakknda","title":"Configuration.nix Dosyas\u0131 Hakk\u0131nda","text":"<p>En ba\u015fta configuration.nix dosyam\u0131z\u0131n da bir module oldu\u011funu s\u00f6ylemi\u015ftik.</p> <pre><code>{\n  description = \"Murat Cabuk NixOS Configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.11\";\n  };\n\n  outputs = { self, nixpkgs, ... }@inputs: {\n\n    nixosConfigurations.nixos = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [\n        ./configuration.nix\n      ];\n    };\n  };\n}\n</code></pre> <p>\u015eimdi art\u0131k bu module'e bir g\u00f6z atabiliriz. BAz\u0131 a\u00e7\u0131klama sat\u0131rlar\u0131n\u0131 dosya k\u00fc\u00e7\u00fcls\u00fcn diye kald\u0131rd\u0131m.</p> <pre><code>{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Include the results of the hardware scan.\n      ./hardware-configuration.nix\n    ];\n\n nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ];\n\n\n  # Bootloader.\n  boot.loader.grub.enable = true;\n  boot.loader.grub.device = \"/dev/sda\";\n  boot.loader.grub.useOSProber = true;\n\n  networking.hostName = \"nixos\"; # Define your hostname.\n  # networking.wireless.enable = true;  # Enables wireless support via wpa_supplicant.\n\n  # Enable networking\n  networking.networkmanager.enable = true;\n\n  # Set your time zone.\n  time.timeZone = \"Europe/Istanbul\";\n\n  # Select internationalisation properties.\n  i18n.defaultLocale = \"tr_TR.UTF-8\";\n\n  i18n.extraLocaleSettings = {\n    LC_ADDRESS = \"tr_TR.UTF-8\";\n    LC_IDENTIFICATION = \"tr_TR.UTF-8\";\n    LC_MEASUREMENT = \"tr_TR.UTF-8\";\n    LC_MONETARY = \"tr_TR.UTF-8\";\n    LC_NAME = \"tr_TR.UTF-8\";\n    LC_NUMERIC = \"tr_TR.UTF-8\";\n    LC_PAPER = \"tr_TR.UTF-8\";\n    LC_TELEPHONE = \"tr_TR.UTF-8\";\n    LC_TIME = \"tr_TR.UTF-8\";\n  };\n\n  # Configure keymap in X11\n  services.xserver = {\n    layout = \"tr\";\n    xkbVariant = \"\";\n  };\n\n  # Configure console keymap\n  console.keyMap = \"trq\";\n\n  # Define a user account. Don't forget to set a password with \u2018passwd\u2019.\n  users.users.muratcabuk = {\n    isNormalUser = true;\n    description = \"murat cabuk\";\n    extraGroups = [ \"networkmanager\" \"wheel\" ];\n    packages = with pkgs; [];\n  };\n\n  # Allow unfree packages\n  nixpkgs.config.allowUnfree = true;\n  virtualisation.virtualbox.guest.enable = true;\n  virtualisation.virtualbox.guest.x11 = true;\n\n\n\n  # List packages installed in system profile. To search, run:\n  # $ nix search wget\n  environment.systemPackages = with pkgs; [\n    vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.\n    wget\n    curl\n    git\n  ];\n\n\n\n  # Enable the OpenSSH daemon.\n   services.openssh.enable = true;\n\n\n   networking.firewall.enable = false;\n\n  # This value determines the NixOS release from which the default\n  # settings for stateful data, like file locations and database versions\n  # on your system were taken. It\u2018s perfectly fine and recommended to leave\n  # this value at the release version of the first install of this system.\n  # Before changing this value read the documentation for this option\n  # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).\n  system.stateVersion = \"23.11\"; # Did you read the comment?\n}\n</code></pre> <p>Mod\u00fcle dikkat ederseniz \u00fcstte bahsetti\u011fimiz fonksiyon moduyla yaz\u0131lm\u0131\u015f. Herhangi bir option tan\u0131m\u0131 yok. Fonksiyon argument olarka config ve pkgs alm\u0131\u015f. Do\u011fal olarak bir \u00e7ok option ayarlan\u0131yor ve baz\u0131 uygulamalar da nixpkgs'den kuruluyor. Mesela alttaki sat\u0131rlarla vim, wget, curl ve git uygulamalar\u0131n\u0131n nixpkgs'den kuruldu\u011funu g\u00f6rebiliyoruz.</p> <pre><code>environment.systemPackages = with pkgs; [\n    vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.\n    wget\n    curl\n    git\n  ];\n</code></pre> <p>Ayr\u0131ca bu mod\u00fcl ba\u015fka bir mod\u00fcl\u00fc de y\u00fckl\u00fcyor. Alttaki sat\u0131rla g\u00f6rebiliyoruz.</p> <pre><code>  imports =\n    [ # Include the results of the hardware scan.\n      ./hardware-configuration.nix\n    ];\n</code></pre> <p>Bu iki blok d\u0131\u015f\u0131nda g\u00f6rd\u00fc\u011f\u00fcm\u00fcz b\u00fct\u00fcn kodlarda config blo\u011funu temsil ediyor. B\u00f6ylece i\u00e7 i\u00e7e onlarca mod\u00fcl bir \u00e7ok option tan\u0131m\u0131 ve monfig\u00fcrasyon i\u00e7eriyor. Son tahlilde b\u00fct\u00fcn bu konfig\u00fcrasyonlar tek bir set haline getirilerek NixOS'a uygulan\u0131yor.</p> <p>hardware-configuration.nix dosyas\u0131 da bir mod\u00fcl. Bunu da inceleyecek olursak yine fonksiyon tan\u0131m\u0131 olarak yaz\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6rebiliyoruz. Option tan\u0131m\u0131 hi\u00e7 yok ve geri kalan\u0131 da zaten config tan\u0131mlamas\u0131 olarak g\u00f6r\u00fcn\u00fcyor. Host platform olarak x86_64-linux olarak ayarlanm\u0131\u015f Bildi\u011finiz gibi paketler onlarca farkl\u0131 sistem de \u00e7al\u0131\u015fabiliyor. Dolay\u0131s\u0131yla e\u011fer kendimiz bir mod\u00fcl yazacaksak ve farkl\u0131 host'lar\u0131 da aya\u011fa kald\u0131rmak i\u00e7in kullanacaksak bunu da g\u00f6z \u00f6n\u00fcnde bulundurmal\u0131y\u0131z.</p> <pre><code># Do not modify this file!  It was generated by \u2018nixos-generate-config\u2019\n# and may be overwritten by future invocations.  Please make changes\n# to /etc/nixos/configuration.nix instead.\n{ config, lib, pkgs, modulesPath, ... }:\n\n{\n  imports = [ ];\n\n  boot.initrd.availableKernelModules = [ \"ata_piix\" \"ohci_pci\" \"ehci_pci\" \"ahci\" \"sd_mod\" \"sr_mod\" ];\n  boot.initrd.kernelModules = [ ];\n  boot.kernelModules = [ ];\n  boot.extraModulePackages = [ ];\n\n  fileSystems.\"/\" =\n    { device = \"/dev/disk/by-uuid/5b06bc26-f363-4810-bc0d-a44a9c7cdc12\";\n      fsType = \"ext4\";\n    };\n\n  swapDevices = [ ];\n\n  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking\n  # (the default) this is the recommended approach. When using systemd-networkd it's\n  # still possible to use this option, but it's recommended to use it in conjunction\n  # with explicit per-interface declarations with `networking.interfaces.&lt;interface&gt;.useDHCP`.\n  networking.useDHCP = lib.mkDefault true;\n  # networking.interfaces.enp0s3.useDHCP = lib.mkDefault true;\n\n  nixpkgs.hostPlatform = lib.mkDefault \"x86_64-linux\";\n  virtualisation.virtualbox.guest.enable = true;\n}\n</code></pre>"},{"location":"nix_ile_nix_konfigurasyonu.html#home-manager-hakknda","title":"Home-Manager Hakk\u0131nda","text":"<p>NixOS sadece sistem level konfig\u00fcrasyonlar\u0131 desteklerken Home-Manager ise tamamen community taraf\u0131nda geli\u015ftirilen ve kullan\u0131c\u0131 level konfig\u00fcrasyonlar\u0131 y\u00f6netmemizi sa\u011flar. Yani home dizinimizi y\u00f6netmemizi sa\u011flar. Resmi Github sayfas\u0131ndan t\u00fcm dok\u00fcmanlara eri\u015febilirsiniz.</p> <p>Home_manager bu arada NixOS olmadan da kullan\u0131labilir. NixOS ile kullan\u0131laca\u011f\u0131 zaman module olarak eklenir. E\u011fer NixOS d\u0131\u015f\u0131nda kullanacaksan\u0131z resmi dok\u00fcman sayfas\u0131ndaki Standalone Installation ba\u015fl\u0131\u011f\u0131n\u0131 inceleyebilirsiniz.</p> <p>Home-Manager da ayn\u0131 sistem konfig\u00fcrasyonun da yapt\u0131\u011f\u0131m\u0131z gibi bir module olarak olarak y\u00fcklenir. Alttaki flake \u00f6rne\u011finde modules listesine home-manager'\u0131n eklendi\u011fini g\u00f6rebiliriz. Dikkat edilirse home.nix ad\u0131nda bir dosya import ediliyor.</p> <pre><code># flake.nix\n\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.11\";\n\n    home-manager = {\n      url = \"github:nix-community/home-manager/release-23.11\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs = inputs@{ nixpkgs, home-manager, ... }: {\n    nixosConfigurations = {\n      # TODO please change the hostname to your own\n      my-nixos = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n\n          home-manager.nixosModules.home-manager {\n            home-manager.useGlobalPkgs = true;\n            home-manager.useUserPackages = true;\n\n            home-manager.users.muratcabuk = import ./home.nix;\n\n\n          }\n        ];\n      };\n    };\n  };\n}\n</code></pre> <p>Home.nix dosyas\u0131na da bir g\u00f6z atal\u0131m. Tabi alttaki \u00e7ok k\u00fc\u00e7\u00fck bir dosya. B\u00fcy\u00fck ihtimal kendi mod\u00fcl\u00fcn\u00fcz\u00fc yazd\u0131\u011f\u0131n\u0131zda bundan \u00e7ok daha b\u00fcy\u00fck hatta i\u00e7 i\u00e7e bir \u00e7ok mod\u00fclden olu\u015facak bir yap\u0131da yazacaks\u0131n\u0131z.</p> <pre><code># home.nix\n\n{ config, pkgs, ... }:\n\n{\n\n  home.username = \"muratcabuk\";\n  home.homeDirectory = \"/home/muratcabuk\";\n\n\n  home.packages = with pkgs; [\n\n    neofetch\n    zip\n    ripgrep\n    jq\n    which\n    tree\n    btop\n    iotop\n    iftop\n    sysstat\n    lm_sensors\n    ethtool\n  ];\n\n\n  programs.git = {\n    enable = true;\n    userName = \"muratcabuk\";\n  };\n\n\n  programs.bash = {\n    enable = true;\n    enableCompletion = true;\n\n    bashrcExtra = ''\n      export PATH=\"$PATH:$HOME/bin:$HOME/.local/bin:$HOME/go/bin\"\n    '';\n\n\n    shellAliases = {\n      k = \"kubectl\";\n      ll = \"ls -lhs\";\n\n    };\n  };\n\n\n  home.stateVersion = \"23.11\";\n\n  programs.home-manager.enable = true;\n}\n</code></pre> <p>Yaz\u0131y\u0131 uzatmamak i\u00e7in \u015fimdilik burada kesiyoruz. Bir sonraki yaz\u0131m\u0131zda mod\u00fcl ve option tan\u0131mlaman\u0131n detaylar\u0131na girece\u011fiz. Kendi mod\u00fcllerimizi yazarak option yazman\u0131n inceliklerine de\u011finece\u011fiz.</p>"},{"location":"nix_ile_nix_konfigurasyonu.html#modul-ve-optionlar-daha-detayl-ogrenmek-icin-kaynaklar","title":"Mod\u00fcl ve Option'lar\u0131 Daha Detayl\u0131 \u00d6\u011frenmek \u0130\u00e7in Kaynaklar","text":"<ul> <li>NixOS manual</li> <li>NixOS Wiki</li> <li>Nix Language</li> <li>NixOS Non-Official</li> </ul>"},{"location":"nix_ile_nix_konfigurasyonu.html#turkce-youtube-kaynaklar","title":"T\u00fcrk\u00e7e Youtube Kaynaklar\u0131","text":"<ul> <li>Youtube 1</li> <li>Youtube 2</li> <li>Youtube 3</li> </ul>"},{"location":"nix_ile_nix_konfigurasyonu.html#kaynaklar","title":"Kaynaklar","text":"<ul> <li>https://github.com/Misterio77/nix-starter-configs/tree/main</li> <li>https://nixos-and-flakes.thiscute.world/nixos-with-flakes/modularize-the-configuration</li> <li>https://www.tweag.io/blog/2020-07-31-nixos-flakes/</li> <li>https://jade.fyi/blog/flakes-arent-real/</li> <li>https://github.com/mikeroyal/NixOS-Guide</li> <li>https://nixos.wiki/wiki/NixOS_modules</li> <li>https://nix.dev/tutorials/module-system/module-system.html</li> <li>https://nixos.org/manual/nixos/stable/#sec-writing-modules</li> </ul>"},{"location":"nixos_cloud_ve_uzak_ortam.html","title":"NixOS'u Cloud ve Uzak Ortamlara Deploy Etmek","text":"<p>\u0130lk yaz\u0131m\u0131zda bahsetti\u011fim <code>nix-gernerator</code> arac\u0131ndan tekrar bahsederek konuya girmek istiyorum.</p> <p>Tek bir konfig\u00fcrasyonu kullanarak nix-generator arac\u0131 ile alttaki b\u00fct\u00fcn ortamlara \u00e7\u0131kt\u0131 \u00fcretebilirsiniz.</p> format description amazon Amazon EC2 image azure Microsoft azure image (Generation 1 / VHD) cloudstack qcow2 image for cloudstack do Digital Ocean image docker Docker image (uses systemd to run, probably only works in podman) gce Google Compute image hyperv Hyper-V Image (Generation 2 / VHDX) install-iso Installer ISO install-iso-hyperv Installer ISO with enabled hyper-v support iso ISO kexec kexec tarball (extract to / and run /kexec_nixos) kexec-bundle same as before, but it's just an executable kubevirt KubeVirt image linode Linode image lxc create a tarball which is importable as an lxc container, use together with lxc-metadata lxc-metadata the necessary metadata for the lxc image to start, usage: <code>lxc image import $(nixos-generate -f lxc-metadata) $(nixos-generate -f lxc)</code> openstack qcow2 image for openstack proxmox VMA file for proxmox proxmox-lxc LXC template for proxmox qcow qcow2 image raw raw image with bios/mbr. for physical hardware, see the 'raw and raw-efi' section raw-efi raw image with efi support. for physical hardware, see the 'raw and raw-efi' section sd-aarch64 Like sd-aarch64-installer, but does not use default installer image config. sd-aarch64-installer create an installer sd card for aarch64. For cross compiling use <code>--system aarch64-linux</code> and read the cross-compile section. vagrant-virtualbox VirtualBox image for Vagrant virtualbox virtualbox VM vm only used as a qemu-kvm runner vm-bootloader same as vm, but uses a real bootloader instead of netbooting vm-nogui same as vm, but without a GUI vmware VMWare image (VMDK) <p><sup>1</sup></p> <p>Sayfas\u0131nda detaylar\u0131na bakabilirsiniz. Uygulama olarak Nix paket y\u00f6neticisi ile kurulum yap\u0131p kullan\u0131labiliyor veya flake dosyas\u0131na konfig\u00fcrasyon olarak da girilebiliyor. Yani illa NixOS sahibi olmak zorunda de\u011filiz. Yani \u00f6rne\u011fin bir Ubuntu \u00fczerinde Nix paket y\u00f6neticisini kurup bu arac\u0131 kullanabiliriz.</p> <p>Elimizdeki Konfig\u00fcrasyon \u00fczerinden bu arac\u0131 kullanarak ISO, Docker Image ve VM olu\u015fturmak \u00e7ok vakit alcakt\u0131r. Bu nedenle Github sayfamda \u00f6nceki yaz\u0131lar\u0131m\u0131zda kulland\u0131\u011f\u0131m\u0131z repo'da ilk olu\u015fturdu\u011fumuz base konfig\u00fcrasyonu kullanarak uygulamalar\u0131 yapaca\u011f\u0131z.</p> <p>Bunun i\u00e7in alttaki komutla base brach'i klonlayal\u0131m.</p> <pre><code>git clone -b base https://github.com/muratcabuk/nixos-sample-dotfiles.git\n</code></pre>"},{"location":"nixos_cloud_ve_uzak_ortam.html#nixos-generator-ile-iso-docker-image-ve-vm-olusturma","title":"NixOS-Generator ile ISO, Docker Image ve VM olu\u015fturma","text":"<p>ISO Olu\u015fturmak</p> <ul> <li><code>Configuration.nix</code> dosyas\u0131nda <code>boot.loader.grub.enable = true;</code> sat\u0131r\u0131n\u0131 <code>boot.loader.grub.enable = pkgs.lib.mkForce true;</code> olarak de\u011fi\u015ftiriyoruz.</li> <li><code>Configuration.nix</code> dosyas\u0131nda <code>networking.networkmanager.enable = true;</code> sat\u0131r\u0131n\u0131 <code>networking.networkmanager.enable = false;</code> olarak de\u011fi\u015ftiriyoruz.</li> <li>Daha sonra <code>nix profile install github:nix-community/nixos-generators</code> komutuyla kurulumu yap\u0131yoruz. Son olarak <code>nixos-generate -f install-iso -c configuration.nix</code> komutu ile ISO dosyam\u0131z\u0131 olu\u015fturuyoruz.</li> </ul> <p>Bu biraz vakit alcakt\u0131r. \u0130\u015flem bitti\u011finde <code>/nix/store/4sqxkbx1im3wsrdfrzxcyklkaynq3mpy-nixos-23.11pre536306.12bdeb01ff9e-x86_64-linux.iso/iso/nixos-23.11pre536306.12bdeb01ff9e-x86_64-linux.iso</code> adresine benzer \u015fekilde ISO dosyas\u0131n\u0131n adresini g\u00f6rebilirsiniz.</p> <p>Ddocker Image Olu\u015fturmak</p> <p>Mesela docker image olu\u015fturmak i\u00e7in <code>nixos-generate -f docker -c configuration.nix</code> komutunu kullanmak yeterli olacakt\u0131r.</p> <p>komutu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131n\u0131zda <code>/nix/store/5bmzn6rrjqjb3j1vn7h09vplfjn960r2-tarball/tarball/nixos-system-x86_64-linux.tar.xz</code> adresine benzer \u015fekilde docker image dosyas\u0131n\u0131n adresini g\u00f6rebilirsiniz. Bu paketi load etmek i\u00e7in alttaki komutu \u00e7al\u0131\u015ft\u0131rabilirsiniz.</p> <pre><code>docker import  /nix/store/5bmzn6rrjqjb3j1vn7h09vplfjn960r2-tarball/tarball/nixos-system-x86_64-linux.tar.xz\n\nsha256:31f06f10c13b90698c2764c16f0b2a9c50d52113f3b8ddf9771c3c4c1070dcfe\n\ndocker image ls\nREPOSITORY                                                          TAG                         IMAGE ID       CREATED         SIZE\n&lt;none&gt;                                                              &lt;none&gt;                      31f06f10c13b   8 seconds ago   1.07GB\n&lt;none&gt;                                                              &lt;none&gt;                      925f5d1664a6   4 days ago      1.11GB\n&lt;none&gt;                                                              &lt;none&gt;                      bb873de60531   4 days ago      3.02GB\n&lt;none&gt;                                                              &lt;none&gt;                      1b6b71ea5c5c   4 days ago      966MB\n</code></pre> <ul> <li> <p>Docker i\u00e7in do\u011frudan Nix paket y\u00f6neticisinde de bir \u00e7ok paket var. Kendi resmi developer sayfas\u0131nda da konu ilgili bir ba\u015fl\u0131k var.</p> </li> <li> <p>Nix paket y\u00f6neticisi i\u00e7inde de docker ile ilgili bir \u00e7ok \u00f6rnek bulabilirsiniz. \u00d6rne\u011fin \u015fu sayfada akl\u0131n\u0131za gelebilecek hemen hemen bir \u00e7ok \u00f6rnek var.</p> </li> <li> <p>Bir de \u015fu harika \u00f6rne\u011fi inceleyebilirsiniz. Ba\u015ftan sona bir uygulaman\u0131n dev ortam\u0131n\u0131n ve paketin olu\u015fturulmas\u0131 ve uygulaman\u0131n docker image'\u0131 haline getirilmesi s\u00fcrecinin tamam\u0131n\u0131 Nix ile anlat\u0131yor.</p> </li> <li> <p>Nixpkgs i\u00e7inde Docker image'lar\u0131n\u0131 olu\u015ftururken \u00e7ok daha detayl\u0131 \u00e7al\u0131\u015fabilece\u011finiz dockerTools ad\u0131nda ir paket bulunuyor. Buna da bakman\u0131z\u0131 tavsiye ederim.</p> </li> <li> <p>Di\u011fer bir ara\u00e7 da Arion. Bu arac\u0131 daha do\u011frusu paketi kullanarak Docker Compose'daki gibi ayn\u0131 anda bir den fazla uygulamay\u0131 hem container yapabilir hem de \u00e7al\u0131\u015ft\u0131rabilirsiniz.</p> </li> </ul> <p>VM Olu\u015fturmak</p> <p>Virtualbox virtual Machine olu\u015fturmak i\u00e7in \u00f6ncelikle <code>configuration.nix</code> dosyas\u0131ndaki disk bilgisini a\u00e7\u0131klama sat\u0131r\u0131na alarak devre d\u0131\u015f\u0131 b\u0131rak\u0131yoruz.</p> <pre><code>  # fileSystems.\"/\" =\n  #   { device = \"/dev/disk/by-uuid/5b06bc26-f363-4810-bc0d-a44a9c7cdc12\";\n  #     fsType = \"ext4\";\n  #   };\n</code></pre> <p>Daha sonra <code>nixos-generate -f virtualbox -c configuration.nix</code> komutunu kullanarak VirtualBox i\u00e7in sanal bir makine olu\u015fturmu\u015f olaca\u011f\u0131z.</p> <p>\u0130\u015flem bitti\u011finde <code>/nix/store/7qy9wvm93p4ycwq2rxf6184xj8bna32c-nixos-ova-23.11pre536306.12bdeb01ff9e-x86_64-linux/nixos-23.11pre536306.12bdeb01ff9e-x86_64-linux.ova</code> \u015feklinde bir dizinde VirtualBox image'\u0131m\u0131z\u0131n olu\u015ftu\u011funu g\u00f6rebiliriz.</p>"},{"location":"nixos_cloud_ve_uzak_ortam.html#nixosu-uzak-sistemlere-ve-clouda-kurmak","title":"NixOS'u Uzak Sistemlere ve Cloud'a Kurmak","text":"<p>Burada kar\u015f\u0131m\u0131za alttaki ara\u00e7lar \u00e7\u0131k\u0131yor. Bir iki ara\u00e7 daha var ama ya geli\u015ftirmeleri durmu\u015f ya da \u00e7ok pop\u00fcler de\u011fil o y\u00fczden listeye eklemedim.</p> <ul> <li>NixOS Everywhere: Y\u0131ld\u0131z Say\u0131s\u0131 950. Temel amac\u0131 SSH ile ba\u011flan\u0131labilen bir sisteme elinizdeki Flake ile kurulum yapmak. Nix Everywhere'de cloud k\u0131sm\u0131 yok ancak Disco eklentisi sayesinde disk formatlama ve bi\u00e7imlendirme i\u015flerini de yapabiliyor.</li> <li>Detaylar i\u00e7in resmi dok\u00fcman\u0131na bakabilirsiniz.</li> <li>Yetenekleri<ul> <li>Disk formatlama ve b\u00f6l\u00fcmlendirme</li> <li>NixOS'un kurulumu ve konfig\u00fcrasyonu</li> <li>Uygulama kurabilir</li> <li>Ayr\u0131ca ekstra dosya konulacaksa onlar\u0131 ekleyebilir</li> </ul> </li> <li>Nas\u0131l \u00c7al\u0131\u015f\u0131r?<ul> <li>SSH ile ba\u011flan\u0131labiliyor olmas\u0131 laz\u0131m.</li> <li>SSh ile ayarlar\u0131 sayfas\u0131nda bulabilirsiniz.</li> <li>Kar\u015f\u0131 makinede NixOS kurulu olmal\u0131 yada installer \u00e7al\u0131\u015f\u0131yor olmal\u0131. E\u011fer o yoksa kexec ile makine boot edilmi\u015f olmal\u0131.</li> <li>\u015fu komutla sisteme kurulum yap\u0131l\u0131r <code>nix run github:nix-community/nixos-anywhere -- --flake '.#myconfig' nixos@remote-host-ip-address</code></li> </ul> </li> <li>deploy-rs: Y\u0131ld\u0131z Say\u0131s\u0131 (1100)</li> <li>Yetenekleri<ul> <li>Birden fazla profili deploy edebiliyor</li> <li>Rust diliyle yaz\u0131lm\u0131\u015f \u00e7ok h\u0131zl\u0131 bir ara\u00e7</li> <li>Kurulum i\u015flemleri ters giderse sistemi temiz bir \u015fekilde rollback yapabiliyor.</li> <li>Temel amac\u0131 bir flake \u00fczerideki profili al\u0131p tan\u0131mlanan makine (node) \u00fczerine kurmakt\u0131r.</li> <li>Blok sitesinden ba\u015ftan sona bir \u00f6rnek. Di\u011fer bir \u00f6rnek Github sayfas\u0131ndaki tam sistem kurulumu g\u00f6steren \u00f6rnek.</li> </ul> </li> <li>Nas\u0131l \u00c7al\u0131\u015f\u0131r<ul> <li>Flake i\u00e7inde node (makine) tan\u0131m\u0131 yap\u0131l\u0131r (ip, ssh port, kullan\u0131c\u0131 ad\u0131, parola, ssh key, vb.)</li> <li>daha sonra deploy-rs cli kullan\u0131larak <code>deploy-rs --flake ./flake.nix --profile defaultPackage --node myNode1 --node myNode2</code> komutu ile kurulum yap\u0131l\u0131r.</li> </ul> </li> <li>colmena: Y\u0131ld\u0131z say\u0131s\u0131 930. Rust diliyle yaz\u0131lm\u0131\u015f di\u011fer bir deployment arac\u0131.<ul> <li>Yetenekleri</li> <li>Node'lara tag vererek grupland\u0131rmak m\u00fcmk\u00fcn.</li> <li>Nixops network konfigurayonu ile uyumlu de\u011fi\u015fiklik yapmadan kullan\u0131labilir.</li> <li>Local makine deployment'\u0131 da yapabiliyor.</li> <li>Paralel deployment yapabiliyor. Zaten Rust ile yaz\u0131l\u0131 oldu\u011fu i\u00e7in de h\u0131zl\u0131.</li> <li>Cloud deployment yetene\u011fi yok. Sadece local ve uzak makinelere kurulum yapabiliyor.</li> <li>Kullan\u0131m\u0131 Nixops'a \u00e7ok benziyor. YAni bir flake deployment'\u0131 yok daha \u00e7ok sunucu kurulumlar i\u00e7in uygun g\u00f6r\u00fcn\u00fcyor.</li> </ul> </li> <li>Morph: Y\u0131ld\u0131z Say\u0131s\u0131 700</li> <li>Temel amac\u0131 birden fazla host \u00fczerinde NixOS'u y\u00f6netmek. Kurulum yap\u0131p health check yapabiliyor.</li> <li>Daha \u00f6nce Ansible, Chef veya Puppet gibi ara\u00e7lar kulland\u0131ysan\u0131z tam olarak onlar\u0131n yapt\u0131\u011f\u0131 i\u00e7in NixOS ve Nix paket y\u00f6neticisini kullanarak yap\u0131yor.</li> <li>\u00c7ok basit bir kullan\u0131m\u0131 var. Bir nix dosyas\u0131na makinelerin bilgilerini yazd\u0131ktan morph komutu ile elinizdeki konfig\u00fcrasyonu toplu halde makinelerinize uygulayabiliyorsunuz.</li> <li> <p>Nixops: Y\u0131ld\u0131z Say\u0131s\u0131 1700. Ara\u00e7lardan en dikkat \u00e7ekeni Nixops. Temelde Nixops bir flake'i al\u0131p onu belirtilen makineye kurmaya odaklanm\u0131yor. Bunu Nix Everywhere veya Deploy-rs ile yapabiliriz. Nixops amac\u0131 \u00e7ok farkl\u0131 ortamlardaki makinelere ba\u011flanmak ve onlara Nixops konfig\u00fcrasyonunda belirtti\u011fimiz paketleri ve uygulamalar\u0131 kurmakt\u0131r. Toplu halde paket kurmak, toplu halde sistemleri destroy etmek gibi i\u015flemleri yapabilir. Yani daha \u00e7ok sunucu i\u015flemleri ve konfig\u00fcrasyonu i\u00e7in kullan\u0131l\u0131r.</p> </li> <li> <p>Nixops'un yeni versiyonu Nixops 2.0'da baz\u0131 de\u011fi\u015fikliliklere gidilmi\u015f. Yeni versiyonla ilgili olarak da elimizdeki tek kaynak da resmi dok\u00fcmanlar. Ancak bu versiyondaki baz\u0131 yap\u0131sal problemlerden dolay\u0131 da Rust diliyle yeniden yazmaya karar verilmi\u015f. Bu yeni versiyonu da tamamen yeni bir Github hesab\u0131ndan devam ettiriyorlar. \u015eu linkten takip edebilirsiniz. Mevzu halen \u015fu issue'da tart\u0131\u015f\u0131l\u0131yor.</p> </li> <li> <p>Elimizdeki \u00e7al\u0131\u015fan en temiz versiyon olarak 1.7'nin resmi dok\u00fcmanlar\u0131na da \u015fu linkten eri\u015febilirsiniz.</p> </li> <li> <p>Konu ile ilgili T\u00fcrk\u00e7e olarak bulabilece\u011finiz belki tek i\u00e7erik \u015fu Youtube videosu olacakt\u0131r. Bunu da izlemenizi tavsiye ederim. \u00c7\u00fcnk\u00fc videonun yar\u0131s\u0131nda Nix paket y\u00f6neticisi ve NixOS hakk\u0131nda \u00e7ok g\u00fczel bilgiler veriliyor.</p> </li> <li> <p>Ba\u015ftan sona t\u00fcm detaylar\u0131yla Nixops'un anlat\u0131ld\u0131\u011f\u0131 bir makale.</p> </li> <li> <p>Yetenekleri</p> <ul> <li>Local veya uzak makinelere kurulum yapabilirsiniz.</li> <li>Hetzner fiziksel makinelere kurulum yapabilirsiniz.</li> <li>Libvirt (Qemu) \u00fczerinde VM olu\u015fturabilirsiniz.</li> <li>VirtualBox \u00fczerinde \u00e7al\u0131\u015fan bir NixOS \u00fczerinde kurulum ve de\u011fi\u015fiklik yapabilirsiniz. Ancak buraya dikkat \u00e7ekmek istiyorum Nixops Virtualbox \u00fczerinden makine olu\u015fturmaz sadece vorolan mak\u015fneye ba\u011flanablir.</li> <li>AWS (Amazon Web Services), GCE (Google Compute Engine), Azure (Microsoft Azure), Digital Ocean gibi cloud ortamlar\u0131na kurulum yapabilir hatta network, storage, IP, firewall gibi</li> <li>\u015eu kaynakta da Versiyon 1'den 2'ye ge\u00e7i\u015fle alakal\u0131 konulara de\u011finilmi\u015f.</li> </ul> </li> </ul> <p>Son tahlilde e\u011fer 1.7 kullanmak istiyorsak \u00f6zellikle ilgili NixOS versiyonunu bulup onun \u00fczerinden nixops'u y\u00fcklememiz gerekiyor. Nixops 1.7 versiyonunun bulundu\u011fu Nixpks'nin en son versiyonu NixOS 23.05'de bulabiliyoruz. O zaman registry (channel) olarak 23.05 versiyonunu registry'lere ekleyip bu versiyon \u00fczeridnen Nixops'u kurabiliriz.</p> <pre><code>     nix registry add nixpkgs2305 github:NixOS/nixpkgs/nixos-23.05\n\n     export NIXPKGS_ALLOW_INSECURE=1\n\n     nix profile install flake:nixpkgs2305#nixops\n\n     nixops --version\n</code></pre> <p>Nixops'u kullan\u0131rken flake i\u00e7ine veya flake'den ba\u011f\u0131ms\u0131z olarak bir dosya i\u00e7ine konfig\u00fcrasyonu yazabiliriz. Bu dosya i\u00e7inde birden fazla makine tan\u0131mlayabiliriz. Bu makinelere ba\u011flanarak NixOS konfig\u00fcrasyonunu uygulayabiliriz.</p> <p>Flake i\u00e7inde tan\u0131mlama yaparken alttaki gibi bir template kullanmal\u0131s\u0131n\u0131z. <code>nixopsConfigurations</code> blo\u011funa bakacak olursan\u0131z <code>network</code>, <code>defaults</code> ve <code>machine</code> bloklar\u0131n\u0131 g\u00f6rebilirsiniz. <code>network</code> blo\u011funda genel network ayarlar\u0131 yap\u0131l\u0131rken <code>machine</code> blo\u011funda ise tekbir makinenin tan\u0131m\u0131n\u0131 g\u00f6steriyor. Defaults blo\u011fu ise t\u00fcm makinelere uygulanacak genel ayarlar\u0131 g\u00f6steriyor. Konfig\u00fcrasyondaki databasefile k\u0131sm\u0131 ise eskiye uyumluluk i\u00e7in gerekiyor. Bu dosya i\u00e7inde deployment'lar ve makine bilgileri tutuluyor.</p> <p>Network blo\u011funa e\u011fer \u00f6rne\u011fin bir AWS konfig\u00fcrasyonu yapacak olursak bu durumda makinelerimiz ve di\u011fer AWS kaynaklar\u0131 AWS \u00fczerinden Nixops taraf\u0131ndan olu\u015fturulacakt\u0131r. Alttaki \u00f6rnek Virtualbox \u00fczerinde bir makine olu\u015fturmak i\u00e7in kullan\u0131labilir.</p> <pre><code># flake.nix\n{\ndescription = \"Murat Cabuk NixOS Configuration\";\n\ninputs = {\n  nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.11\";\n  nixops.url = \"github:NixOS/nixops\";\n};\n\noutputs = { self, nixpkgs, ... }@inputs: {\n\nnixopsConfigurations.default = {\n\n          inherit nixpkgs;\n\n          network =  {\n              description = \"my virtual network\";\n              enableRollback = true;\n              storage.legacy = {\n                  databasefile = \"~/.nixops/deployments.nixops\";\n              };\n\n              deployment.targetEnv = \"virtualbox\";\n              deployment.virtualbox.memorySize = 4096; # megabytes\n              deployment.virtualbox.vcpu = 2; # number of cpus\n              deployment.virtualbox.headless = true;\n\n          };\n\n          defaults = {\n              imports = [ ];\n          };\n\n          machine = { config, pkgs, ...  }: {\n              services = {\n                httpd.enable = true;\n                openssh.enable = true;\n              };\n\n              environment.systemPackages = with pkgs; [ vim git htop];\n          };\n  };\n\n  nixosConfigurations.nixos = nixpkgs.lib.nixosSystem {\n    system = \"x86_64-linux\";\n    modules = [ /configuration.nix ];\n    };\n  };\n}\n</code></pre>"},{"location":"nixos_cloud_ve_uzak_ortam.html#kubernetes-cluster-olusturmak","title":"Kubernetes Cluster'\u0131 Olu\u015fturmak","text":"<ul> <li>Kubenix: Bu ara\u00e7 Rust dili kulln\u0131larak yaz\u0131lm\u0131\u015f ama\u00e7 development ortam\u0131 i\u00e7in Kubernetes cluster'\u0131 olu\u015fturmak.</li> </ul> <p>Nixops ile Kubernetes kurulumu i\u00e7in fikir olmas\u0131 ad\u0131na altta 2 Github projesinin linkini payla\u015f\u0131yorum.</p> <ul> <li>Sadene Kubernetes de\u011fil ELK, Kafka, Mesos ve Postgres cluster'lar\u0131n\u0131n da Nixops ile nas\u0131l olu\u015fturabilce\u011finize \u00f6rnek olarak \u015fu linkten inmceleyebilirsiniz.</li> <li>Bu \u00f6rnek de sade bir \u015fekilde 6 sunuculu bir Kubernetes cluster'\u0131n\u0131n nas\u0131l yap\u0131labilece\u011fini g\u00f6steriyor.</li> </ul> <p>Evet bu yazm\u0131zda bu kadar. F\u0131rsat bulduk\u00e7a NixOS hakk\u0131ndaki deneyimlerimi payla\u015fmaya devam edece\u011fim. Umar\u0131m faydal\u0131 olmu\u015ftur di\u011fer yaz\u0131lar\u0131mda g\u00f6r\u00fc\u015fmek \u00fcmidiyle.</p> <ol> <li> <p>Tablo Kayna\u011f\u0131 \u21a9</p> </li> </ol>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html","title":"NixOS Kurulumu ve Konfig\u00fcrasyonu","text":"<p>Bu yaz\u0131m\u0131zda daha \u00f6nce kurmu\u015f oldu\u011fumuz NixOS konfig\u00fcrasyonunu yapmaya devam edece\u011fiz.</p> <p>Yaz\u0131n\u0131n en sonunda \u00f6rnek olarak incelenebilecek bir \u00e7ok repo'nun da linklerini verdim. Onlarda da faydalanarak \u00f6rne\u011fimizi yava\u015f yava\u015f geli\u015ftirece\u011fiz.</p> <p>Alttaki \u00e7al\u0131\u015fman\u0131n son halini de Github'daki repo \u00fczerinden inceleyebilirsiniz. Ad\u0131m ad\u0131m her de\u011fi\u015fimi ayr\u0131 bir branch olarak ekleyece\u011fim. Kod de\u011fi\u015fece\u011fi i\u00e7in geri d\u00f6n\u00fck takip edebilirsiniz kodu.</p>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#klasorlerin-kullanm-amaclar","title":"Klas\u00f6rlerin Kullan\u0131m Ama\u00e7lar\u0131","text":"<p>Bir bilgisayarda ne t\u00fcr ayarlar yapar\u0131z bi listeleyelim.</p> <ul> <li>Makinemizin kullan\u0131c\u0131dan ba\u011f\u0131ms\u0131z donan\u0131msal ayarlar\u0131: Disk yap\u0131s\u0131, driver'lar, bluetooth, sens\u00f6r, d\u0131\u015f cihazlar (yaz\u0131c\u0131, monitor, kamera vb) ayarlar. Tabi e\u011fer birden fazla makine y\u00f6netiliyorsa o zaman makine say\u0131s\u0131 kadar ayar gerekiyor.</li> <li>\u0130\u015fletim sisteminin kullan\u0131c\u0131dan ba\u011f\u0131ms\u0131z ayarlar\u0131: Hangi mod\u00fcller kullan\u0131lacak, hangi servisler \u00e7al\u0131\u015f\u0131yor olacak, sistem \u00fczerinde t\u00fcm kullan\u0131c\u0131lar i\u00e7in ortak olacak di\u011fer ayarlar.</li> <li>Sistem \u00fczerinden kullan\u0131c\u0131dan ba\u011f\u0131ms\u0131z kurulmas\u0131 gereken uygulamalar: Hangi kullan\u0131c\u0131 sistemi kullan\u0131rsa kullans\u0131n olmas\u0131 gereken uygulamalar. Mesela bir servis, office uygulamas\u0131 veya basit bir \u00e7izim program\u0131 gibi. Tabi bunlar\u0131n kullan\u0131labilmesi i\u00e7inde bir masa\u00fcst\u00fc ortam\u0131 (kde, gnome) gerekiyor.</li> <li>Kullan\u0131c\u0131n\u0131n ki\u015fisel ayarlar\u0131: Ki\u015finin kullanaca\u011f\u0131 uygulamalar me masa\u00fcst\u00fc ortam\u0131 ayarlar\u0131</li> <li>Kullan\u0131c\u0131n\u0131n ki\u015fisel uygulamalar\u0131: Ki\u015finin sadece kendisinin kulland\u0131\u011f\u0131, di\u011fer kullan\u0131c\u0131lara payla\u015ft\u0131r\u0131lmayacak uygulamalar. Tabi her kullan\u0131c\u0131 kendisi isterse kurabilir ayn\u0131 uygulamay\u0131.</li> </ul> <p>B\u00fct\u00fcn bu sistemi kurmak i\u00e7in herkesin farkl\u0131 bir dosya y\u00f6netme stratejisi var. Alttaki \u00f6rnek linklerden farkl\u0131 kullan\u0131c\u0131lar\u0131n repo'lar\u0131n\u0131 inceleyebilirsiniz. Baz\u0131 klas\u00f6r adlar\u0131n\u0131 hemen hemen hepsinde g\u00f6rebilirsiniz.</p> <ul> <li>Hosts/machines : Kullan\u0131lacak Bilgisayar\u0131n ayalar\u0131 i\u00e7in kullan\u0131l\u0131r. BAz\u0131lar\u0131 donan\u0131msal i\u015fleri machines klas\u00f6r\u00fcne, di\u011fer ayarlar\u0131 da hosts klas\u00f6r\u00fcne koyabiliyor.</li> <li>Home/Users : Kullan\u0131c\u0131ya \u00f6zel ayarlar ve uygulamalar i\u00e7in kullan\u0131l\u0131r.</li> <li>Pkgs/Packages: Bizzat ilgili konfig\u00fcrasyon i\u00e7inde build al\u0131n\u0131p derivation/package olu\u015fturulacak paket bilgileri bulunur.</li> <li>Overlays: Nixpkgs \u00fczerindeki de\u011fi\u015fiklikler, pkgs/packages klas\u00f6r\u00fcndeki paketlerin y\u00fcklenmesi ve di\u011fer paket repo'lar\u0131ndan y\u00fcklenen paketlerin override i\u015flemleri gibi i\u015fler i\u00e7in kullan\u0131l\u0131r.</li> <li>Modules : NixOS konfig\u00fcrasyonu i\u00e7in kullan\u0131l\u0131r. Burada \u00f6nemli olan konu her kim olursa olsun yani ki\u015fiye ba\u011fl\u0131 olmadan yap\u0131lan konfig\u00fcrasyonlar burada olmal\u0131.</li> <li>Lib : Custom yaz\u0131lan fonksiyonlar konulur.</li> <li>Scripts/Config/Bin : Bazen NixOS module ve option'lar\u0131 yetersiz gelebilir. Bu gibi durumlarda script yazmak gerekebilir. Hem bu script'leri hem de kullan\u0131lan konfig\u00fcrasyon dosyalar\u0131n\u0131 burada tutulur.</li> </ul> <p>NixOS klas\u00f6r yap\u0131s\u0131 i\u00e7in bize bir best practice sunmuyor. Yani tamamen nas\u0131l bir \u015fey yapaca\u011f\u0131m\u0131z tamamen bize kalm\u0131\u015f</p> <p>Bu yaz\u0131da elimden geldi\u011fince sade kalmaya \u00e7al\u0131\u015faca\u011f\u0131m. Hem yaz\u0131y\u0131 bitiremeyiz hem de amac\u0131m\u0131z zaten m\u00fckemmel bir sistem kurmak de\u011fil daha \u00e7ok mant\u0131\u011f\u0131n\u0131 anlamak. Devam\u0131n\u0131 getirmek art\u0131k sizin elinizde. Bu arada ben de kendi sistemlerimde m\u00fcmk\u00fcn oldu\u011funca sade tutmaya \u00e7al\u0131\u015f\u0131yorum. Gereksiz yere kullanmayaca\u011f\u0131m\u0131z konfig\u00fcrasyonlar\u0131 y\u00f6netmeye gerek yok.</p> <p>Tek bir makine ve tek bir kullan\u0131c\u0131 i\u00e7in system konfig\u00fcrasyonu yapaca\u011f\u0131z. Dosya yap\u0131m\u0131z alttaki gibi olacak</p> <p></p> <ul> <li>Host: Makine hardware ayarlar\u0131m\u0131z\u0131n oldu\u011fu klas\u00f6r</li> <li>Modules: NixOS konfig\u00fcrasyonunun ve kullan\u0131c\u0131 home dizini ve di\u011fer ki\u015fisel ayarlar\u0131n\u0131n oldu\u011fu klas\u00f6r</li> <li>Overlays: Custom geli\u015ftirilen uygulamalar\u0131n ve di\u011fer paket y\u00f6neticilerinden y\u00fcklenen uygulamalar\u0131n y\u00fcklenme \u00f6ncesinde yap\u0131lacak de\u011fi\u015fikliklerinin y\u00f6netildi\u011fi overlay dosyalar\u0131n\u0131n konuldu\u011fu klas\u00f6r</li> <li>Pkgs: Custom geli\u015ftirilen uygulamalar\u0131n bulundu\u011fu klas\u00f6r</li> </ul> <p>Bu arada b\u00fct\u00fcn klas\u00f6rlerde README dosyas\u0131 mevcut, bu dosyalardan bulundu\u011fu klas\u00f6r ve uygulama hakk\u0131nda bilgi alabilirsiniz.</p>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#dosya-ve-klasor-yapsnn-olusturulmas","title":"Dosya ve Klas\u00f6r Yap\u0131s\u0131n\u0131n Olu\u015fturulmas\u0131","text":"<p>Ad\u0131m ad\u0131m sistemimizi kurmaya ba\u015flayal\u0131m.</p> <ol> <li>\u00d6ncelikle hosts klas\u00f6r\u00fcn\u00fcze makinemizin ad\u0131n\u0131/modelini i\u00e7eren bir klas\u00f6r olu\u015ftural\u0131m ve root dizinde olan <code>hardware-configuration.nix</code> dosyas\u0131n\u0131 bu klas\u00f6re kopyalayal\u0131m.</li> </ol> <p></p> <p>\u0130lerde belki farkl\u0131 sistemler de eklemek sitesebiz yap\u0131n\u0131z haz\u0131r olmu\u015f olur.</p> <ol> <li>Root dizindeki <code>nixos-configuration.nix</code> dosyas\u0131n\u0131 da modules klas\u00f6r\u00fcne ta\u015f\u0131yal\u0131m ve bu dosyada en \u00fcstte yer <code>hardware-configuration.nix</code> dosyas\u0131n\u0131n adresini de\u011fi\u015ftirelim. Ayr\u0131ca <code>networking.hostName = \"muratpc\";</code> sat\u0131r\u0131nda \u00f6nceden hostname NixOS olarak yaz\u0131yordu onu da sistem ad\u0131yla ayn\u0131 yapt\u0131m yani muratpc. Siz de istedi\u011finiz gibi de\u011fi\u015ftirebilirsiniz. \u0130lla sistem ad\u0131yla hostname ayn\u0131 olmak zorunda de\u011fil farkl\u0131 isimler de verilebilir.</li> </ol> <pre><code>{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Include the results of the hardware scan.\n      ../hosts/lenovo-l15/hardware-configuration.nix\n    ];\n\n# KISALTILDI\n</code></pre> <ol> <li>modules klas\u00f6r\u00fcn\u00fcze <code>home-manager.nix</code> dosyan\u0131z\u0131 ekleyin. Ben prefix olarak kendi ad\u0131m\u0131 kulland\u0131m .Hangi user i\u00e7in oldu\u011fu belli olsun. \u0130lerde belki farkl\u0131 kulaln\u0131c\u0131lar da ekleyebilirsiniz. \u0130\u00e7ini bo\u015f b\u0131rak\u0131n \u015fimdilik ilerde dolduraca\u011f\u0131z.</li> <li>Pkgs klas\u00f6r\u00fcn\u00fc olu\u015ftural\u0131m. Bu klas\u00f6rde kendi yazd\u0131\u011f\u0131m\u0131z paketler olarak. E\u011fer yaz\u0131 dizisini ba\u015ftan beri okuduysan\u0131z zaten i\u00e7inde daha \u00f6nceki yaz\u0131larda olu\u015fturdu\u011fum \u00f6rnek paketleri koydum. Bu paketleri sizde Github sayfamdaki repo'dan alabilirsiniz. Uygulamalar farkl\u0131 \u015fekillerde nas\u0131l kendi paketlerinize yazabilirsiniz bunlar i\u00e7in de \u00f6rnek olmu\u015f oluyor. Zaten her bir uygulama klas\u00f6r\u00fcnde README dosyas\u0131 var onlardan da bilgi alabilirsiniz.</li> <li>Overlays klas\u00f6r\u00fcn\u00fc olu\u015ftural\u0131m. Bu klas\u00f6rde de hem kendi yazd\u0131\u011f\u0131m\u0131z paketlerde hem de di\u011fer paket repo'lar\u0131ndan y\u00fckledi\u011fimiz paketlerde y\u00fcklenme \u00f6ncesi de\u011fi\u015fiklikleri y\u00f6netiyoruz. Hat\u0131rlarsan\u0131z \u00f6nceki yaz\u0131lar\u0131m\u0131zda paket y\u00fcklemenin bile bir nixpkgs \u00fczerinde bir de\u011fi\u015fiklik yapmak anlam\u0131na geldi\u011finden bahsetmi\u015ftik. Bu nedenle kendi yazd\u0131\u011f\u0131m\u0131z paketlerin sisteme y\u00fcklenmesini ve y\u00fcklenme \u00f6ncesi yap\u0131lacak de\u011fi\u015fiklikleri de buradan y\u00f6netiyoruz.</li> </ol> <p>Burada da \u015fimdilik 2 dosya <code>custom.nix</code> ve <code>hello.nix</code> buluyor.</p> <p></p> <p><code>custom.nix</code> dosyas\u0131nda kendi yazd\u0131\u011f\u0131m\u0131z paketlere ait overlay i\u015flemleri varken <code>hello.nix</code> i\u00e7inde NisOs repo'sudan yer alan hello uygulamas\u0131na y\u00f6nelik overlay ayarlar\u0131 bulunuyor.</p> <p><code>Custom.nix</code> dosya i\u00e7eri\u011fi</p> <pre><code># custom.nix\nfinal: prev: {\n  defaultapp = import ../pkgs/default {pkgs = final;};\n  defaultfile = import ../pkgs/defaultfile {pkgs = final;};\n  defaultalt = import ../pkgs/defaultalt {pkgs = final;};\n  nixapp = import ../pkgs/nixapp {pkgs = final;};\n\n  # uygulama build al\u0131n\u0131rken v3.0 kullan\u0131ls\u0131n\n  message = import ../pkgs/message {\n    pkgs = final;\n    version = \"v3.0\";\n  };\n\n  # uygulama build al\u0131n\u0131rken v3.0 kullan\u0131ls\u0131n\n  testapp = import ../pkgs/testapp {\n    pkgs = final;\n    version = \"v3.0\";\n  };\n}\n</code></pre> <p><code>Hello.nix</code> dosya i\u00e7eri\u011fi</p> <pre><code># hello.nix\n\nfinal: prev: {\n\n  # uygulama build al\u0131n\u0131rken 2.9 kullan\u0131ls\u0131n\n  hello-custom = final.hello.overrideAttrs (old: rec {\n    name = \"hello-custom\";\n    version = \"2.9\";\n    src = final.fetchurl {\n      url = \"mirror://gnu/hello/hello-${version}.tar.gz\";\n      sha256 = \"sha256-7Lt6IhQZbFf/k0CqcUWOFVmr049tjRaWZoRpNd8ZHqc=\";\n    };\n  });\n\n  hello-new = final.hello;\n\n}\n</code></pre> <ol> <li><code>Flake.nix</code> dosyas\u0131n\u0131 alttaki gibi de\u011fi\u015ftiriyoruz. De\u011fi\u015fiklikler a\u00e7\u0131klama sat\u0131r\u0131 olarak eklendi.</li> </ol> <pre><code>{\n  description = \"Murat Cabuk NixOS Configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.11\";\n  };\n\n  outputs = { self, nixpkgs, ... }@inputs:\n  let\n\n    # \u00fczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z sistemin Nix'deki kod add\u0131.\n    system = \"x86_64-linux\";\n\n    # 2 adet overlay var\n    overlays = [\n                (import ./overlays/custom.nix)\n                (import ./overlays/hello.nix)\n               ] ;\n    # ne t\u00fcr bir sistemde \u00e7al\u0131\u015f\u0131yorsak onun i\u00e7in nixpkgs koleksiyonu ve k\u00fct\u00fcphanesi olu\u015fturuluyor.\n    pkgs = import nixpkgs {\n              inherit system;\n              overlays = overlays;\n            };\n\n    # build al\u0131nan veya override edilen paketler bu flake ile yay\u0131nlan\u0131yor.\n    packages = {\n        x86_64-linux.default = pkgs.defaultapp;\n        x86_64-linux.defaultfile = pkgs.defaultfile;\n        x86_64-linux.defaultalt = pkgs.defaultalt;\n        x86_64-linux.nixapp = pkgs.nixapp;\n        x86_64-linux.message = pkgs.message;\n        x86_64-linux.testapp = pkgs.testapp;\n        x86_64-linux.hello = pkgs.hello;\n        x86_64-linux.hello-custom = pkgs.hello-custom;\n    };\n\n  in {\n\n    # bu sistemin ad\u0131 muratpc olarak de\u011fi\u015ftirildi\n    nixosConfigurations.muratpc = nixpkgs.lib.nixosSystem {\n\n      # systm bilgisi yukar\u0131da tan\u0131mlana system de\u011fi\u015fkeniniden al\u0131nd\u0131\n      system = system;\n\n      # dosya adresi de\u011fi\u015ftirildi\n      modules = [\n        ./modules/nixos-configuration.nix\n      ];\n    };\n\n    packages = packages;\n  };\n}\n</code></pre> <p>\u015eimdi <code>flake.nix</code> dosyam\u0131z neler sunuyor ona bir bakal\u0131m.</p> <pre><code>nix flake show . --impure --all-systems\nwarning: Git tree '/home/.../nixos-sample-dotfiles' is dirty\nwarning: creating lock file '/home/muratcabuk/projects/GitHub/nixos-sample-dot./assets/files\\flake.lock'\nwarning: Git tree '/home/.../nixos-sample-dotfiles' is dirty\ngit+file:///home/.../nixos-sample-dotfiles\n\u251c\u2500\u2500\u2500nixosConfigurations\n\u2502   \u2514\u2500\u2500\u2500nixos: NixOS configuration\n\u2514\u2500\u2500\u2500packages\n    \u2514\u2500\u2500\u2500x86_64-linux\n        \u251c\u2500\u2500\u2500default: package 'default'\n        \u251c\u2500\u2500\u2500defaultalt: package 'defaultalt'\n        \u251c\u2500\u2500\u2500defaultfile: package 'defaultfile'\n        \u251c\u2500\u2500\u2500hello: package 'hello-2.12.1'\n        \u251c\u2500\u2500\u2500hello-custom: package 'hello-custom'\n        \u251c\u2500\u2500\u2500message: package 'message'\n        \u251c\u2500\u2500\u2500nixapp: package 'nixapp'\n        \u2514\u2500\u2500\u2500testapp: package 'testapp'\n</code></pre> <p>Ever g\u00f6r\u00fclece\u011fi \u00fczere flake dosyam\u0131z bir NixOS sistem birde 8 adet paket sunuyor.</p> <p>\u015eimdide yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fiklikleri sisteme uygulayal\u0131m. Bunun i\u00e7in alttaki komutu \u00e7al\u0131\u015ft\u0131r\u0131yoruz. E\u011fer siz de <code>flake.nix</code> dosyas\u0131nda system ad\u0131n\u0131 nixos d\u0131\u015f\u0131nda ba\u015fka bir isme \u00e7evirdiyseniz altta muratpc yerine o ismi yazmal\u0131s\u0131n\u0131z. E\u011fer de\u011fi\u015ftirmediyseniz de nixos yazmal\u0131.</p> <pre><code>sudo nixos-rebuild switch --flake .#muratpc\n# sistem ad\u0131 ayn\u0131 kald\u0131ysa\n# sudo nixos-rebuild switch --flake .#nixos\n</code></pre> <p>Bu komut sonras\u0131nda asl\u0131nda bizim do\u011frudan hissedebilece\u011fimiz bir \u015fey olmad\u0131. Sadece hostname de\u011fi\u015fti onu da <code>cat /etc/hostname</code> komutu ile g\u00f6rebiliriz.</p> <p>Hissetmedi\u011fimiz tarafta ise custom geli\u015ftirmi\u015f oldu\u011fumuz uygulamalar build al\u0131nd\u0131 ve build al\u0131nabilmeleri i\u00e7in gerekli olan paketler de kuruldu. Ancak bu uygulamalar do\u011frudan PATH'a ekli de\u011fil \u00e7\u00fcnk\u00fc biz kurulumlar\u0131n\u0131 ve user baz\u0131nda eri\u015filebilmesi i\u00e7in gerekli ayarlar\u0131 yapmad\u0131k. Ancak bir developer olarak bu test edemeyece\u011fimiz anlam\u0131na gelmiyor. Alttaki komutlarla test edebiliriz.</p> <pre><code>nix run .#default  --impure\n\nnix run .#message --impure\n\nnix run .#hello --impure\n</code></pre> <p>Ancak mesela hello uygulamas\u0131na terminalden eri\u015fmeyi denedi\u011fimizde sonu\u00e7 alamayaca\u011f\u0131z.</p> <p>Bu k\u0131sm\u0131 bu \u015fekilde h\u0131zl\u0131 ge\u00e7iyorum daha fazla detaya girmeden \u00e7\u00fcnk\u00fc \u00e7ok b\u00fcy\u00fck ihtimal bu yaz\u0131y\u0131 okuyanlar\u0131n b\u00fcy\u00fck bir k\u0131sm\u0131 bu tarz bir i\u015flem yapamayacakt\u0131r yani kendi kod yaz\u0131p yada internetten bir projeyi, bulup build alama yoluna gitmeyecektir. Zaten bunu d\u00fc\u015f\u00fcnenleriniz varsa geriye d\u00f6n\u00fck b\u00fct\u00fcn yaz\u0131lar bu konuyu anlat\u0131yor. Yani NixOS'u ayarlamak ona paket yazmaktan daha kolay.</p> <p>Github sayfamda geldi\u011fimiz noktaya kadar olan kodlar\u0131 file-structure adl\u0131 branch'de bulabilirsiniz.</p>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#nix-configuration-dosyasnn-incelenmesi","title":"Nix-Configuration Dosyas\u0131n\u0131n \u0130ncelenmesi","text":"<p>Dosyay\u0131 a\u00e7\u0131klama sat\u0131rlar\u0131n\u0131 silerek sadele\u015ftirdim ve her bir ayar i\u00e7in a\u00e7\u0131klamalar ekledim. Bundan dolay\u0131 sizinkinden biraz farkl\u0131 g\u00f6r\u00fcn\u00fcyor olabilir.</p> <pre><code>{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Burada donan\u0131msal ayarlar\u0131m\u0131z\u0131n oldu\u011fu di\u011fer bir module import ediliyor\n      ../hosts/lenovo-l15/hardware-configuration.nix\n    ];\n\n # Nix flake halen geli\u015ftiriliyor tam release olmad\u0131.\n # Buna ra\u011fmen \u00e7ok stable ve neredeyse NixOS ile ilgili herkes flake'i art\u0131k aktif olarak kullan\u0131yor\n # Ancak halen release olmad\u0131\u011f\u0131 i\u00e7in deneyimsel bir \u00f6zellik olarak kabul ediliyor.\n # bundan dolay\u0131 bunu kullanmak i\u00e7in enable etmemiz gerekiyor\n nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ];\n\n  # Bootloader.\n  boot.loader.grub.enable = true;\n  boot.loader.grub.device = \"/dev/sda\";\n  boot.loader.grub.useOSProber = true;\n\n  # hem bilgisayar ad\u0131m\u0131z hem de bir network'de bilgisayara eri\u015fmek i\u00e7in kullan\u0131lan isim\n  networking.hostName = \"muratpc\";\n\n  # Network ayarlar\u0131n\u0131n yap\u0131labilmesi i\u00e7in gerekli.\n  # Sadece Network MAnager yok asl\u0131nda Linux d\u00fcnyas\u0131 i\u00e7in ancak ben de en iyilerinden biri\n  networking.networkmanager.enable = true;\n\n  # TimeZoe ayar\u0131\n  time.timeZone = \"Europe/Istanbul\";\n\n  # Windows'daki b\u00f6lgesel ayarlarla ayn\u0131 i\u015fi yap\u0131yor.\n  # Yani  mesela para birimi, \u00f6l\u00e7\u00fcm ayalarlar\u0131, Klavye karakterleri vb T\u00fcrkiye'ye \u00f6zel ayarlar\u0131n baz al\u0131naca\u011f\u0131n\u0131 s\u00f6yl\u00fcyor. .\n  i18n.defaultLocale = \"tr_TR.UTF-8\";\n  i18n.extraLocaleSettings = {\n    LC_ADDRESS = \"tr_TR.UTF-8\";\n    LC_IDENTIFICATION = \"tr_TR.UTF-8\";\n    LC_MEASUREMENT = \"tr_TR.UTF-8\";\n    LC_MONETARY = \"tr_TR.UTF-8\";\n    LC_NAME = \"tr_TR.UTF-8\";\n    LC_NUMERIC = \"tr_TR.UTF-8\";\n    LC_PAPER = \"tr_TR.UTF-8\";\n    LC_TELEPHONE = \"tr_TR.UTF-8\";\n    LC_TIME = \"tr_TR.UTF-8\";\n  };\n\n\n\n  # xserver i\u00e7in keyboard ayarlar\u0131\n  services.xserver = {\n    layout = \"tr\";\n    xkbVariant = \"\";\n  };\n\n  # console i\u00e7in keyboard ayarlar\u0131\n  console.keyMap = \"trq\";\n\n  # Normal bir kullan\u0131c\u0131 tan\u0131ml\u0131yoruz ve onu wheel ve network manager gruplar\u0131na ekliyoruz.\n  # wheel grubu bir\u00e7ok linux da\u011f\u0131t\u0131m\u0131ndaki sudo grubuyla ayn\u0131 \u015feyi ifade eder.\n  users.users.muratcabuk = {\n    isNormalUser = true;\n    description = \"murat cabuk\";\n    extraGroups = [ \"networkmanager\" \"wheel\" ];\n    packages = with pkgs; [];\n  };\n\n  # free paketlerin kullan\u0131lmas\u0131na izin verdik\n  nixpkgs.config.allowUnfree = true;\n\n  # ileride buna de\u011fi\u015fence\u011fiz.\n  #B\u0130r masa\u00fcst\u00fc ortam\u0131 kurdu\u011fumuzda SSh yerine VirtualBox \u00fczeriden GUI kullanmak ve\n  # Host ile dosya al\u0131\u015fveri\u015fi sa\u011flam i\u00e7in kullan\u0131an ayalarlar.\n  virtualisation.virtualbox.guest.enable = true;\n  virtualisation.virtualbox.guest.x11 = true;\n\n\n  # Sistemde kullan\u0131c\u0131dan ba\u011f\u0131ms\u0131z kullan\u0131lacak paketler\n  # ilerde buralar\u0131 da de\u011fi\u015ftirece\u011fiz.\n  environment.systemPackages = with pkgs; [\n    vim\n    wget\n    curl\n    git\n  ];\n\n   # SSh \u0131 a\u00e7t\u0131k\n   services.openssh.enable = true;\n\n  # Firewall'\u0131 kapatt\u0131k\n   networking.firewall.enable = false;\n\n   # Sistemde kullan\u0131c\u0131dan ba\u011f\u0131ms\u0131z kullan\u0131lacak paketler\n   system.stateVersion = \"23.11\";\n}\n</code></pre> <p>Tabi bir \u00e7ok ayar yapaca\u011f\u0131m\u0131z i\u00e7in ger\u00e7ek bir konfig\u00fcrasyonda bu ayn\u0131 hardware configuration mod\u00fcl\u00fcnde oldu\u011fu gibi konfig\u00fcrasyonlar\u0131 farkl\u0131 mod\u00fcllere b\u00f6lmek gerekebilir.</p> <p>Di\u011fer \u00f6nemli konu da dosyada en attaki stateVersion numaras\u0131 ne i\u015fe yarar? Bunu da alttaki ba\u015fl\u0131kta inceleyelim.</p>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#nixos-nasl-upgrade-edilir","title":"NixOS Nas\u0131l Upgrade Edilir?","text":"<p>Bu versiyon numaras\u0131n\u0131 tabiri caizse dok\u00fcman\u0131m\u0131z\u0131n versiyon numaras\u0131 olarak d\u00fc\u015f\u00fcnebiliriz.</p> <ul> <li>\u00d6ncelikle kesinlikle stateVersion numaras\u0131n\u0131 bir sonraki s\u00fcr\u00fcn notunu okumadan asla de\u011fi\u015ftirmiyoruz. Bu sistemin bozulmas\u0131na neden olabilir. Daha da k\u00f6t\u00fcs\u00fc rollback de \u00e7al\u0131\u015fmayabilir.</li> <li>Sistem bulundu\u011fumuz stateVersion \u00fczerinden paket g\u00fcncellemelerini otomatik olarak yapar.</li> <li>Bu de\u011ferin mevcut NixOS s\u00fcr\u00fcm\u00fcnden daha d\u00fc\u015f\u00fck olmas\u0131, sisteminizin modas\u0131 ge\u00e7mi\u015f, destek d\u0131\u015f\u0131 veya savunmas\u0131z oldu\u011fu anlam\u0131na gelmez.</li> <li>Bundan dolay\u0131 bu de\u011feri, yap\u0131land\u0131rmam\u0131za yapaca\u011f\u0131 t\u00fcm de\u011fi\u015fiklikleri manuel olarak incelemedi\u011fimiz ve verilerinizi buna g\u00f6re ta\u015f\u0131mad\u0131\u011f\u0131m\u0131z s\u00fcrece de\u011fi\u015ftirmemeliyiz. Bunun i\u00e7in bir nedenden \u00f6t\u00fcr\u00fc \u00f6rne\u011fin stateVersion numaras\u0131n\u0131 release 23.11'e ge\u00e7irmek istiyorsak \u00f6ncelikle release notlar\u0131n\u0131 okumal\u0131y\u0131z. Bu notlar bize e\u011fr bu de\u011fi\u015ftirmeyi yaparsak hangi verilerimizde problem olaca\u011f\u0131n\u0131 ve bunlar\u0131 nas\u0131l \u00e7\u00f6zebilece\u011fimizi anlat\u0131r.</li> </ul> <p>Bu se\u00e7enek, bu belirli makineye ilk y\u00fckledi\u011finiz NixOS s\u00fcr\u00fcm\u00fcn\u00fc tan\u0131mlar ve eski NixOS s\u00fcr\u00fcmlerinde olu\u015fturulan uygulama verileriyle (\u00f6rne\u011fin veritabanlar\u0131) uyumlulu\u011fu korumak i\u00e7in kullan\u0131l\u0131r.</p> <p>\u00d6rne\u011fin, NixOS XX.YY s\u00fcr\u00fcm\u00fc varsay\u0131lan olarak AwesomeDB N s\u00fcr\u00fcm\u00fcyle birlikte gelirse ve daha sonra XX.YY+1 s\u00fcr\u00fcm\u00fcne y\u00fckseltilirse, AwesomeDB N+1 s\u00fcr\u00fcm\u00fcyle birlikte gelen bu s\u00fcr\u00fcm, mevcut veritabanlar\u0131yla art\u0131k uyumlu olmayabilir. Bu, uygulamalar\u0131n \u00e7al\u0131\u015fmas\u0131na engel olabilir veya hatta veri kayb\u0131na yol a\u00e7abilir. stateVersion mekanizmas\u0131, varsay\u0131lan paket s\u00fcr\u00fcmlerini, her zaman en son s\u00fcr\u00fcm\u00fc kullanmak yerine, y\u00fckledi\u011finiz ilk NixOS s\u00fcr\u00fcm\u00fcne (stateVersion ile kodlanm\u0131\u015f) ba\u011fl\u0131 hale getirerek bu durumdan ka\u00e7\u0131n\u0131r.</p> <p>Bu, genellikle verilerini otomatik olarak y\u00fckseltemeyen uygulamalar\u0131 etkiler. Otomatik ge\u00e7i\u015fleri destekleyen uygulamalar ve hizmetler, siz y\u00fckseltme yapt\u0131\u011f\u0131n\u0131zda en son s\u00fcr\u00fcmlerde kalacakt\u0131r.</p> <p>Otomatik y\u00fckseltmelerde da zaten problem olabilecekler kontrol edilir. \u00d6rne\u011fin Postgresql paketinin y\u00fckseltilmesi her setateVersion'a \u00f6zel yap\u0131l\u0131r.</p> <pre><code>    services.postgresql.package = let\n        mkThrow = ver: throw \"postgresql_${ver} was removed, please upgrade your postgresql version.\";\n        base = if versionAtLeast config.system.stateVersion \"23.11\" then pkgs.postgresql_15\n            else if versionAtLeast config.system.stateVersion \"22.05\" then pkgs.postgresql_14\n            else if versionAtLeast config.system.stateVersion \"21.11\" then pkgs.postgresql_13\n            else if versionAtLeast config.system.stateVersion \"20.03\" then mkThrow \"11\"\n            else if versionAtLeast config.system.stateVersion \"17.09\" then mkThrow \"9_6\"\n            else mkThrow \"9_5\";\n    in\n      # Note: when changing the default, make it conditional on\n      # \u2018system.stateVersion\u2019 to maintain compatibility with existing\n      # systems!\n      mkDefault (if cfg.enableJIT then base.withJIT else base);\n</code></pre> <p>\u00c7o\u011fu kullan\u0131c\u0131, sisteminizi yeni bir NixOS s\u00fcr\u00fcm\u00fcne y\u00fckseltmi\u015f olsan\u0131z bile, ilk kurulumdan sonra hi\u00e7bir nedenle bu de\u011feri de\u011fi\u015ftirmemelidir.Bu de\u011fer, paketlerinizin ve i\u015fletim sisteminizin \u00e7ekildi\u011fi Nixpkgs s\u00fcr\u00fcm\u00fcn\u00fc etkilemez, bu nedenle onu de\u011fi\u015ftirmek sisteminizi y\u00fckseltmez. Bu de\u011ferin mevcut NixOS s\u00fcr\u00fcm\u00fcnden daha d\u00fc\u015f\u00fck olmas\u0131, sisteminizin modas\u0131 ge\u00e7mi\u015f, destek d\u0131\u015f\u0131 veya savunmas\u0131z oldu\u011fu anlam\u0131na gelmez.</p> <p>Zaten bunu \u015fu \u015fekilde de test edebilirsiniz. Alttaki komutla sisteminizin versiyonunu g\u00f6rebilirsiniz. en son upgrade ald\u0131\u011f\u0131 tarih 2024-02-26 olarak g\u00f6r\u00fcn\u00fcyor ki ben sistemi herhalde bu tarihten 1 hafta \u00f6nce kurmu\u015fumdur.</p> <pre><code> cat /run/current-system/nixos-version\n# 23.11.20240226.b7ee09c\n\n# active/current system hakk\u0131nda daha fazla bilgi almak i\u00e7in `/run/current-system` dinizi incelenebilir. Bu arada bu dizin de /nix/store alt\u0131ndad\u0131r `/run` alt\u0131n a symbolic link iel ba\u011fl\u0131d\u0131r.\n\nll /run/current-system/\n</code></pre> <ul> <li>Peki diyelim ki bu de\u011fer d\u00fc\u015f\u00fck olmas\u0131na ra\u011fmen bir paketin \u00fcst versiyonunu kullanmak istersek veya tam tersi versiyon yukar\u0131da olsa bile bir paketin alt versiyon kullanmak istersek ne yapaca\u011f\u0131z?</li> </ul> <p>\u00d6ncelikle \u015funu bilmek gerekiyor ki sistemi her zaman en son s\u00fcr\u00fcmde tutmam\u0131z laz\u0131m. Zaten sistemimiz de her zaman otomatik upgrade ile bunu sa\u011fl\u0131yor.</p> <p>E\u011fer bir paketin/uygulaman\u0131n farkl\u0131 bir versiyonu test edeceksek bunun i\u00e7in <code>nix shell</code> komutunu kullanmak en do\u011frusu. Mesela sisteminiz 23.11 ve siz 22.05 deki bir paketi test etmek istiyorsunuz. Testiniz bittikten sonra da sistemden otomatik kald\u0131r\u0131ls\u0131n istiyorsunuz. Bu durumda alttaki komutu kullanabilirsiniz.</p> <pre><code>  nix shell nixpkgs/nixos-22.05#hello\n  # \u00e7al\u0131\u015ft\u0131rmak i\u00e7inde hello komutunu \u00e7al\u0131\u015ft\u0131rabilirsiniz\n</code></pre> <p>Bu arada \u00f6nceki yaz\u0131lar\u0131m\u0131zda <code>nix shell</code>, <code>nix profile</code> ve <code>nix develop</code> komutlar\u0131n\u0131 detayl\u0131 olarak inceledik. O yaz\u0131lar\u0131 okuman\u0131z\u0131 da tavsiye ederim.</p> <p>E\u011fer kal\u0131c\u0131 olarak kurmak istiyorsan\u0131z <code>nix profile</code> komutunu kullanabilirsiniz.</p> <pre><code>  nix profile install nixpkgs/nixos-22.05#hello\n</code></pre> <p>Tabi bu tekniklerin hi\u00e7 birisi declarative de\u011fil ve bu nedenle de\u011fi\u015fikliklerinizi kaydetmek istiyorsan\u0131z bunu <code>flake.nix</code> dosyan\u0131za eklemeniz gerekiyor. Ayr\u0131ca servis kuracaksan\u0131z veya kuraca\u011f\u0131n\u0131z uygulamada baz\u0131 de\u011fi\u015fikliler yapman\u0131z gerekiyorsa bu durumda da zaten declarative yolu tercih etmeniz gerekiyor.</p> <p>Flake Dosyan\u0131zda iki farkl\u0131 registry tan\u0131mlaman\u0131z gerekiyor. Mesela alttaki \u00f6rnekte sistemde aktif olarak 23.11 versiyonu kullan\u0131lmas\u0131na ra\u011fmen unstable versiyonundan paket y\u00fckleyebilmek i\u00e7in unstable registry configuration dosyas\u0131nda kullan\u0131labilir hale getiriliyor..</p> <pre><code># flake.nix\n{\ndescription = \"NixOS configuration with two or more channels\";\n\ninputs = {\n  nixpkgs.url = \"nixpkgs/nixos-23.11\";\n  nixpkgs-unstable.url = \"nixpkgs/nixos-unstable\";\n};\n\noutputs = { self, nixpkgs, nixpkgs-unstable }:\n  let\n    system = \"x86_64-linux\";\n    overlay-unstable = final: prev: {\n      unstable = nixpkgs-unstable.legacyPackages.${prev.system};\n    };\n  in {\n    nixosConfigurations.\"&lt;hostname&gt;\" = nixpkgs.lib.nixosSystem {\n      inherit system;\n      modules = [\n        # overlay kullan\u0131larak unstable congifuration.nix dosyas\u0131nda kullan\u0131labilir hale getiriliyor\n        ({ config, pkgs, ... }: { nixpkgs.overlays = [ overlay-unstable ]; })\n        ./configuration.nix\n      ];\n    };\n  };\n}\n</code></pre> <p>Mesela Firefox 23.11'den y\u00fcklenirken Chromium unstable'den y\u00fckleniyor.</p> <pre><code># configuration.nix\n# NixOS configuration.nix art\u0131k \"pkgs.package\" veya \"pkgs.unstable.package\" kullanabilir hale geldi\n{ config, pkgs, ... }: {\n  environment.systemPackages = [pkgs.firefox pkgs.unstable.chromium];\n  # ...\n}\n</code></pre> <p>Tabi burada e\u011fer y\u00fckledi\u011fimiz \u015fey bir paket bir servise option ayarlar\u0131n\u0131n yap\u0131lmas\u0131 gerekebilir. \u0130lgili versiyonun b\u00fct\u00fcn ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 Nix paket y\u00f6neticisi hallediyor.</p> <p>\u015eimdi home-manager'\u0131 da sisteme dahil edelim ve kullan\u0131c\u0131 ile sistemi birbirinden ay\u0131rd\u0131ktan sonra iki taraf i\u00e7in ad\u0131m ad\u0131m ayarlar\u0131m\u0131z\u0131 eklemeye devam edelim.</p>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#home-manager-modulunun-eklenmesi","title":"Home-Manager Mod\u00fcl\u00fcn\u00fcn Eklenmesi","text":"<p>Home-manager tamamen bir community projesidir.</p> <p>Home-manager ile y\u00f6netilecek kullan\u0131c\u0131 NixOS'e user olarak eklenmi\u015f olmal\u0131. Mesel bendeki <code>configuration.nix</code> dosyas\u0131nda alttaki gibi ekli.</p> <pre><code>  users.users.muratcabuk = {\n    isNormalUser = true;\n    description = \"murat cabuk\";\n    extraGroups = [ \"networkmanager\" \"wheel\" ];\n    packages = with pkgs; [];\n  };\n</code></pre> <p>Ayn\u0131 kullan\u0131c\u0131 i\u00e7in modules dizisine <code>murat-home-manager.nix</code> dosyas\u0131n\u0131 ekliyoruz. <code>flake.nix</code> dosyas\u0131nda da \u00f6ncelikle inputs'lara ve alttaki gib modules dizisine ekleyelim. Home manager'\u0131n NixOS ile ayn\u0131 version olmas\u0131na dikket edin. Versiyon bilgileri i\u00e7in \u015fu sayfay\u0131 takip edebilrisiniz.</p> <pre><code>{\n  description = \"Murat Cabuk NixOS Configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.11\";\n\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n\n  };\n\n  outputs = { self, nixpkgs, home-manager, ... }@inputs:\n  let\n\n    # \u00fczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z sistemin Nix'deki kod add\u0131.\n    system = \"x86_64-linux\";\n\n    # 2 adet overlay var\n    overlays = [\n                (import ./overlays/custom.nix)\n                (import ./overlays/hello.nix)\n               ] ;\n    # ne t\u00fcr bir sistemde \u00e7al\u0131\u015f\u0131yorsak onun i\u00e7in nixpkgs koleksiyonu ve k\u00fct\u00fcphanesi olu\u015fturuluyor.\n    pkgs = import nixpkgs {\n              inherit system;\n              overlays = overlays;\n            };\n\n    # build al\u0131nan veya override edilen paketler bu flake ile yay\u0131nlan\u0131yor.\n    packages = {\n        x86_64-linux.default = pkgs.defaultapp;\n        x86_64-linux.defaultfile = pkgs.defaultfile;\n        x86_64-linux.defaultalt = pkgs.defaultalt;\n        x86_64-linux.nixapp = pkgs.nixapp;\n        x86_64-linux.message = pkgs.message;\n        x86_64-linux.testapp = pkgs.testapp;\n        x86_64-linux.hello = pkgs.hello;\n        x86_64-linux.hello-custom = pkgs.hello-custom;\n    };\n\n  in {\n\n    # bu sistemin ad\u0131 muratpc olarak de\u011fi\u015ftirildi\n    nixosConfigurations.muratpc = nixpkgs.lib.nixosSystem {\n\n      # systm bilgisi yukar\u0131da tan\u0131mlana system de\u011fi\u015fkeniniden al\u0131nd\u0131\n      system = system;\n\n      # dosya adresi de\u011fi\u015ftirildi\n      modules = [\n        ./modules/nixos-configuration.nix\n\n        home-manager.nixosModules.home-manager\n          {\n            home-manager.useGlobalPkgs = true;\n            home-manager.useUserPackages = true;\n            home-manager.users.muratcabuk = import ./modules/murat-home-manager.nix;\n          }\n      ];\n    };\n\n    packages = packages;\n  };\n}\n</code></pre> <p>Konfig\u00fcrasyondaki <code>home-manager.inputs.nixpkgs.follows = \"nixpkgs\";</code> sat\u0131r\u0131nda ge\u00e7en follows keyword'\u00fc ile Nix paket y\u00f6neticisine e\u011fer nixpkgs update edilirse home-manager pakaetinin de update edilmesi gerekti\u011fini s\u00f6ylemi\u015f oluyoruz.</p> <p>\u015eimdi home-manager dosyam\u0131z\u0131 d\u00fczenlemeye ba\u015flayal\u0131m.</p> <pre><code>{ config, pkgs, ... }:\n\n{\n  # buradaki kullan\u0131c\u0131 nixos-configuration.nix dosyas\u0131nda tan\u0131ml\u0131 olan kullan\u0131c\u0131 ile ayn\u0131 olmal\u0131\n  home.username = \"muratcabuk\";\n  home.homeDirectory = \"/home/muratcabuk\";\n\n\n\n  # bu de\u011feri de ilk kuruulumdaki gibi b\u0131rak\u0131yoruz.\n  # daha \u00f6nce flake.nix dosyas\u0131 i\u00e7in s\u00f6ylediklerimiz buras\u0131 i\u00e7in de ge\u00e7erli\n  home.stateVersion = \"23.11\";\n\n  # Homemanager \u0131n kendini kurmas\u0131n\u0131 ve ayarlamas\u0131n\u0131 s\u00f6yl\u00fcyoruz.\n  programs.home-manager.enable = true;\n}\n</code></pre> <p>\u015eimdi buraya kadar yapt\u0131klar\u0131m\u0131z\u0131 NixOS'a uygulayal\u0131m. Ancak yapt\u0131\u011f\u0131m\u0131z 2 de\u011fi\u015fikli\u011fi hat\u0131rlatmak istiyorum</p> <ol> <li><code>nixos-configuration.nix</code> dosyas\u0131nda Hostame'i de\u011fi\u015ftirmi\u015ftik: Mesela benimkinde <code>networking.hostName = \"muratpc\";</code> olarka ayarl\u0131.</li> <li><code>flake.nix</code> dosyas\u0131nda <code>nixosConfigurations.muratpc = nixpkgs.lib.nixosSystem</code> sat\u0131r\u0131nda sistem \u00e7\u0131kt\u0131m\u0131z\u0131n ad\u0131n\u0131 de\u011fi\u015ftirmi\u015ftik. Mesela benimkinde hostnem ad\u0131yla ayn\u0131 yani mcabuk.</li> </ol> <p>Flake dosyas\u0131ndaki de\u011fi\u015fikli\u015fkten solay\u0131 art\u0131k build al\u0131rken nixos de\u011fil mcabukpc olarak build al\u0131yorum.</p> <pre><code>sudo nixos-rebuild switch --flake .#muratpc --impure\n</code></pre> <p>Build i\u015flemi bitti\u011finde art\u0131k home-manager y\u00fcklenmi\u015f olacak.</p>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#nixos-konfigurasyonu","title":"NixOS Konfig\u00fcrasyonu","text":"<p>Bu noktadan sonra bir strateji belirlememiz gerekiyor. Kendimede yak\u0131n buldu\u011fum i\u00e7in :) bir yaz\u0131l\u0131mc\u0131n\u0131n i\u015f bilgisayar\u0131n\u0131 konfig\u00fcre edelim diyorum.</p> <p>Home Manager Konfig\u00fcrasyonu</p> <ul> <li>Varsay\u0131lan metin edit\u00f6r\u00fcm\u00fcz\u00fc Vim olarak ayarlayal\u0131m</li> <li>IDE olarak Visual Studio Code kural\u0131m</li> <li>Shell olarak Zsh'\u0131 ayarlayal\u0131m</li> <li>Varsay\u0131lan Browser olarak Google Chrome kural\u0131m</li> </ul> <p>System Konfig\u00fcrasyonu</p> <ul> <li>Sistem dilini ingilizce olarak ayarlayal\u0131m</li> <li>Masa\u00fcst\u00fc Ortam\u0131 Olarak KDE'i kural\u0131m</li> <li>Sistemin varsay\u0131lan metin edit\u00f6r\u00fc olarak Nano'yu ayaralayal\u0131m</li> <li>Sanalla\u015ft\u0131rma olarak kvm-qemu'yu kural\u0131m</li> <li>Docker kural\u0131m ve ayaralar\u0131n\u0131 yapal\u0131m</li> <li>Sistem i\u00e7in Firefox'\u0131 varsay\u0131lan Browser olarak kural\u0131m</li> </ul> <p>Tabi daha bir \u00e7ok \u015fey yap\u0131labilir ancak bunu yazarak bitiremeyiz. En temekl haliyke b\u00f6yle bir sistem kuramak baya bi i\u015fimizi g\u00f6recektir. Zatwn incelemeniz ve \u00f6rnek almn\u0131z i\u00e7in bir \u00e7okGithub reposunun adresini altta verece\u011fim.</p> <p>Home Manager Konfig\u00fcrasyonu yaparken bir \u00e7ok option'\u0131 ayarlamam\u0131z ve gereken yerlerde olmayan option'lar\u0131 da yazmam\u0131z gerekecek. Home manager'\u0131n normal NixOS mod\u00fclleriden en \u00f6nemli far\u0131 da zaten \u00f6zellikle home dizininne ve kullan\u0131c\u0131 \u00f6zelle\u015ftirmelerine y\u00f6nelik option'lar sunuyor olmas\u0131. \u015eu sayfadan home manager'\u0131n sunmu\u015f oldu\u011fu opiton'lar\u0131 inceleyebilirsiniz ki zaten konfig\u00fcrasyon yapmaya ba\u015flad\u0131\u011f\u0131n\u0131zda bu sayfay\u0131 bir \u00e7ok kez ziyaret etmeniz gerekecek.</p> <p>Home manager ile kendi paketlerimizi y\u00fckleyebiliriz, sistemde zaten kurulu olan paketleri ayarlayabiliriz. Masa\u00fcst\u00fc ortam\u0131m\u0131z\u0131 ayarayabiliriz. Kendi dotfile'lar\u0131m\u0131z\u0131 veya di\u011fer config\u00fcrasyon dosyala\u0131m\u0131z y\u00f6netebiliriz. YAni temel de ama\u00e7 ki\u015fisel tercihlerimizi declarative olarak y\u00f6netebilmemmizi sa\u011flar.</p>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#kde-masaustu-ortam-kurulumu-dil-ayarlar-zshn-ayarlanmas-browser-ayarlar","title":"KDE Masa\u00fcst\u00fc Ortam\u0131 Kurulumu, Dil ayarlar\u0131, Zsh'\u0131n ayarlanmas\u0131, Browser ayarlar\u0131","text":"<p>Tabii ki biz burada \u00e7ok derin konfig\u00fcrasyona y\u00f6netimi yapmayaca\u011f\u0131z. Amac\u0131m\u0131z sadece aktive etmek ve ufak tefek dokunu\u015flar yaparak mant\u0131\u011f\u0131n\u0131 anlamak. Yoksa KDE'de kulland\u0131\u011f\u0131m\u0131z k\u0131sa yollar\u0131, temelar\u0131, Kwin scriptleri,...vb b\u00fct\u00fcn ayarlar\u0131n\u0131z\u0131 declarative olarak yazmak m\u00fcmk\u00fcn.</p> <p>Biz kullanmayaca\u011f\u0131z ancak linkini vermek istedim. KDE Plasma'y\u0131 daha detayl\u0131 ama daha kolay bir yolla ayalarmyabilmemiz i\u00e7in community bir modul geli\u015ftirmi\u015f \u015fu linkten g\u00f6rebilirsiniz. GitHub'da g\u00f6rebilce\u011finiz bir \u00e7ok \u00f6rnekte de kullan\u0131l\u0131yor.</p> <p>Bu b\u00f6l\u00fcmde yapt\u0131klar\u0131m\u0131z\u0131 da GitHub respsundaki kde-zsh branch'inde bulabilirsiniz.</p> <p><code>nixos-configuration.nix</code> dosyam\u0131za bir g\u00f6z atal\u0131m. Yeni eklene nveya de\u011fi\u015ftirilen her yerde a\u00e7\u0131klama ekledim.</p> <pre><code># nixos-configuration.nix\n{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Include the results of the hardware scan.\n      ../hosts/lenovo-l15/hardware-configuration.nix\n    ];\n\n  nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ];\n\n  # Bootloader.\n  boot.loader.grub.enable = true;\n  boot.loader.grub.device = \"/dev/sda\";\n  boot.loader.grub.useOSProber = true;\n\n  networking.hostName = \"muratpc\";\n\n  # Enable networking\n  networking.networkmanager.enable = true;\n\n  # Set your time zone.\n  time.timeZone = \"Europe/Istanbul\";\n\n  # Select internationalisation properties.\n  i18n.defaultLocale = \"en_US.UTF-8\";\n  i18n.supportedLocales = [\"all\"];\n\n  i18n.extraLocaleSettings = {\n    LC_ADDRESS = \"tr_TR.UTF-8\";\n    LC_IDENTIFICATION = \"tr_TR.UTF-8\";\n    LC_MEASUREMENT = \"tr_TR.UTF-8\";\n    LC_MONETARY = \"tr_TR.UTF-8\";\n    LC_NAME = \"tr_TR.UTF-8\";\n    LC_NUMERIC = \"tr_TR.UTF-8\";\n    LC_PAPER = \"tr_TR.UTF-8\";\n    LC_TELEPHONE = \"tr_TR.UTF-8\";\n    LC_TIME = \"tr_TR.UTF-8\";\n  };\n\n  # Grafik servisini enable ediyoruz\n  # klavye ayar\u0131 yap\u0131l\u0131yor\n  services.xserver = {\n\n    enable = true;\n\n    # sddm Oturum Y\u00f6neticisini aktif ediyoruz\n    displayManager.sddm = {\n                              enable = true;\n                              autoNumlock = true;\n    };\n\n    # kde plasma 5 aktif ediliyor                          };\n    desktopManager.plasma5.enable = true;\n\n    layout = \"tr\";\n    xkbVariant = \"\";\n  };\n\n  # Enable the OpenSSH daemon.\n  services.openssh.enable = true;\n\n  # Configure console keymap\n  console.keyMap = \"trq\";\n\n  # Define a user account. Don't forget to set a password with `passwd`.\n  users.users.muratcabuk = {\n    isNormalUser = true;\n    description = \"murat cabuk\";\n    extraGroups = [ \"networkmanager\" \"wheel\" \"docker\"];\n    packages = with pkgs; [];\n\n    # kullan\u0131c\u0131 default shell i zsh olarka ayarlan\u0131yor\n    shell = pkgs.zsh;\n  };\n\n  # https://nixos.wiki/wiki/Command_Shell\n  # Sistemdeki b\u00fct\u00fcn kullan\u0131c\u0131lar i\u00e7in bash varsay\u0131lan shell olarak ayaraln\u0131yor\n  # tabiiki kendi kullan\u0131c\u0131\u0131da da oldu\u011fu gibi farkl\u0131 shell'lere ge\u00e7i\u015f yapabilir\n  users.defaultUserShell = pkgs.bash;\n\n  # Allow unfree packages\n  nixpkgs.config.allowUnfree = true;\n  virtualisation.virtualbox.guest.enable = true;\n  virtualisation.virtualbox.guest.x11 = true;\n\n\n  environment.systemPackages = with pkgs; [\n    nano\n    wget\n    curl\n    git\n    home-manager\n\n    # kde plasma 5 paketleri\n    kate\n    kwin\n  ];\n\n  ## https://wiki.archlinux.org/title/XDG_Base_Directory\n  # environment.sessionVariables = {\n  #   XDG_CACHE_HOME = \"$HOME/.cache\";\n  #   XDG_CONFIG_DIRS = \"/etc/xdg\";\n  #   XDG_CONFIG_HOME = \"$HOME/.config\";\n  #   XDG_DATA_DIRS = \"/usr/local/share/:/usr/share/\";\n  #   XDG_DATA_HOME = \"$HOME/.local/share\";\n  #   XDG_STATE_HOME = \"$HOME/.local/state\";\n  # };\n\n\n  # https://nixos.wiki/wiki/Fonts\n  # ihtiyac\u0131m\u0131z olabilcek fontlar y\u00fckleniyor.\n  fonts.packages = with pkgs; [\n                                  meslo-lgs-nf\n                                  noto-fonts\n                                  noto-fonts-cjk\n                                  noto-fonts-emoji\n                                  font-awesome\n                                  powerline-fonts\n                                  powerline-symbols\n                                  (nerdfonts.override { fonts = [ \"NerdFontsSymbolsOnly\" ]; })\n                              ];\n    # zsh'\u0131 sadece home-manager'da aktif etmek yetmiyor\n    # burada da aktif etmek gerekiyor\n    programs = {\n      zsh.enable = true;\n      };\n\n\n    networking.firewall.enable = false;\n\n    system.stateVersion = \"23.11\";\n\n}\n</code></pre> <p>NisOs konfig\u00fcrasyonu yaparken bol miktarda yukar\u0131daki gibi option ayarlamak gerekiyor. Bunun i\u00e7in NixOS Arama sayfas\u0131nda hem opiton hem de paket arayabilirniz. </p> <p>Bir de Homa_manager dosyam\u0131za bakal\u0131m.</p> <pre><code># murat-home-manager.nix\n{ config, pkgs, ... }:\n\n{\n  # buradaki kullan\u0131c\u0131 nixos-configuration.nix dosyas\u0131nda tan\u0131ml\u0131 olan kullan\u0131c\u0131 ile ayn\u0131 olmal\u0131\n  home.username = \"muratcabuk\";\n  home.homeDirectory = \"/home/muratcabuk\";\n\n  # Language ayaralar\u0131 : https://nix-community.github.io/home-manager/options.xhtml#opt-home.language\n  home.language.base = \"en_US.UTF-8\";\n\n  home.keyboard = {\n    layout = \"tr\";\n  };\n\n  # Kurulmas\u0131 gereken pakatler\n  home.packages = with pkgs; [\n    vim\n\n    # zsh\n    zsh\n    oh-my-zsh\n    zsh-powerlevel10k\n    zsh-completions\n    zsh-syntax-highlighting\n    zsh-history-substring-search\n\n    powershell\n  ];\n\n  # Uygulamalar\u0131n Konfig\u00fcrasyonu\n    programs.home-manager.enable = true;\n    programs.chromium = {\n                          enable = true;\n                          extensions = [\"aapbdbdomjkkjkaonfhkkikfgjllcleb\"];\n                        };\n\n    # Yukar\u0131da kurulan paketlerin ayarlanmas\u0131\n    # zsh ayarlar\u0131n\u0131n yap\u0131lmas\u0131\n    programs.zsh = {\n\n                      history.size = 10000;\n                      historySubstringSearch.enable = true;\n                      enable = true;\n                      enableCompletion = true;\n                      enableAutosuggestions = true;\n                      dotDir = \".config/zsh\";\n                      plugins = [\n                                  # zaten kurulu olan powerlevel10k paketinin ayarlamass\u0131n\u0131 yap\u0131yoruz\n                                  {\n                                    name = \"powerlevel10k\";\n                                    src = pkgs.zsh-powerlevel10k;\n                                    file = \"share/zsh-powerlevel10k/powerlevel10k.zsh-theme\";\n                                  }\n\n                                  # Elimizdeki konfigurasyon dosyas\u0131n\u0131 sisteme kopyal\u0131yoruz.\n                                  # \u00fcst dinizdek config klas\u00f6r\u00fcndeki .pk10k.zsh dosyas\u0131n\u0131 kopyal\u0131yoruz\n                                  {\n                                    name = \"powerlevel10k-config\";\n                                    src = ../config;\n                                    file = \".p10k.zsh\";\n                                  }\n\n                                  # manual olarka paket kuruyoruz\n                                  {\n                                    name = \"zsh-syntax-highlighting\";\n                                    src = pkgs.fetchFromGitHub {\n                                    owner = \"zsh-users\";\n                                    repo = \"zsh-syntax-highlighting\";\n                                    rev = \"0.7.1\";\n                                    sha256 = \"03r6hpb5fy4yaakqm3lbf4xcvd408r44jgpv4lnzl9asp4sb9qc0\";\n                                            };\n                                  }\n\n                                ];\n                      oh-my-zsh = {\n                                    enable = true;\n                                    package = pkgs.oh-my-zsh;\n                                    plugins = [ \"git\" \"sudo\"];\n\n\n                                  };\n                      # zsh i\u00e7ine alias tan\u0131ml\u0131yoruz\n                      shellAliases = {\n                                        ll = \"ls -l\";\n                                        nixupdate = \"sudo nixos-rebuild switch --flake .#muratpc --impure\";\n                                      };\n\n                    };\n\n  # Servislerin Konfig\u00fcrasyonu\n  services.kdeconnect = {\n      enable = true;\n      indicator = true;\n    };\n\n\n  # bu de\u011feri de ilk kuruulumdaki gibi b\u0131rak\u0131yoruz.\n  # daha \u00f6nce flake.nix dosyas\u0131 i\u00e7in s\u00f6ylediklerimiz buras\u0131 i\u00e7in de ge\u00e7erli\n  home.stateVersion = \"23.11\";\n\n}\n</code></pre> <p>NixOS i\u00e7in home manager gerekli de\u011fil. Hatta home manager i\u00e7in NixOS'da gerekli de\u011fil. Yani homa manger'\u0131 Nix paket y\u00f6netcisini kurdu\u011funuz di\u011fer Linux da\u011f\u0131t\u0131mlar\u0131nda da kullanabilirsiniz. Yeterince uzamnla\u015ft\u0131\u011f\u0131n\u0131da kendiniz de mod\u00fcllerinizi yazabilirsiniz. Ancak yine de home manager bu home dizini i\u00e7in bize sundu\u011fu stadart kab\u00fcl g\u00f6rm\u00fc\u015f ve bir \u00e7ok kolayl\u0131\u011f\u0131 da sunuyor. Yani illa bir\u015feyler yapmak isterseniz home manager'a detek olabilirsiniz.</p> <p>Flake.nix dosyas\u0131nda bir de\u011fi\u015fiklik yapmam\u0131\u015ft\u0131k.</p>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#vs-code-qemu-kvm-ve-docker-kurulumu-ve-ayarlarnn-yaplmas","title":"VS Code, Qemu-KVM ve Docker kurulumu ve Ayarlar\u0131n\u0131n yap\u0131lmas\u0131","text":"<p>\u00d6ncelikle VS Code kurulumunu yapal\u0131m. Kurgumuz \u015fu \u015fekilde olacak. Visual Studio'yu kuraca\u011f\u0131z, basit ki\u015fisel ayarlar yapaca\u011f\u0131z, bir iki extension kuraca\u011f\u0131z. Ancak kuraca\u011f\u0131m\u0131z extension'lardan birini nixpks'nin unstable veryionundan kuraca\u011f\u0131z. Ancak home manager'da sadece 23.11 paket kolksiyonunu parametre olarak ge\u00e7irmi\u015ftik. Ektra parametre ge\u00e7irmek i\u00e7in flake \u00fczerinden extraSpecialArgs parametresini ge\u00e7irmemiz gerekiyor.</p> <p>\u00d6ncelikle flake i\u00e7inde inputs'a yeni bir paket koleksiyonu <code>nixpkgs-unstable</code> tan\u0131ml\u0131yoruz.</p> <pre><code># k\u0131salt\u0131ld\u0131\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.11\";\n    nixpkgs-unstable.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n\n    home-manager = {\n      url = \"github:nix-community/home-manager/release-23.11\";  # this selects the release-branch and needs to match Nixpkgs\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n\n\n  };\n\n  outputs = { self, nixpkgs,home-manager,nixpkgs-unstable, ... }@inputs:\n  let\n\n\n# k\u0131salt\u0131ld\u0131\n</code></pre> <p>Daha sonra bunu flake \u00fczerinde home manager'a parametre olarak ge\u00e7irmemiz gerekiyor.</p> <pre><code># k\u0131salt\u0131ld\u0131\n\n  # dosya adresi de\u011fi\u015ftirildi\n      modules = [\n          ./modules/nixos-configuration.nix\n          home-manager.nixosModules.home-manager\n            {\n              home-manager.useGlobalPkgs = true;\n              home-manager.useUserPackages = true;\n              home-manager.users.muratcabuk = import ./modules/murat-home-manager.nix;\n\n              # home-manager i\u00e7in ektra parametre ge\u00e7iriyoruz\n              home-manager.extraSpecialArgs = {inherit pkgs-unstable; };\n\n            }\n      ];\n\n# k\u0131salt\u0131ld\u0131\n</code></pre> <p>\u015eimdi bir de home manager'a VS Code ayarlar\u0131m\u0131z\u0131 ekleyelim.</p> <pre><code># home-manager.nix\n\n{ config, pkgs, pkgs-unstable, ... }:\n\n# k\u0131salt\u0131ld\u0131\n\nprograms.vscode = {\n                    enable = true;\n\n                    # bu ayar sayesinde VS Code'u manulal olarak da y\u00f6ntecilece\u011fiz.\n                    # \u00d6Zellikle NixOS a al\u0131\u015fma \u015famas\u0131nda faydal\u0131 olacakt\u0131r.\n                    mutableExtensionsDir = true;\n\n                    # Ki\u015fisel ayarlarm\u0131z\u0131 json format da girebiliriz.\n                    userSettings = {\n                                      \"editor.fontSize\" = 16;\n                                    };\n\n                    # vs code update'leri kontrol edilsin mi?\n                    enableUpdateCheck = true;\n                    # extensiton lar\u0131n update'leri kontrol edilsin mi?\n                    enableExtensionUpdateCheck = true;\n\n                    # community open source edition olan  pkgs.vscodium  paketi de kullan\u0131labilir\n                    package = pkgs.vscode;\n\n                    # extension listesi yaz\u0131labilir\n                    # ancak tabi extension lar\u0131 burradan y\u00fcklemek istersek bu paketlerin yaz\u0131lm\u0131\u015f olmas\u0131 laz\u0131m.\n                    # \u015fuan NixOS paket y\u00f6neticisinde 290 paketin yaz\u0131l\u0131 oldu\u011fu g\u00f6r\u00fcn\u00fcyor.\n                    # ayr\u0131ca istenirse farkl\u0131 version lardan da kurulum yap\u0131labilir.\n                    # Altta ili liste ++ oprat\u00f6r\u00fc ile top\u015fan\u0131yor.\n                    extensions = (with pkgs.vscode-extensions;[\n                                  pkgs.vscode-extensions.bbenoist.nix\n                                  bierner.markdown-emoji\n                                  ]) ++ (with pkgs-unstable.vscode-extensions; [\n                                                # Unstable nixpkgs den paket y\u00fckleniyor\n                                                seatonjiang.gitmoji-vscode\n                                                ]);\n                    # k\u0131sayol tan\u0131mlar\u0131 yap\u0131labilir\n                    keybindings = [\n                                    {\n                                      key = \"ctrl+y\";\n                                      command = \"editor.action.commentLine\";\n                                      when = \"editorTextFocus &amp;&amp; !editorReadonly\";\n                                    }\n                                  ];\n                  };\n\n# k\u0131salt\u0131ld\u0131\n</code></pre> <p>Build al\u0131p \u00e7al\u0131\u015ft\u0131d\u0131\u011f\u0131m\u0131zda VS Code'un kuruldu\u011funu ve extension'lar\u0131n y\u00fcklendi\u011fini g\u00f6rebiliyoruz.</p> <pre><code>sudo nixos-rebuild switch --flake .#muratpc --impure --show-trace --upgrade\n</code></pre> <p>Paket y\u00f6neticisiniden Visual Studio Extension'lar\u0131n dan arama yapabilirsiniz. \u015euan 290 adet paket bulunuyor.</p> <p></p> <p>Ancak bildi\u011finiz \u00fczere e\u011fer VS Code'a GitHub hesab\u0131n\u0131z\u0131 ba\u011flanrsan\u0131z zaten b\u00fct\u00fcn aylar\u0131n\u0131z ve extension'lar\u0131n\u0131z senkronize oluyor. Ben bunu tercih ediyorum a\u00e7\u0131k\u00e7as\u0131.</p> <p>Di\u011fer VS Code option'lar\u0131 i\u00e7in home manager option'lar\u0131nda arama yapabilirsiniz.</p> <p>Visual Studio Code'u \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda extension'lar\u0131n kuruldu\u011funu g\u00f6rebiliyoruz.</p> <p></p> <p>Bir de yapt\u0131\u011f\u0131m\u0131z font ayar\u0131na bakal\u0131m. Fontu 16 olarak ayarlam\u0131\u015ft\u0131k. Onu da g\u00f6rebiliyoruz.</p> <p></p> <p>Bu arada bu b\u00f6l\u00fcm\u00fcn kodlar\u0131n\u0131 da kendi Github hesab\u0131mdaki nixos-sample-dotfiles reposunda vscode-qemu-docker branch'inde bulabilirsiniz.</p> <p>\u015eimdi de Qemu-Kvm (libvirt) ve Docker kurulumlar\u0131n\u0131 yap\u0131p kodun son halini inceleyelim. Bu paketlerin kurulumunu <code>nixos-configuration.nix</code> dosyas\u0131nda yapacakt\u0131k.</p> <pre><code># nixos-configuration.nix\n\n# K\u0131salt\u0131ld\u0131\n\nenvironment.systemPackages = with pkgs; [\n\n  # k\u0131salt\u0131ld\u0131\n\n    # virtualisation olarka  virt-manager '\u0131 ekliyoruz\n    virt-manager\n\n  ];\n\n\n# k\u0131salt\u0131ld\u0131\n\n  # virtualisation / kvm-qemu\n  virtualisation.libvirtd.enable = true;\n</code></pre> <p>Kvm-Qemu (libvirt) ayarlar\u0131nda hata al\u0131rsan\u0131z \u015fu linki ziyaret ediniz.</p> <p>Alttaki komutla s\u015fstemimide kurumlar\u0131 yapabiliriz.</p> <pre><code>sudo nixos-rebuild switch --flake .#muratpc --impure --show-trace --upgrade\n</code></pre> <p>\u00c7al\u0131\u015ft\u0131rd\u0131ktan sonra uygulamalardan virtual machine manager'\u0131 a\u00e7t\u0131\u011f\u0131n\u0131zda <code>can't detect default hypervisor</code> hatas\u0131 verece sistem. Bizde file men\u00fcs\u00fcne gidip yeni bir conneciton eklememizi istiyor. Aynen dedi\u011fini yap\u0131yoruz, File&gt;Add Connection dedi\u011fimizde sadece KVM/QEMU'nun se\u00e7memiz yeterli.</p> <p></p> <p>Son olarka bir de Docker'\u0131 ekleyelim. \u015eu linkten de konuyu inceleyebilirsiniz.</p> <pre><code># k\u0131salt\u0131ld\u0131\n\n  # kullan\u0131c\u0131y\u0131 docker grubuna ekliyoruz\n  users.users.muratcabuk = {\n    isNormalUser = true;\n    description = \"murat cabuk\";\n    extraGroups = [ \"networkmanager\" \"wheel\" \"docker\" \"libvirtd\"];\n\n    # ki\u015fise \u00f6zel paketler. Biz bu k\u0131sm\u0131 home manager ile y\u00f6netece\u011fiz\n    packages = with pkgs; [];\n\n    # kullan\u0131c\u0131 default shell i zsh olarka ayarlan\u0131yor\n    shell = pkgs.zsh;\n  };\n\n\n\n# k\u0131salt\u0131ld\u0131\n\n# virtualisation / kvm-qemu\nvirtualisation.libvirtd.enable = true;\n\n# virtualizatiob docker\nvirtualisation.docker = {\n                        enable = true;\n                        # e\u011fer btrfs kullanacaksan\u0131z\n                        # storageDriver = \"btrfs\";\n\n                        # Docker data dizinini de\u011fi\u015ftirmek isterseniz\n                        #daemon.settings = {\n                        #        data-root = \"/some-place/to-store-the-docker-data\";\n                        #};\n                        };\n</code></pre> <p>Kurulumu yap\u0131p test ediyoruz.</p> <p></p> <p>Bu noktadan sonra biraz da ihtiyac\u0131m\u0131z olabilecek ince detaylarla u\u011fra\u015fal\u0131m.</p>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#bir-servisi-kurmak-ve-gerektiginde-baslatp-durdurmak","title":"Bir Servisi Kurmak ve Gerekti\u011finde Ba\u015flat\u0131p Durdurmak","text":"<p>Bildi\u011finiz \u00fczere servislerl de asl\u0131nda bir uygulama veya paket. Tek farklar\u0131 i\u015fleri bitene kadar veya manual olarak durdurulana kadar yapmas\u0131 gereken i\u015fi yapmaya devam etmesi.</p> <p>\u00d6rne\u011fin bir web servisi (Nginx, Apache, Dotnet Kestrel, NodeJs ExpressJs, Java Tomcat) veya bir veritaban\u0131 (Postgres, Mysql, MS Sql, Oracle) gibi devaml\u0131 \u00e7al\u0131\u015fmas\u0131 gereken uygulamalara servis diyoruz. S\u0131\u011f bi tan\u0131m oldu ama burada yapmak istedi\u011fimiz \u015feyi tan\u0131mlamaya yetiyor.</p> <p>\u00d6rnek olarak Nginx ile bir siteyi yay\u0131na verelim ve gerekti\u011finde ba\u015flat\u0131p durdural\u0131m. Klasik da\u011f\u0131t\u0131mlardan ne gibi farkl\u0131l\u0131klar var g\u00f6relim.</p> <p>Yazd\u0131\u011f\u0131m\u0131z mod\u00fcl\u00fc <code>flake.nix</code> mod\u00fclleri aras\u0131na ekliyoruz.</p> <pre><code># flake.nix\n\n# k\u0131salt\u0131ld\u0131\n\n modules = [\n          ./modules/nixos-configuration.nix\n          home-manager.nixosModules.home-manager\n            {\n              home-manager.useGlobalPkgs = true;\n              home-manager.useUserPackages = true;\n              home-manager.users.muratcabuk = import ./modules/murat-home-manager.nix;\n              # Bu da home-manager i\u00e7in\n              home-manager.extraSpecialArgs = {inherit pkgs-unstable; };\n            }\n          ./modules/nginx.nix\n      ];\n\n# k\u0131salt\u0131ld\u0131\n</code></pre> <p>Daha sonra modules klas\u00f6r\u00fcm\u00fcze <code>nginx.nix</code> ad\u0131nda bir dosya ekleyelim alttaki kodlar\u0131 kopyalayal\u0131m.</p> <pre><code># modules/nginx.nix\n{ config, pkgs,lib, ...}:\n\nlet\n\n  # writeTextDir fonksiyonu ile nix/store dizinine html/site1/index.html ad\u0131nda\n  # bir klas\u00f6r a\u00e7\u0131p i\u00e7inde index.html ad\u0131nda bir doya olu\u015fturuyoruz.\n  # aynen yazd\u0131\u011f\u0131m gibi yanl\u0131\u015fl\u0131k yok. index.html ad\u0131nda  bir klas\u00f6r\u00fcn alt\u0131na index.html ad\u0131nda doys olul\u015fturuyor.\n  site1Root = pkgs.writeTextDir \"html/site1/index.html\" ''\n      &lt;!DOCTYPE html&gt;\n      &lt;html lang=\"en\"&gt;\n      &lt;head&gt;\n          &lt;meta charset=\"UTF-8\"&gt;\n          &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n          &lt;title&gt;Document&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n          Hello from Site 1\n      &lt;/body&gt;\n      &lt;/html&gt;'';\n\n\n  # writeTextDir fonksiyonu ile nix/store dizinine html/site2/index.html ad\u0131nda\n  # bir klas\u00f6r a\u00e7\u0131p i\u00e7inde index.html ad\u0131nda bir doya olu\u015fturuyoruz.\n  # aynen yazd\u0131\u011f\u0131m gibi yanl\u0131\u015fl\u0131k yok. index.html ad\u0131nda  bir klas\u00f6r\u00fcn alt\u0131na index.html ad\u0131nda doys olul\u015fturuyor.\n  site2Root = pkgs.writeTextDir \"html/site2/index.html\" ''\n      &lt;!DOCTYPE html&gt;\n      &lt;html lang=\"en\"&gt;\n      &lt;head&gt;\n          &lt;meta charset=\"UTF-8\"&gt;\n          &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n          &lt;title&gt;Document&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n          Hello from Site 2\n      &lt;/body&gt;\n      &lt;/html&gt;'';\n\nin\n\n{   # domain olarak site1 ve site2 yi ekliyoruz hosts dosyam\u0131za\n    # https://nixos.wiki/wiki/Networking\n    networking.extraHosts = ''\n                              127.0.0.1 site1\n                              127.0.0.1 site2\n                            '';\n    # nginx i enable ediyoruz ve statik sayfalar\u0131m\u0131z\u0131n dizinlerini gosteriyoruz.\n    services.nginx = {\n                    enable = true;\n\n                    recommendedGzipSettings = true;\n\n                    virtualHosts.\"site1\" = {\n                                              locations.\"/\" = {root = site1Root + \"/html/site1\";};\n                                           };\n\n                    virtualHosts.\"site2\" = {\n                                              locations.\"/\" = {root = site2Root + \"/html/site2\";};\n                                            };\n                   };\n}\n</code></pre> <p>Tabiiki burada amac\u0131m\u0131z Nis Store'a nas\u0131l dosya kaydedilir omu da g\u00f6rmek. Yoksa en do\u011frusu bu tarz bir i\u015f i\u00e7in <code>/var/www</code> dizinini kullanmak daha do\u011fru olacakt\u0131r.</p> <p>Build al\u0131p taray\u0131c\u0131dan test etti\u011fimizde alttaki gibi ekledi\u011fimiz <code>index.html</code> sayfas\u0131n\u0131n i\u00e7er\u011fini g\u00f6rebiliriz.</p> <p></p> <p>\u015e\u0130mdi mevzuyu biraz daha karma\u015f\u0131kla\u015ft\u0131ral\u0131m. Sisteme bir de vertaban\u0131 ekleyelim. Ancak bu veritaban\u0131 Nginx \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda \u00e7al\u0131\u015fs\u0131n \u00e7al\u0131\u015fm\u0131yorsa hi\u00e7 ba\u015flamas\u0131n. Ayr\u0131ca kullan\u0131c\u0131 ad\u0131, \u015fifre ve veritaban\u0131 ad\u0131n\u0131 option'lardan als\u0131n.</p> <p>Bunun i\u00e7in modules klas\u00f6r\u00fcne <code>postgres.nix</code> ad\u0131nda bir dosya olu\u015ftural\u0131m ve alttaki kodlar\u0131 ekleyelim.</p> <p>\u015e\u00f6yle bir soru akl\u0131m\u0131za gelebilir. Neden burada option kulland\u0131k ki, zaten do\u011frudan postgres konfig\u00fcrasyonuna kullan\u0131c\u0131 ad\u0131 ve \u015fifreyi yazabilirdik. Bir \u00f6zelli\u011fi option haline gatirdi\u011finizde ba\u015fka mod\u00fcllerde de bu ayar\u0131 de\u011fi\u015ftirme \u015fans\u0131m\u0131z oluyor. Yazaca\u011f\u0131n\u0131z bir ba\u015fka mod\u00fclde de tan\u0131mlad\u0131\u011f\u0131m\u0131z kullan\u0131c\u0131 ad\u0131 ve \u015fifre optionlar\u0131n\u0131 kullnabiliriz. Bu sayede zaten Nginx'e ait bir \u00f6zelli\u011fi Postgres mod\u00fcl\u00fc i\u00e7inde kullanabiliyoruz. Kodda da g\u00f6rece\u011finiz gibi Nginx'in enbale olup olmad\u0131\u011f\u0131n\u0131 kontrol edip ona gmre postgre'i kuruyoruz.</p> <pre><code># postgres.nix\n# https://nixos.wiki/wiki/PostgreSQL\n{ lib, config, pkgs, ...}:\n{\n\n  options = {\n      postgres.database_name = lib.mkOption {\n        type = lib.types.str;\n        description = \"database name\";\n        default = null;\n      };\n\n\n      postgres.username = lib.mkOption {\n        type = lib.types.str;\n        description = \"db username\";\n        default = null;\n      };\n\n      postgres.password = lib.mkOption {\n        type = lib.types.str;\n        description = \"db password\";\n        default = null;\n      };\n\n    };\n\nconfig = lib.mkMerge [ {\n                          postgres.username = \"admin\";\n                          postgres.password = \"Abc123\";\n                          postgres.database_name = \"mydatabase\";\n                        }\n\n                        # e\u011fer nginx enable ise postgres de \u00e7al\u0131\u015fs\u0131n\n                        (lib.mkIf config.services.nginx.enable {\n\n                                services.postgresql = {\n                                    enable = true;\n                                    ensureDatabases = [ config.postgres.database_name ];\n                                    enableTCPIP = true;\n\n                                    port = 5432;\n\n                                      initialScript = pkgs.writeText \"backend-initScript\" ''\n                                            CREATE ROLE ${config.postgres.username} WITH LOGIN PASSWORD '${config.postgres.password}' CREATEDB;\n                                            CREATE DATABASE ${config.postgres.database_name};\n                                            GRANT ALL PRIVILEGES ON DATABASE ${config.postgres.database_name} TO ${config.postgres.username};\n                                            '';\n                                      };}\n                        )\n\n                    ];\n\n}\n</code></pre> <p><code>Flake.nix</code> dosyasm\u0131za da alttaki gibi yazd\u0131\u011f\u0131m\u0131z <code>postgres.nix</code> mod\u00fcl\u00fcn\u00fc ekleyelim.</p> <pre><code># flake.nix\n\n modules = [\n          ./modules/nixos-configuration.nix\n          home-manager.nixosModules.home-manager\n            {\n              home-manager.useGlobalPkgs = true;\n              home-manager.useUserPackages = true;\n              home-manager.users.muratcabuk = import ./modules/murat-home-manager.nix;\n              # Bu da home-manager i\u00e7in\n              home-manager.extraSpecialArgs = {inherit pkgs-unstable; };\n            }\n\n          ./modules/nginx.nix\n          ./modules/postgres.nix\n      ];\n</code></pre> <p>Kurulumu yap\u0131p test edelim.</p> <pre><code>sudo nixos-rebuild switch --flake .#muratpc --impure --show-trace --upgrade\n\nsystemctl status postgresql\n\n# sonu\u00e7ta \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 g\u00f6rebiliriz.\n</code></pre> <p>Nginx'i enable \u00f6zelli\u011fini false yap\u0131p sistememizi \u00fcstteki komutla tekrar g\u00fcncelleyip postgres servisinin \u00e7al\u0131p \u00e7al\u0131\u015fmad\u0131\u011f\u0131n\u0131 kontrol etti\u011fimizde \u00e7al\u0131\u015fmad\u0131\u011f\u0131n\u0131 da g\u00f6rebiliriz.</p> <p>Bu \u015fekilde kurmu\u015f oldu\u011fumuz bir servisi bildi\u011finiz systemctl komutlar\u0131 ile ba\u015flat\u0131p durdurabiliriz. Ancak servisi <code>systemctl disable postgresql</code> komutu ile disable etmeye \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131zda <code>Read-only file system</code> hatas\u0131 al\u0131r\u0131z. \u0130\u015fte tam buras\u0131 NixOS i\u00e7in \u00e7ok \u00f6nemli. NixOS'un kullan\u0131\u011f\u0131 bir sisteme yazme yapaca\u011f\u0131n\u0131z zaman bunu kesinlikle NixOS komutlar\u0131 ile yapmal\u0131s\u0131n\u0131z. \u00d6rne\u011fin bir servisi disable etti\u011fimizde en basiyle <code>/etc/systemd/system/</code> dizininden sembolik link silinir ki bu da sisteme yazmak anlam\u0131na gelir. Bu durumda her defas\u0131nda bir servisi disable/enable etmek i\u00e7in konfig\u00fcrasyon dosyam\u0131z\u0131 de\u011fitirmemiz gerekecek \u015fuana kadar \u00f6\u011frendiklerimize g\u00f6re.</p> <p>G\u00fcnl\u00fck kullan\u0131mda illaki bu tarz i\u015flemlere ihtiyac\u0131m\u0131z olacak ancak bunun \u00e7\u00f6z\u00fcm\u00fc de konfig\u00fcrasyon dosyalar\u0131n\u0131 editlemek olmamal\u0131. \u00c7\u00fcnk\u00fc bu dosyalar sistemin state'ini de tutuyor. Yani bir dahaki sefere bir sistemi aya\u011fa kald\u0131rak sitedi\u011fimizde z\u0131rt p\u0131rt de\u011fi\u015fen bir dosyan\u0131n \u00fczerinden kurulum yapmak istemeyiz. Bu tarz durumlarda kullanmak i\u00e7in \u00f6nceleri ad\u0131 nesting olan ama sonralar\u0131 ad\u0131 specialisation olarak de\u011fi\u015ftirilen bir kullan\u0131m var. Amac\u0131m\u0131z konfig\u00fcrasyon dosyalar\u0131ndaki b\u00fct\u00fcn aylar\u0131 ayn\u0131 tutup sdece de\u011fi\u015fen ayarlar\u0131 bir yerde toplamak. Bu sadece bu farkl\u0131l\u0131klar \u00fczerinden sitemi update edebilce\u011fiz. Tabi bunu ayn\u0131 zamanda iki farl\u0131 kullan\u0131c\u0131 i\u00e7in bir \u00e7ok ayar tamemen ayn\u0131ysa di\u011ferinden farkl\u0131 olan ayarlar\u0131 bir yerde toplamak i\u00e7in de kullanabiliriz. Nesne Y\u00f6netlimli Programlamadaki inheritance (miras almaya) benzetebiliriz.</p> <p>Biz de \u00f6rne\u011fimizde Nginx servisini istedi\u011fimiz zaman disable etmeyi deneyelim. Tabibiz bun yaptu\u011f\u0131m\u0131zda konfig\u00fcrasyomnumuzdan dolay\u0131 Postgres'in de disable olmas\u0131 gerekeiyor. Tabi normal da\u011f\u0131t\u0131mlardaki servisi disable etmek gibi de\u011fil. NixOS da bir uyugulamy\u0131 disable etmek demek tamamen sistemden kald\u0131rmak anlam\u0131na geliyor.</p> <p>Modules klas\u00f6r\u00fcne <code>nigix-disabled.nix</code> ad\u0131ndan bir dosya olu\u015ftural\u0131m ve i\u00e7ine alattaki kodlar\u0131 kopyalayal\u0131m. Alttaki kodda en \u00f6nceli b\u00f6l\u00fcm configuration blo\u011fu. Sistemde tan\u0131ml\u0131 b\u00fct\u00fcn aylar\u0131 de\u011fi\u015ftrebiliriz veya yenileri ekelyebliriz.</p> <pre><code># nginx-disabled.nix\n{ config, pkgs,lib, ...}:\n {\n    specialisation = {\n           nginx-disabled = {\n                inheritParentConfig = true;\n                configuration = {\n\n                         system.nixos.tags = [ \"nginx-disabled\" ];\n                         services.nginx.enable = lib.mkForce false;\n                                 };\n                            };\n                      };\n }\n                            };\n</code></pre> <p>Sonu\u00e7ta bu dosaya da bir mod\u00fcl. Bu mod\u00fcl\u00fc de <code>flake.nix</code> dosyamzdaki mod\u00fcllerin aras\u0131na import ediyoruz. Biz \u015fu ana kadar b\u00fct\u00fcn mod\u00fclleri <code>flake.nix</code> dosyuas\u0131na ekledik. Asl\u0131nda istesek <code>nixos-congfiguration.nix</code> dosyas\u0131ndaki imports listesine veya tamamane ba\u015fka bir module dosyas\u0131 ekleyip ona import edip daha sonra onu <code>flake.nix</code> dosyas\u0131ndaki modules listesine ekleyebilirdik. Bu tamamen bize kalm\u0131\u015f bir durum. Ancak \u015fu\u0131nu s\u00f6yleyebilirim, e\u011fer bir klas\u00f6rde \u00e7ok fazla dosya birikirse bunlar\u0131 <code>default.nix</code> dsoyas\u0131na import edip o dosyas\u0131 flake'e eklemek genel bir kullan\u0131m haline gelmi\u015f.</p> <pre><code># flake.nix\n\n# K\u0131salt\u0131ld\u0131\n\n      modules = [\n          ./modules/nixos-configuration.nix\n          home-manager.nixosModules.home-manager\n            {\n              home-manager.useGlobalPkgs = true;\n              home-manager.useUserPackages = true;\n              home-manager.users.muratcabuk = import ./modules/murat-home-manager.nix;\n              # Bu da home-manager i\u00e7in\n              home-manager.extraSpecialArgs = {inherit pkgs-unstable; };\n            }\n\n          ./modules/nginx.nix\n          ./modules/postgres.nix\n          ./modules/nginx-disabled.nix\n      ];\n\n# K\u0131salt\u0131ld\u0131\n</code></pre> <p>Tabi burada ciddi bir de\u011fi\u015fiklik yap\u0131yoruz. \u00c7al\u0131\u015fma an\u0131nda postgres'i dsiable edip tekrar enable ediyoruz. Ancak \u00e7ok daha basit i\u015fler i\u00e7in de specialisation'lar\u0131 kullanabiliriz. Olu\u015ftrdu\u011fumuz nginx-disabled ad\u0131ndaki specialisation'i \u00e7al\u0131\u015ft\u0131mak i\u00e7in alttaki komutu \u00e7al\u0131\u015ft\u0131r\u0131yoruz. komutun sonuna ekled\u011fimiz <code>--specialisation nginx-disabled</code> k\u0131sm\u0131na dikkate edin.</p> <pre><code>sudo nixos-rebuild switch --flake .#muratpc --impure --show-trace --upgrade --specialisation nginx-disabled\n</code></pre> <p>Bunu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda Nginx servisi disable olacak, Postgres ise Nginx disaple oldu\u011funu i\u00e7in disable olacak.</p> <pre><code>systemctl status nginx\n# Unit nginx.service could not be found.\n\nsystemctl status postgres\n# Unit postgres.service could not be found.\n</code></pre> <p>Kodun bitmi\u015f halini Github sayfamda nixos-sample-dotfiles reposundaki nginx-postgres branch'inde bulabilirsiniz.</p> <p>\u015eimdilik bu kadar. Bir sonraki yaz\u0131m\u0131zda da elimizde ki config\u00fcrasyon dosyas\u0131 ile,</p> <ul> <li>uzak bir makineye kurmay\u0131,</li> <li>Docker Container olu\u015fturmay\u0131,</li> <li>ISO olu\u015fturmay\u0131   g\u00f6rece\u011fiz.</li> </ul> <p>\u0130lk yaz\u0131m\u0131zda bahsetti\u011fimiz gibi NixOS bunlardan ibaret de\u011fil. Ben ancak bu kadar\u0131na girebilce\u011fim ama t\u00fcm kaynklar\u0131 da yaz\u0131da verece\u011fim.</p> <p>Bu yaz\u0131y\u0131 ilgilendiren di\u011fer bir konu da hardware managment k\u0131sm\u0131 ancak ona da o kadar hakim de\u011filim. Tamamen ihtiyac\u0131n\u0131za g\u00f6re adok\u00fcmnlardan ara\u015ft\u0131rma yap\u0131p halletmemniz gerekiyor. \u0130lk kurulumda sistem asl\u0131nda bir \u00e7ok \u015feyi hallediyor. Ancak hi\u00e7 birmedi\u011finiz bir makineye do\u011frudan konfig\u00fcrasyon \u00fcerinden b\u00fct\u00fcn dona\u0131m ayarlar\u0131 kurulu yapmaya \u00e7al\u0131\u015fmak tabii ki biraz zorlay\u0131c\u0131 bir s\u00fcre\u00e7. Tabi \u00f6yle bir \u015feye ne kadar ihtiyac\u0131n\u0131z olur a\u0131nu bilemem ancak \u00e7ok myo\u011fun sistem m\u00fchendisli\u011fi i\u015fi yap\u0131yoran\u0131z belki ihyisa\u00e7 duyabilrisiniz. Ben de ihtiya\u00e7 duymad\u0131\u011f\u0131m i\u00e7in o k\u0131s\u0131mlar\u0131 sadece ihtiya\u00e7 duyfupumda bakaca\u011f\u0131m \u015fekilde b\u0131rakt\u0131m.</p> <p>Bu yazn\u0131n konusu oldupu i\u00e7in sadece Disco arac\u0131ndan \u00e7ok k\u0131sa bahsetmek istiyorum. Bu ara\u00e7 ile durulu esnas\u0131nda gerekli olan disk b\u00f6l\u00fcmlendirme ve y\u00f6netim i\u015flemlerini de declarative olarak y\u00f6netbiliyorsunuz. Bu paketi de community geli\u015ftiriyor ve tamamen a\u00e7\u0131k kaynak. Altta sadece firkir vermesi i\u00e7in NixOS wiki sayfas\u0131ndaki \u00f6rne\u011fi payla\u015f\u0131yorum.</p> <pre><code># disko-config.nix\n\n{ disks ? [ \"/dev/vda\" ], ... }: {\n  disko.devices = {\n    disk = {\n      vdb = {\n        device = builtins.elemAt disks 0;\n        type = \"disk\";\n        content = {\n          type = \"table\";\n          format = \"gpt\";\n          partitions = [\n            {\n              name = \"ESP\";\n              start = \"1MiB\";\n              end = \"500MiB\";\n              bootable = true;\n              content = {\n                type = \"filesystem\";\n                format = \"vfat\";\n                mountpoint = \"/boot\";\n              };\n            }\n            {\n              name = \"root\";\n              start = \"500MiB\";\n              end = \"100%\";\n              part-type = \"primary\";\n              content = {\n                type = \"filesystem\";\n                format = \"bcachefs\";\n                mountpoint = \"/\";\n              };\n            }\n          ];\n        };\n      };\n    };\n  };\n}\n</code></pre> <p><code>Flake.nix</code> dosyam\u0131z\u0131 da alttaki gibi yaz\u0131yoruz. G\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere bu da bir module. Formatlancak disk ile ilgili bilgiyi parametre olarak mod\u00fcle ge\u00e7iyoruz.</p> <pre><code># flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.05\";\n    disko.url = \"github:nix-community/disko\";\n    disko.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = {self, nixpkgs, disko, ...}@inputs: {\n\n    nixosConfigurations.mysystem = inputs.nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      specialArgs.inputs = inputs;\n      modules = [\n        disko.nixosModules.disko\n        ./disko-config.nix\n        {\n          _module.args.disks = [ \"/dev/vda\" ];\n        }\n        ./configuration.nix\n      ];\n    };\n  };\n}\n</code></pre> <p>Github sayfas\u0131nda ihtiyac\u0131n\u0131z olacak hemen hemen b\u00fct\u00fcn durumlar i\u00e7in \u00f6rnekler mevcut. \u015eu linkte \u00f6rnekleri bulabilirsiniz.</p>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#nixos-icin-diger-paket-yoneticileri","title":"NixOS \u0130\u00e7in Di\u011fer Paket Y\u00f6neticileri","text":"<p>NixOS'da di\u011fer cross platform paket y\u00f6neticilerini de kullnabilirsiniz. Alttaki kurumlar\u0131n\u0131 da i\u00e7eren linkleri payla\u015f\u0131yorum.</p> <ul> <li>Flatpak Sayfas\u0131, NixOS Sayfas\u0131</li> <li>AppImage</li> <li>Community, Github Tart\u0131\u015fma Sayfas\u0131, Flake ile Snapd Kurmak</li> </ul>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#araclar-ve-sayfalar","title":"Ara\u00e7lar ve Sayfalar","text":"<p>\u0130\u015finize yarayabilcek baz\u0131 linkler payla\u015f\u0131yorum.</p> <ul> <li>Stylix is a NixOS module which applies the same colour scheme, font and wallpaper to a range of applications and desktop environments.</li> <li>Gaming related stuff for Nix and NixOS.</li> <li>Visual Studio Code Server support in NixOS</li> <li>A curated list of the best resources in the Nix community.</li> <li>https://nixos.wiki/wiki/Comparison_of_NixOS_setups</li> <li>https://nixos.wiki/wiki/Configuration_Collection</li> <li>https://aldoborrero.com/posts/2023/01/15/setting-up-my-machines-nix-style/</li> <li>Painless dependencies for Nix projects.</li> <li>Declarative disk partitioning</li> <li>https://www.tweag.io/blog/2022-08-18-nixos-specialisations/</li> <li>https://nixos.wiki/wiki/Specialisation</li> </ul>"},{"location":"nixos_kurulumu_ve_konfigurasyonu.html#incelemlemek-ve-ornek-almak-icin-nixos-dotfiles-github-repolar","title":"\u0130ncelemlemek ve \u00d6rnek Almak i\u00e7in NixOS Dotfiles GitHub Repo'lar\u0131","text":"<ul> <li>https://github.com/mitchellh/nixos-config</li> <li>https://github.com/hlissner/dot./assets/files\\tree/master</li> <li>https://github.com/dustinlyons/nixos-config</li> <li>https://github.com/gvolpe/nix-config</li> <li>https://github.com/Misterio77/nix-config/tree/main</li> <li>https://github.com/fufexan/dotfiles</li> <li>https://github.com/Mic92/dotfiles</li> <li>https://github.com/fufexan/nix-gaming</li> <li>https://github.com/sioodmy/dotfiles</li> <li>https://github.com/notusknot/dotfiles-nix</li> <li>https://github.com/srid/nixos-config</li> <li>https://github.com/NobbZ/nixos-config</li> <li>https://github.com/gytis-ivaskevicius/nix./assets/files\\tree/master</li> <li>https://github.com/bobbbay/dot./assets/files\\tree/master</li> <li>https://github.com/chvp/nixos-config/tree/main</li> <li>https://github.com/shiryel/fennecOS</li> <li>https://github.com/phenax/nixos-dotfiles</li> <li>https://github.com/tolgaerok/nixos-kde</li> <li>https://github.com/mcdonc/.nixconfig</li> <li>https://github.com/hervyqa/dotfire</li> <li>https://codeberg.org/merulox/dot./assets/files\\src/branch/master/nixos/configuration.nix</li> </ul>"},{"location":"assets/flakes/mcabuk/OrnekConfDetaylari.html","title":"OrnekConfDetaylari","text":""},{"location":"assets/flakes/mcabuk/OrnekConfDetaylari.html#nixos-configuration","title":"nixos configuration","text":"<p>https://nixos.wiki/wiki/Overview_of_the_NixOS_Linux_distribution#Declarative_Configuration</p>"},{"location":"assets/flakes/mcabuk/OrnekConfDetaylari.html#nixos-uzerinde-kullanm","title":"NixOS \u00fczerinde kullan\u0131m","text":"<p>\u00f6ncelikle unstable paket yoneticisi aktive edilir.</p> <pre><code>nix registry add pkgs github:nixos/nixpkgs/nixos-unstable\n</code></pre> <p>daha sonra bir klas\u00f6rde alttaki komut ile flake projesi olu\u015fturulur</p> <pre><code>mkdir muratpc-test\n\nnix flake new --template templates#full ./muratpc-test\n</code></pre> <p>klas\u00f6re gidip bakt\u0131\u011f\u0131m\u0131zda flake.nix ve flake.lock dosyalar\u0131 olu\u015fmu\u015f olmal\u0131d\u0131r.</p> <p>flake.nix dosyas\u0131nda bakt\u0131\u011f\u0131m\u0131zda alttaki gibi uzun bir doya ile kar\u015f\u0131la\u015f\u0131yor olaca\u011f\u0131z.</p> <pre><code>{\n  description = \"A template that shows all standard flake outputs\";\n\n  # Inputs\n  # https://nixos.org/manual/nix/unstable/command-ref/new-cli/nix3-flake.html#flake-inputs\n\n  # The flake in the current directory.\n  # inputs.currentDir.url = \".\";\n\n  # A flake in some other directory.\n  # inputs.otherDir.url = \"/home/alice/src/patchelf\";\n\n  # A flake in some absolute path\n  # inputs.otherDir.url = \"path:/home/alice/src/patchelf\";\n\n  # The nixpkgs entry in the flake registry.\n  inputs.nixpkgsRegistry.url = \"nixpkgs\";\n\n  # The nixpkgs entry in the flake registry, overriding it to use a specific Git revision.\n  inputs.nixpkgsRegistryOverride.url = \"nixpkgs/a3a3dda3bacf61e8a39258a0ed9c924eeca8e293\";\n\n  # The master branch of the NixOS/nixpkgs repository on GitHub.\n  inputs.nixpkgsGitHub.url = \"github:NixOS/nixpkgs\";\n\n  # The nixos-20.09 branch of the NixOS/nixpkgs repository on GitHub.\n  inputs.nixpkgsGitHubBranch.url = \"github:NixOS/nixpkgs/nixos-20.09\";\n\n  # A specific revision of the NixOS/nixpkgs repository on GitHub.\n  inputs.nixpkgsGitHubRevision.url = \"github:NixOS/nixpkgs/a3a3dda3bacf61e8a39258a0ed9c924eeca8e293\";\n\n  # A flake in a subdirectory of a GitHub repository.\n  inputs.nixpkgsGitHubDir.url = \"github:edolstra/nix-warez?dir=blender\";\n\n  # A git repository.\n  inputs.gitRepo.url = \"git+https://github.com/NixOS/patchelf\";\n\n  # A specific branch of a Git repository.\n  inputs.gitRepoBranch.url = \"git+https://github.com/NixOS/patchelf?ref=master\";\n\n  # A specific revision of a Git repository.\n  inputs.gitRepoRev.url = \"git+https://github.com/NixOS/patchelf?ref=master&amp;rev=f34751b88bd07d7f44f5cd3200fb4122bf916c7e\";\n\n  # A tarball flake\n  inputs.tarFlake.url = \"https://github.com/NixOS/patchelf/archive/master.tar.gz\";\n\n  # A GitHub repository.\n  inputs.import-cargo = {\n    type = \"github\";\n    owner = \"edolstra\";\n    repo = \"import-cargo\";\n  };\n\n  # Inputs as attrsets.\n  # An indirection through the flake registry.\n  inputs.nixpkgsIndirect = {\n    type = \"indirect\";\n    id = \"nixpkgs\";\n  };\n\n  # Non-flake inputs. These provde a variable of type path.\n  inputs.grcov = {\n    type = \"github\";\n    owner = \"mozilla\";\n    repo = \"grcov\";\n    flake = false;\n  };\n\n  # Transitive inputs can be overridden from a flake.nix file. For example, the following overrides the nixpkgs input of the nixops input:\n  inputs.nixops.inputs.nixpkgs = {\n    type = \"github\";\n    owner = \"NixOS\";\n    repo = \"nixpkgs\";\n  };\n\n  # It is also possible to \"inherit\" an input from another input. This is useful to minimize\n  # flake dependencies. For example, the following sets the nixpkgs input of the top-level flake\n  # to be equal to the nixpkgs input of the nixops input of the top-level flake:\n  inputs.nixpkgs.url = \"nixpkgs\";\n  inputs.nixpkgs.follows = \"nixops/nixpkgs\";\n\n  # The value of the follows attribute is a sequence of input names denoting the path\n  # of inputs to be followed from the root flake. Overrides and follows can be combined, e.g.\n  inputs.nixops.url = \"nixops\";\n  inputs.dwarffs.url = \"dwarffs\";\n  inputs.dwarffs.inputs.nixpkgs.follows = \"nixpkgs\";\n\n  # For more information about well-known outputs checked by `nix flake check`:\n  # https://nixos.org/manual/nix/unstable/command-ref/new-cli/nix3-flake-check.html#evaluation-checks\n\n  # These examples all use \"x86_64-linux\" as the system.\n  # Please see the c-hello template for an example of how to handle multiple systems.\n\n  inputs.c-hello.url = \"github:NixOS/templates?dir=c-hello\";\n  inputs.rust-web-server.url = \"github:NixOS/templates?dir=rust-web-server\";\n  inputs.nix-bundle.url = \"github:NixOS/bundlers\";\n\n  # Work-in-progress: refer to parent/sibling flakes in the same repository\n  # inputs.c-hello.url = \"path:../c-hello\";\n\n  outputs = all@{ self, c-hello, rust-web-server, nixpkgs, nix-bundle, ... }: {\n\n    # Utilized by `nix flake check`\n    checks.x86_64-linux.test = c-hello.checks.x86_64-linux.test;\n\n    # Utilized by `nix build .`\n    defaultPackage.x86_64-linux = c-hello.defaultPackage.x86_64-linux;\n\n    # Utilized by `nix build`\n    packages.x86_64-linux.hello = c-hello.packages.x86_64-linux.hello;\n\n    # Utilized by `nix run .#&lt;name&gt;`\n    apps.x86_64-linux.hello = {\n      type = \"app\";\n      program = c-hello.packages.x86_64-linux.hello;\n    };\n\n    # Utilized by `nix bundle -- .#&lt;name&gt;` (should be a .drv input, not program path?)\n    bundlers.x86_64-linux.example = nix-bundle.bundlers.x86_64-linux.toArx;\n\n    # Utilized by `nix bundle -- .#&lt;name&gt;`\n    defaultBundler.x86_64-linux = self.bundlers.x86_64-linux.example;\n\n    # Utilized by `nix run . -- &lt;args?&gt;`\n    defaultApp.x86_64-linux = self.apps.x86_64-linux.hello;\n\n    # Utilized for nixpkgs packages, also utilized by `nix build .#&lt;name&gt;`\n    legacyPackages.x86_64-linux.hello = c-hello.defaultPackage.x86_64-linux;\n\n    # Default overlay, for use in dependent flakes\n    overlay = final: prev: { };\n\n    # # Same idea as overlay but a list or attrset of them.\n    overlays = { exampleOverlay = self.overlay; };\n\n    # Default module, for use in dependent flakes. Deprecated, use nixosModules.default instead.\n    nixosModule = { config, ... }: { options = {}; config = {}; };\n\n    # Same idea as nixosModule but a list or attrset of them.\n    nixosModules = { exampleModule = self.nixosModule; };\n\n    # Used with `nixos-rebuild --flake .#&lt;hostname&gt;`\n    # nixosConfigurations.\"&lt;hostname&gt;\".config.system.build.toplevel must be a derivation\n    nixosConfigurations.example = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [{boot.isContainer=true;}] ;\n    };\n\n    # Utilized by `nix develop`\n    devShell.x86_64-linux = rust-web-server.devShell.x86_64-linux;\n\n    # Utilized by `nix develop .#&lt;name&gt;`\n    devShells.x86_64-linux.example = self.devShell.x86_64-linux;\n\n    # Utilized by Hydra build jobs\n    hydraJobs.example.x86_64-linux = self.defaultPackage.x86_64-linux;\n\n    # Utilized by `nix flake init -t &lt;flake&gt;`\n    defaultTemplate = {\n      path = c-hello;\n      description = \"template description\";\n    };\n\n    # Utilized by `nix flake init -t &lt;flake&gt;#&lt;name&gt;`\n    templates.example = self.defaultTemplate;\n  };\n}\n</code></pre> <p>burada inpup olarak adland\u0131r\u0131lanlar c# daki using bloklar\u0131 gibidir. yani kullan\u0131lacak paketleri belirliyor. </p> <p>output ise bu paketleri kullanarak sistemi olu\u015fturan kod bloklar\u0131n\u0131 g\u00f6steriyor.</p> <p>Bu \u00f6rnekte full template oldu\u011fu i\u00e7in neredeyse t\u00fcm flake outputlar\u0131n\u0131 g\u00f6steriyor.</p> <p>sade bir \u00f6rne\u011fe bakal\u0131m</p> <pre><code>{\n  description = \"Ryan'\u0131n NixOS Flake'i\";\n\n  # Bu, flake.nix i\u00e7in standart bi\u00e7imidir.\n  # `inputs`, flake'in ba\u011f\u0131ml\u0131l\u0131klar\u0131d\u0131r,\n  # ve `outputs` i\u015flevi, flake'in t\u00fcm derleme sonu\u00e7lar\u0131n\u0131 d\u00f6nd\u00fcrecektir.\n  # `inputs` i\u00e7indeki her \u00f6\u011fe, \u00e7ekildikten ve derlendikten sonra\n  # `outputs` i\u015flevine bir parametre olarak iletilir.\n  inputs = {\n    # Flake giri\u015flerini ba\u015fvurman\u0131n bir\u00e7ok yolu vard\u0131r.\n    # En yayg\u0131n olarak kullan\u0131lan\u0131 `github:owner/name/reference`'dir,\n    # Bu, GitHub deposu URL + branch/commit-id/tag temsil eder.\n\n    # Resmi NixOS paket kayna\u011f\u0131, burada nixos-unstable branch ini kullan\u0131yor\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    # Kullan\u0131c\u0131 yap\u0131land\u0131rmas\u0131n\u0131 y\u00f6netmek i\u00e7in kullan\u0131lan home-manager\n    home-manager = {\n      url = \"github:nix-community/home-manager/release-23.05\";\n      # `inputs` i\u00e7indeki `home-manager`'\u0131n `inputs.nixpkgs`'nin\n      # g\u00fcncel flake'in `inputs.nixpkgs` ile tutarl\u0131 kalmas\u0131n\u0131 sa\u011flamak i\u00e7in kullan\u0131lan `follows` anahtar kelimesi.\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  # `outputs`, flake'in t\u00fcm derleme sonu\u00e7lar\u0131d\u0131r.\n  #\n  # Bir flake'in bir\u00e7ok kullan\u0131m ve farkl\u0131 t\u00fcrde \u00e7\u0131kt\u0131lar\u0131 olabilir.\n  # \n  # `outputs` i\u015flevindeki parametreler, `inputs` i\u00e7inde tan\u0131mlan\u0131r ve\n  # adlar\u0131yla ba\u015fvurulabilir. Ancak `self` bir istisnad\u0131r,\n  # bu \u00f6zel parametre, `outputs`'un kendisine i\u015faret eder (self-referans).\n  # \n  # Buradaki `@` s\u00f6zdizimi, giri\u015f parametresinin \u00f6znitelik k\u00fcmesini takma adland\u0131rmak i\u00e7in kullan\u0131l\u0131r,\n  # i\u015flev i\u00e7inde kullanmak daha uygun hale gelir.\n  outputs = { self, nixpkgs, ... }@inputs: {\n    nixosConfigurations = {\n      # Varsay\u0131lan olarak, NixOS, nixosConfiguration'\u0131 ana makine ad\u0131yla bulmaya \u00e7al\u0131\u015facakt\u0131r,\n      # bu nedenle 'nixos-test' adl\u0131 sistem bu yap\u0131land\u0131rmay\u0131 kullanacakt\u0131r.\n      # Ancak, yap\u0131land\u0131rma ad\u0131 a\u015fa\u011f\u0131daki gibi belirtilebilir:\n      #   sudo nixos-rebuild switch --flake /path/to/flakes/directory#&lt;name&gt;\n      #\n      # Bu yap\u0131land\u0131rmay\u0131 herhangi bir NixOS sisteminde da\u011f\u0131tmak i\u00e7in flake'in dizininde\n      # a\u015fa\u011f\u0131daki komutu \u00e7al\u0131\u015ft\u0131r\u0131n:\n      #   sudo nixos-rebuild switch --flake .#nixos-test\n      \"nixos-test\" = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n\n        # Nix mod\u00fcl sistemi, yap\u0131land\u0131rman\u0131n bak\u0131m\u0131n\u0131 iyile\u015ftiren\n        # bir \u015fekilde yap\u0131land\u0131rmay\u0131 mod\u00fcler hale getirebilir.\n        #\n        # `modules` i\u00e7indeki her parametre, bir Nix Mod\u00fcl\u00fcd\u00fcr ve\n        # nixpkgs el kitab\u0131nda k\u0131smi bir tan\u0131t\u0131m\u0131 vard\u0131r:\n        #    &lt;https://nixos.org/manual/nixpkgs/unstable/#module-system-introduction&gt;\n        # Bu k\u0131smi oldu\u011fu s\u00f6ylenir \u00e7\u00fcnk\u00fc belge tamamlanmam\u0131\u015ft\u0131r,\n        # yaln\u0131zca baz\u0131 basit tan\u0131t\u0131mlar bulunur.\n        # i\u015fte Nix belgesinin \u015fu anki durumu...\n        #\n        # Bir Nix Mod\u00fcl\u00fc bir \u00f6znitelik k\u00fcmesi veya bir \u00f6znitelik k\u00fcmesi d\u00f6nd\u00fcren bir i\u015flev olabilir.\n        # Varsay\u0131lan olarak, bir Nix Mod\u00fcl\u00fc i\u015flevse, bu i\u015flevin a\u015fa\u011f\u0131daki varsay\u0131lan parametreleri vard\u0131r:\n        #\n        #  lib:     nixpkgs i\u015flev kitapl\u0131\u011f\u0131, Nix ifadeleriyle i\u015flem yapmak i\u00e7in bir\u00e7ok\n        #             faydal\u0131 i\u015flev sa\u011flar:\n        #             https://nixos.org/manual/nixpkgs/stable/#id-1.4\n        #  config:  mevcut flake'in t\u00fcm yap\u0131land\u0131rma se\u00e7enekleri, her biri kullan\u0131\u015fl\u0131d\u0131r\n        #  options: mevcut flake i\u00e7indeki t\u00fcm NixOS Mod\u00fcllerinde tan\u0131mlanan t\u00fcm se\u00e7enekler\n        #  pkgs:   nixpkgs'de tan\u0131mlanan t\u00fcm paketlerin bir koleksiyonu,\n        #            paketleme ile ilgili bir dizi i\u015flevi i\u00e7erir.\n        #            \u015eu an i\u00e7in varsay\u0131lan de\u011feri\n        #            `nixpkgs.legacyPackages.\"${system}\"` olarak varsayabilirsiniz.\n        #            `nixpkgs.pkgs` se\u00e7ene\u011fi ile \u00f6zelle\u015ftirilebilir\n        #  modulesPath: nixpkgs'in mod\u00fcller klas\u00f6r\u00fcn\u00fcn varsay\u0131lan yolu,\n        #               nixpkgs'den ekstra mod\u00fclleri i\u00e7e aktarmak i\u00e7in kullan\u0131l\u0131r.\n        #               bu parametre nadiren kullan\u0131l\u0131r,\n        #               \u015fu an i\u00e7in bunu g\u00f6z ard\u0131 edebilirsiniz.\n        #\n        # Yukar\u0131da bahsedilen varsay\u0131lan parametreler Nixpkgs taraf\u0131ndan otomatik olarak olu\u015fturulur.\n        # Ancak, alt mod\u00fcllere di\u011fer varsay\u0131lan olmayan parametreleri iletmek isterseniz,\n        # bu parametreleri 'specialArgs' kullanarak manuel olarak yap\u0131land\u0131rman\u0131z gerekecektir.\n        # A\u015fa\u011f\u0131daki sat\u0131r\u0131 yorum sat\u0131r\u0131ndan \u00e7\u0131kartarak 'specialArgs' kullanman\u0131z gerekebilir:\n        #\n        # specialArgs = {...};  # T\u00fcm alt mod\u00fcllere \u00f6zel arg\u00fcmanlar\u0131 iletmek i\u00e7in\nmodules = [\n          # Import the configuration.nix here, so that the\n          # old configuration file can still take effect.\n          # Note: configuration.nix itself is also a Nix Module,\n          ./configuration.nix\n        ];\n      };\n    };\n  };\n}\n</code></pre> <p>\u015fimdi ger\u00e7ek sistemimiz i\u00e7in \u00e7al\u0131\u015fmalya ba\u015flayal\u0131m.</p> <p>bunun i\u00e7in \u00f6ncelikle mcabukpc ad\u0131nda bir klas\u00f6r olu\u015fturuz. ve i\u00e7ine flake.nix ad\u0131nda bir dosya olu\u015fturuy\u0131ruz.</p> <p><pre><code>mkdir mcabukpc\n\ntouch flake.nix\n</code></pre> i\u00e7ine alttaki bloklar\u0131 yaz\u0131yoruz</p> <pre><code>{\n  description = \"Murat Cabuk NixOS configuration\";\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixpkgs-unstable\";\n  };\n  outputs = { self, nixpkgs, ... }: {\n    nixosConfigurations = {\n      my-hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n        ];\n      };\n    };\n    defaultPackage = nixpkgs.legacyPackages.x86_64-linux.hello;\n  };\n}\n</code></pre> <p>ayn\u0131 dizine bir de configuration.nix dosyas\u0131 olu\u015fturuyoruz.</p> <pre><code># Edit this configuration file to define what should be installed on\n# your system.  Help is available in the configuration.nix(5) man page\n# and in the NixOS manual (accessible by running \u2018nixos-help\u2019).\n\n{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Include the results of the hardware scan.\n      ./hardware-configuration.nix\n    ];\n\n  # Bootloader.\n  boot.loader.grub.enable = true;\n  boot.loader.grub.device = \"/dev/vda\";\n  boot.loader.grub.useOSProber = true;\n\n  networking.hostName = \"muratpc\"; # Define your hostname.\n  # networking.wireless.enable = true;  # Enables wireless support via wpa_supplicant.\n\n  # Configure network proxy if necessary\n  # networking.proxy.default = \"http://user:password@proxy:port/\";\n  # networking.proxy.noProxy = \"127.0.0.1,localhost,internal.domain\";\n\n  # Enable networking\n  networking.networkmanager.enable = true;\n\n  nix.settings.experimental-features = [\"nix-command\" \"flakes\"];\n\n\n  # Set your time zone.\n  time.timeZone = \"Europe/Istanbul\";\n\n  # Select internationalisation properties.\n  i18n.defaultLocale = \"en_US.UTF-8\";\n\n  i18n.extraLocaleSettings = {\n    LC_ADDRESS = \"tr_TR.UTF-8\";\n    LC_IDENTIFICATION = \"tr_TR.UTF-8\";\n    LC_MEASUREMENT = \"tr_TR.UTF-8\";\n    LC_MONETARY = \"tr_TR.UTF-8\";\n    LC_NAME = \"tr_TR.UTF-8\";\n    LC_NUMERIC = \"tr_TR.UTF-8\";\n    LC_PAPER = \"tr_TR.UTF-8\";\n    LC_TELEPHONE = \"tr_TR.UTF-8\";\n    LC_TIME = \"tr_TR.UTF-8\";\n  };\n\n  # Configure keymap in X11\n  services.xserver = {\n    layout = \"tr\";\n    xkbVariant = \"\";\n  };\n\n  # Configure console keymap\n  console.keyMap = \"trq\";\n\n  # Define a user account. Don't forget to set a password with \u2018passwd\u2019.\n  users.users.muratcabuk = {\n    isNormalUser = true;\n    description = \"murat cabuk\";\n    extraGroups = [ \"networkmanager\" \"wheel\" ];\n    packages = with pkgs; [];\n  };\n\n  # Allow unfree packages\n  nixpkgs.config.allowUnfree = true;\n\n  # List packages installed in system profile. To search, run:\n  # $ nix search wget\n  environment.systemPackages = with pkgs; [\n     vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.\n     wget\n     git\n     curl\n  ];\n\n   environment.variables.EDITOR = \"vim\";\n\n  # Some programs need SUID wrappers, can be configured further or are\n  # started in user sessions.\n  # programs.mtr.enable = true;\n  # programs.gnupg.agent = {\n  #   enable = true;\n  #   enableSSHSupport = true;\n  # };\n\n  # List services that you want to enable:\n\n  # Enable the OpenSSH daemon.\n    services.openssh.enable = true;\n\n  # Open ports in the firewall.\n  # networking.firewall.allowedTCPPorts = [ ... ];\n  # networking.firewall.allowedUDPPorts = [ ... ];\n  # Or disable the firewall altogether.\n  # networking.firewall.enable = false;\n\n  # This value determines the NixOS release from which the default\n  # settings for stateful data, like file locations and database versions\n  # on your system were taken. It\u2018s perfectly fine and recommended to leave\n  # this value at the release version of the first install of this system.\n  # Before changing this value read the documentation for this option\n  # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).\n  system.stateVersion = \"23.05\"; # Did you read the comment?\n\n}\n</code></pre> <p>bide hardware-configuration.nix ad\u0131nda bir dosya olu\u015fturupo alttaki kodlar\u0131 yaz\u0131yoruz. bu dosya asl\u0131nda il kurulumda zaten sisitem taraf\u0131ndan olu\u015fturuluyor. dizin olarak ta /etc/nixos klas\u00f6r\u00fcnde bulabilirsiniz. ben de sanal makinemde kurdu\u011fumda olu\u015fmu\u015f olan\u0131 buraya kopyalad\u0131m.</p> <pre><code># Do not modify this file!  It was generated by \u2018nixos-generate-config\u2019\n# and may be overwritten by future invocations.  Please make changes\n# to /etc/nixos/configuration.nix instead.\n{ config, lib, pkgs, modulesPath, ... }:\n\n{\n  imports =\n    [ (modulesPath + \"/profiles/qemu-guest.nix\")\n    ];\n\n  boot.initrd.availableKernelModules = [ \"ahci\" \"xhci_pci\" \"virtio_pci\" \"sr_mod\" \"virtio_blk\" ];\n  boot.initrd.kernelModules = [ ];\n  boot.kernelModules = [ \"kvm-intel\" ];\n  boot.extraModulePackages = [ ];\n\n  fileSystems.\"/\" =\n    { device = \"/dev/disk/by-uuid/dab4ff6b-f67b-4fa7-9eed-42bfe3d12ef3\";\n      fsType = \"btrfs\";\n      options = [ \"subvol=@\" ];\n    };\n\n  fileSystems.\"/boot\" =\n    { device = \"/dev/disk/by-uuid/3D92-0C66\";\n      fsType = \"vfat\";\n    };\n\n  fileSystems.\"/home\" =\n    { device = \"/dev/disk/by-uuid/cce01581-8b10-4d0f-96a8-c574069c7963\";\n      fsType = \"btrfs\";\n    };\n\n  swapDevices = [ ];\n\n  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking\n  # (the default) this is the recommended approach. When using systemd-networkd it's\n  # still possible to use this option, but it's recommended to use it in conjunction\n  # with explicit per-interface declarations with `networking.interfaces.&lt;interface&gt;.useDHCP`.\n  networking.useDHCP = lib.mkDefault true;\n  # networking.interfaces.enp1s0.useDHCP = lib.mkDefault true;\n\n  nixpkgs.hostPlatform = lib.mkDefault \"x86_64-linux\";\n}\n</code></pre> <p>art\u0131k dosyalar\u0131m\u0131z\u0131 kullanarak sistemmimizi kurabiliriz. buraya kadar asl\u0131nda nix dilini kullanarak bir\u015feyler yapt\u0131k. nixos u ayaralaak ve kullanmak i\u00e7in nix komutlar\u0131 de\u011fil nixos komutlar\u0131 kullan\u0131l\u0131r.</p> <ul> <li>nixos-rebuild switch: Yeni bir yap\u0131land\u0131rmay\u0131 etkinle\u015ftirir.</li> <li>nixos-rebuild boot: \u00d6nceki yap\u0131land\u0131rmaya geri d\u00f6nme olana\u011f\u0131 sa\u011flar.</li> <li>nixos-rebuild build: Yeni yap\u0131land\u0131rmay\u0131 olu\u015fturur ancak etkinle\u015ftirmez.</li> <li>nixos-rebuild test: Yap\u0131land\u0131rmay\u0131 test etmek i\u00e7in kullan\u0131l\u0131r.</li> </ul> <p><code>nixos-rebuild switch</code> komutu, NixOS i\u015fletim sisteminin yap\u0131land\u0131rmas\u0131n\u0131 de\u011fi\u015ftirmek ve yeni bir yap\u0131land\u0131rmay\u0131 etkinle\u015ftirmek i\u00e7in kullan\u0131lan \u00f6nemli bir komuttur. Bu komut tam olarak \u015funlar\u0131 yapar:</p> <ol> <li> <p>Yeni Yap\u0131land\u0131rmay\u0131 Derleme: <code>nixos-rebuild switch</code> komutu, belirtilen NixOS yap\u0131land\u0131rma dosyas\u0131n\u0131 veya Flake'i kullanarak yeni bir sistem yap\u0131land\u0131rmas\u0131 derler. Bu, Nix paketlerini ve yap\u0131land\u0131rmalar\u0131n\u0131 gerekti\u011fi gibi alarak yeni bir sistem g\u00f6r\u00fcnt\u00fcs\u00fcn\u00fc olu\u015fturur.</p> </li> <li> <p>Aktif Yap\u0131land\u0131rmay\u0131 De\u011fi\u015ftirme: Komut, mevcut aktif yap\u0131land\u0131rmay\u0131 de\u011fi\u015ftirir. Yani, sistem \u00fczerindeki mevcut yap\u0131land\u0131rmay\u0131 devre d\u0131\u015f\u0131 b\u0131rak\u0131r ve yeni yap\u0131land\u0131rmay\u0131 etkinle\u015ftirir.</p> </li> <li> <p>Yap\u0131land\u0131rmay\u0131 Geri Alabilme: Komut \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda, eski yap\u0131land\u0131rma hala sistemde bulunur. Bu, herhangi bir hata durumunda veya yeni yap\u0131land\u0131rman\u0131n beklenmedik bir \u015fekilde \u00e7al\u0131\u015fmamas\u0131 durumunda eski yap\u0131land\u0131rmaya geri d\u00f6nebilme olana\u011f\u0131 sunar. Bu, <code>nixos-rebuild boot</code> komutuyla yap\u0131l\u0131r.</p> </li> <li> <p>\u00c7ak\u0131\u015fmalar\u0131 \u00d6nler: NixOS, yap\u0131land\u0131rmalar\u0131 ve paketleri izole edilmi\u015f bir \u00e7evrede saklad\u0131\u011f\u0131 i\u00e7in, yap\u0131land\u0131rma de\u011fi\u015fiklikleri veya yeni paketler y\u00fckleme, var olan yap\u0131land\u0131rmalar\u0131 etkilemez. Bu, sistemin kararl\u0131l\u0131\u011f\u0131n\u0131 art\u0131r\u0131r.</p> </li> <li> <p>Sistem Yap\u0131land\u0131rmas\u0131 De\u011fi\u015ftirme: Yeni yap\u0131land\u0131rma, sistemin genel yap\u0131land\u0131rmas\u0131n\u0131 de\u011fi\u015ftirir. Bu, kullan\u0131c\u0131lar\u0131n NixOS i\u015fletim sisteminin davran\u0131\u015f\u0131n\u0131 veya bile\u015fenlerini de\u011fi\u015ftirmelerine olanak tan\u0131r.</p> </li> </ol> <p>\u00d6zetle, <code>nixos-rebuild switch</code> komutu, yeni bir NixOS sistem yap\u0131land\u0131rmas\u0131 derler ve etkinle\u015ftirir, eski yap\u0131land\u0131rmay\u0131 devre d\u0131\u015f\u0131 b\u0131rak\u0131r ve sistem yap\u0131land\u0131rmas\u0131n\u0131 de\u011fi\u015ftirir. Bu, NixOS'un sistem yap\u0131land\u0131rmas\u0131n\u0131 g\u00fcncellemek ve de\u011fi\u015ftirmek i\u00e7in kullan\u0131lan temel bir komuttur.</p> <pre><code>nixos-rebuild switch \n</code></pre>"},{"location":"assets/flakes/mcabuk/OrnekNixosConfs.html","title":"OrnekNixosConfs","text":"<ul> <li> <p>https://gist.github.com/jonatasoli/ea804a25e872db1f562ad03184bf1295</p> </li> <li> <p>tam bir sistem : https://github.com/Misterio77/nix-starter-configs</p> </li> <li> <p>Resmi sayfas\u0131ndan baya b\u00fcy\u00fck bir liste: https://nixos.wiki/wiki/Configuration_Collection</p> </li> <li>3 saatlik vide ve github reposuyla birlikte = video, github</li> </ul>"},{"location":"assets/projects/flakes-exercises/multi-app/index.html","title":"nix-examples","text":""},{"location":"assets/projects/flakes-exercises/multi-app-with-callpackages/index.html","title":"nix-examples","text":""},{"location":"assets/projects/flakes-exercises/overlay-example/index.html","title":"nix-examples","text":""},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html","title":"Nix Dili ve \u00d6zellikleri","text":"<p>Bir \u00f6nceki makalemizde NisOs d\u00fcnyas\u0131n\u0131 biraz tan\u0131maya \u00e7al\u0131\u015ft\u0131k. bu yaz\u0131m\u0131zda Nix dilinin syntax'ini ve \u00f6zelliklerini \u00f6\u011frenmeye \u00e7al\u0131\u015faca\u011f\u0131z.</p> <ul> <li>Nix Dili: Nix dili C++ ile yaz\u0131lm\u0131\u015f fonksiyonel bir dildir. Yap\u0131 olarak Haskell diline benzer. Ayn\u0131 ama\u00e7la geli\u015ftirilmi\u015f bir de GNU Guile dili geli\u015ftirilmi\u015ftir bu dilde Lisp dilinden esinlenmi\u015ftir. Ancak Guile dili Nix'e g\u00f6re daha karma\u015f\u0131kt\u0131r, \u00f6\u011frenmesi zordur.</li> <li>Nix Paket Y\u00f6neticisi: Nix dili kullan\u0131larka geli\u015ftirilmi\u015f cross platform bir paket y\u00f6neticisidir. Ayn\u0131 mant\u0131kta geli\u015ftirilmi\u015f bir de GNU Guix paket y\u00f6neticisi vard\u0131r (GNU Guile diliyle geli\u015ftirilmi\u015f). Nix paket y\u00f6neticisi 2003 y\u0131l\u0131nda geli\u015ftiril\u015fmeye ba\u015flanm\u0131\u015fken Guix 2013 y\u0131l\u0131nda geli\u015ftirlmeye ba\u015flanm\u0131\u015ftr, Nix'e g\u00f6re toplulu\u011fu yok denecek kadar az.</li> <li>NixOS \u0130\u015fletim Sistemi: Nix paket y\u00f6netcisini kullanan ve Nix dili ile konfig\u00fcrasyou yap\u0131lan declarative bir i\u015fletim sistemidir.</li> <li>Nixpkgs: Nix paket y\u00f6neticisinin paket deposudur (package repository).</li> </ul>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#nix-dilinin-tanm-ve-amaclar","title":"Nix Dilinin Tan\u0131m\u0131 ve Ama\u00e7lar\u0131","text":"<p>Nix, \u00f6zellikle NixOS i\u015fletim sistemi ve Nix paket y\u00f6neticisi \u00fczerinde odaklanan bir fonksiyonel dil ve sistem arac\u0131d\u0131r. Nix dilinin temel amac\u0131, paket y\u00f6netimi ve sistem konfig\u00fcrasyonunu fonksiyonel programlama prensiplerini kullanarak ele almak ve bu i\u015flemleri g\u00fcvenli ve tekrarlanabilir bir \u015fekilde ger\u00e7ekle\u015ftirmektir. \u0130\u015fte Nix dilinin temel ama\u00e7lar\u0131ndan baz\u0131lar\u0131:</p> <ol> <li> <p>Tekrarlanabilirlik ve \u0130zolasyon: Nix, her paketin ve sistem konfig\u00fcrasyonunun ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 ve versiyonlar\u0131n\u0131 kesin bir \u015fekilde belirtme yetene\u011fi ile bilinir. Bu, herhangi bir ortamda ayn\u0131 paket ve konfig\u00fcrasyonun kurulmas\u0131n\u0131 ve \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131n\u0131 sa\u011flar.</p> </li> <li> <p>Fonksiyonel Paket Y\u00f6netimi: Nix, paketleri fonksiyonel programlama prensiplerine dayal\u0131 olarak y\u00f6netir. Her paket, d\u0131\u015fsal ba\u011f\u0131ml\u0131l\u0131klar\u0131 ile birlikte bir fonksiyon olarak tan\u0131mlan\u0131r. Bu sayede paketler birbirinden izole edilir ve sistemdeki ba\u015fka paketlerin durumunu etkilemez.</p> </li> <li> <p>\u0130\u015fletim Sistemi Konfig\u00fcrasyonu: NixOS, Nix dilini kullanarak yap\u0131land\u0131r\u0131lm\u0131\u015f bir i\u015fletim sistemidir. Sistem konfig\u00fcrasyonu, Nix dilinde ifade edilen bir fonksiyon olarak temsil edilir. Bu, sistem yap\u0131land\u0131rmas\u0131n\u0131n da tekrarlanabilir ve s\u00fcrd\u00fcr\u00fclebilir olmas\u0131n\u0131 sa\u011flar.</p> </li> <li> <p>De\u011fi\u015fmez Paket Y\u00f6netimi: Nix, her paketin ve sistem konfig\u00fcrasyonunun belirli bir versiyonunu ve durumunu saklar. Bu durum, de\u011fi\u015fmez paket y\u00f6netimini sa\u011flar ve geriye d\u00f6n\u00fck uyumlulu\u011fu art\u0131r\u0131r.</p> </li> <li> <p>\u00c7oklu Ortam Deste\u011fi: Nix, ayn\u0131 paketlerin farkl\u0131 ortamlara (geli\u015ftirme, test, \u00fcretim) kurulmas\u0131n\u0131 destekler. Her ortam, ayn\u0131 paketin farkl\u0131 versiyonlar\u0131na veya konfig\u00fcrasyonlar\u0131na sahip olabilir.</p> </li> </ol> <p>Nix, genellikle yaz\u0131l\u0131m geli\u015ftirme ve sistem y\u00f6netimi s\u00fcre\u00e7lerini daha g\u00fcvenli, tekrarlanabilir ve y\u00f6netilebilir hale getirmek i\u00e7in kullan\u0131l\u0131r.</p>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#nix-dili","title":"Nix Dili","text":"<p>Nix, bir fonksiyonel dil olan bir paket y\u00f6netim sistemi ve dilidir.</p> <ol> <li> <p>Fonksiyonel Dil:    Nix, fonksiyonel programlama paradigmas\u0131n\u0131 benimser. Bu, de\u011fi\u015fmezlik ve fonksiyonlar\u0131n birinci s\u0131n\u0131f vatanda\u015flar olarak kabul edilmesi anlam\u0131na gelir. Nix ifadeleri de fonksiyonlar olarak d\u00fc\u015f\u00fcn\u00fcl\u00fcr ve de\u011fi\u015fmezlik ilkesine uyar.</p> </li> <li> <p>De\u011fi\u015fmezlik:    Nix dilinde, bir kere tan\u0131mland\u0131ktan sonra de\u011ferler de\u011fi\u015ftirilemez. Bu, bir paket ya da ifade bir kere olu\u015fturuldu\u011funda, onunla ili\u015fkilendirilen de\u011ferlerin de\u011fi\u015fmeyece\u011fi anlam\u0131na gelir. Bu \u00f6zellik, sistem durumunun tahmin edilebilir ve tekrar \u00fcretilebilir olmas\u0131n\u0131 sa\u011flar.</p> </li> <li> <p>Tek Bir Dil:    Nix hem bir paket y\u00f6netimi sistemi hem de bir dil oldu\u011fu i\u00e7in, ayn\u0131 dilin paket tan\u0131mlamalar\u0131nda ve konfig\u00fcrasyon dosyalar\u0131nda kullan\u0131lmas\u0131na izin verir. Bu, dilin genel bir tutarl\u0131l\u0131k ve b\u00fct\u00fcnl\u00fck sa\u011flamas\u0131na yard\u0131mc\u0131 olur.</p> </li> <li> <p>\u0130fade Dilinde Tan\u0131mlama:    Nix ifadeleri, paketlerin, ortamlar\u0131n ve di\u011fer sistem bile\u015fenlerinin tan\u0131mland\u0131\u011f\u0131 bir dilde yaz\u0131l\u0131r. Bu ifadeler, bir dilin i\u00e7inde bir ba\u015fka dil gibi ifade edilebilir ve yorumlanabilir. Bu, Nix'in esnekli\u011fini art\u0131r\u0131r.</p> </li> <li> <p>Lazy Evaluation (Gecikmeli De\u011ferlendirme):    Nix, gecikmeli de\u011ferlendirme kullanarak sadece ihtiya\u00e7 duyuldu\u011funda bir ifadenin de\u011ferlendirilmesini sa\u011flar. Bu, kaynaklar\u0131 verimli bir \u015fekilde kullanmay\u0131 ve gereksiz i\u015flemleri \u00f6nlemeyi ama\u00e7lar.</p> </li> <li> <p>Ba\u011f\u0131ms\u0131z ve Ta\u015f\u0131nabilir Paketler:    Nix paketleri, sistem ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 izole edilmi\u015f bir \u015fekilde i\u00e7erir. Bu, bir paketin bir sistemden di\u011ferine ta\u015f\u0131nabilmesini sa\u011flar. Her paket, kendi ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 ve sistem k\u00fct\u00fcphanelerini i\u00e7erir.</p> </li> <li> <p>\u00c7o\u011falt\u0131labilir Paket Kurulumlar\u0131:    Nix, paketlerin belirli s\u00fcr\u00fcmlerini ve ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 \u00e7o\u011falt\u0131labilir \u015fekilde tan\u0131mlamak i\u00e7in kullan\u0131l\u0131r. Bu, projenin farkl\u0131 sistemlerde tutarl\u0131 bir \u015fekilde \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131na olanak tan\u0131r.</p> </li> <li> <p>NixOps ve NixOS:    Nix, ayr\u0131ca NixOS adl\u0131 bir i\u015fletim sistemi ve NixOps adl\u0131 bir sistem y\u00f6netimi arac\u0131yla birle\u015ftirildi\u011finde g\u00fc\u00e7l\u00fc bir sistem y\u00f6netim \u00e7\u00f6z\u00fcm\u00fc sunar. NixOps, Nix dilini kullanarak \u00f6l\u00e7eklenebilir sistem yap\u0131land\u0131rmalar\u0131n\u0131 y\u00f6netmeye olanak tan\u0131r.</p> </li> </ol> <p>Bu \u00f6zellikler, Nix'in g\u00fc\u00e7l\u00fc bir paket y\u00f6netim sistemi ve sistem konfig\u00fcrasyon dilini tan\u0131mlayan temel karakteristikleridir. Bu \u00f6zellikler, sistemlerin tekrar \u00fcretilebilir ve g\u00fcvenilir bir \u015fekilde yap\u0131land\u0131r\u0131lmas\u0131na, paketlenmesine ve y\u00f6netilmesine olanak tan\u0131r.</p>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#nix-kurulum","title":"Nix Kurulum","text":"<p>M\u00fcmk\u00fcnse NixOS'a ge\u00e7ene kadar NixOS i\u015fletim sistemi d\u0131\u015f\u0131nda ba\u015fka bir Linux da\u011f\u0131t\u0131m\u0131 kullan\u0131n. Bu nedenle Do\u011frudan NixOS kurulumu de\u011fil Nix paket y\u00f6neticisini kuraca\u011f\u0131z. Resmi sayfas\u0131ndan kurulumlar\u0131 yapabilirsiniz. Zeten her i\u015fletim sistemi i\u00e7in bir script var onu \u00e7al\u0131\u015ft\u0131rman\u0131z yeterli.</p> <p>Sadece kurulum bittikten sonra flake'i enable etmemiz gerekiyor. Bunun i\u00e7in <code>~/.config/nix/nix.conf</code> veya `/etc/nix/nix.conf' dosyas\u0131na a\u015fa\u011f\u0131daki sat\u0131r\u0131 ekleyin.</p> <pre><code>experimental-features = nix-command flakes\n</code></pre>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#veri-tipleri","title":"Veri Tipleri","text":"<p>Nix dili, NixOS ve Nix paket y\u00f6neticisi taraf\u0131ndan kullan\u0131lan \u00f6zel bir dildir. Nix dilinde, bir dizi farkl\u0131 veri tipi bulunur. \u0130\u015fte temel veri tipleri:</p>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#atoms-atomlar","title":"Atoms (Atomlar)","text":"<ul> <li><code>true</code>: Mant\u0131ksal do\u011fru.</li> <li><code>false</code>: Mant\u0131ksal yanl\u0131\u015f.</li> <li><code>null</code>: Bo\u015f de\u011fer.</li> </ul> <pre><code>true\nfalse\nnull\n</code></pre>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#saylar","title":"Say\u0131lar","text":"<ul> <li>Tam say\u0131lar (<code>integer</code>): 1, 42, -10 gibi.</li> <li>Ondal\u0131kl\u0131 say\u0131lar (<code>float</code>): 3.14, -0.5 gibi.</li> </ul> <pre><code>42\n3.14\n</code></pre>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#dizgiler-strings","title":"Dizgiler (Strings)","text":"<ul> <li>Tek t\u0131rnak (<code>'</code>) veya \u00e7ift t\u0131rnak (<code>\"</code>) i\u00e7inde ifade edilir.</li> </ul> <pre><code>\"Merhaba, d\u00fcnya!\"\n'This is a string.'\n</code></pre>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#listeler","title":"Listeler","text":"<ul> <li>Elemanlar\u0131 bo\u015flukla ayr\u0131lm\u0131\u015f, k\u00f6\u015feli parantez i\u00e7inde ifade edilir.</li> </ul> <pre><code>[1 2 3 4]\n[\"elma\" \"armut\" \"kiraz\"]\n</code></pre>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#setler","title":"Setler","text":"<ul> <li>Anahtar-de\u011fer \u00e7iftlerini i\u00e7erir. Anahtarlar benzersiz olmal\u0131d\u0131r.</li> </ul> <pre><code>{ anahtar = \"de\u011fer\"; ba\u015fkaAnahtar = 42; }\n</code></pre>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#fonksiyonlar","title":"Fonksiyonlar","text":"<ul> <li>Fonksiyonlar, <code>arg1: body</code> \u015feklinde ifade edilir.</li> </ul> <pre><code>arg: arg * 2\n</code></pre>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#built-in-fonksiyonlar","title":"Built-in Fonksiyonlar","text":"<ul> <li><code>builtins</code> mod\u00fcl\u00fc i\u00e7inde bir dizi yerle\u015fik fonksiyon bulunur. \u00d6rne\u011fin, <code>length</code>, <code>map</code>, <code>filter</code>, <code>throw</code>, vb.</li> </ul> <pre><code>builtins.length [1 2 3]\nbuiltins.map (x: x * 2) [1 2 3]\n</code></pre>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#path-yol","title":"Path (Yol)","text":"<ul> <li>Bir dosya veya dizin yolu ifade eder.</li> </ul> <pre><code>/home/kullanici/dosya.txt\n./proje\n</code></pre> <p>Bu temel veri tipleri, Nix dilindeki temel yap\u0131 ta\u015flar\u0131n\u0131 olu\u015fturur. Nix dilinde daha karma\u015f\u0131k veri yap\u0131lar\u0131 ve mod\u00fcller de bulunabilir, ancak bu, temel veri tipleridir.</p>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#operatorler","title":"Operat\u00f6rler","text":"Syntax Description +, -, *, / Numerik Operat\u00f6rler + String Birle\u015ftirme ++ Liste Birle\u015ftirme == E\u015fitlik &gt;, &gt;=, &lt;, &lt;= B\u00fcy\u00fckl\u00fck Kar\u015f\u0131la\u015ft\u0131rma &amp;&amp; Mant\u0131ksal <code>AND</code> || Mant\u0131sksal <code>OR</code> e1 -&gt; e2 Mant\u0131ksal gerektirme (\u00f6rne\u011fin e1 \u00f6nermesi do\u011fru ise (true) e2 de do\u011frudur) ! Mant\u0131ksal olarak tersini alma (\u00f6rne\u011fin true ise false yapmak) set.attr bir set'in bir attribute'una ula\u015fmak i\u00e7in set ? attribute bir set'in yaz\u0131lan attribute'\u0131 i\u00e7erip i\u00e7ermedi\u011fini kontrol eder. (\u00f6rne\u011fin {a=1;b=2;c=3;} ? b, burada sonu\u00e7 true olur) left // right sa\u011fdaki set'i soldaki set ile birle\u015ftirir (\u00f6rne\u011fin {a=1; b=2; c=3;} // {d=4; e=5; f=6;})"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#degisken-tanmlama","title":"De\u011fi\u015fken Tan\u0131mlama","text":"<p>Evet, Nix dilinde bir de\u011fi\u015fkeni tan\u0131mlamak ve kullanmak i\u00e7in <code>let</code> anahtar kelimesi kullan\u0131l\u0131r. <code>let</code> ifadesi, bir blok i\u00e7inde ge\u00e7ici de\u011fi\u015fkenler tan\u0131mlamak i\u00e7in kullan\u0131l\u0131r ve bu de\u011fi\u015fkenler, sadece <code>in</code> anahtar kelimesinden sonraki kapsamda ge\u00e7erlidir.</p> <p>\u0130\u015fte bir \u00f6rnek:</p> <pre><code>let\n  myVariable = \"Merhaba, D\u00fcnya!\";\nin\n  myVariable\n</code></pre> <p>Bu \u00f6rnekte, <code>myVariable</code> adl\u0131 bir de\u011fi\u015fken tan\u0131mlanm\u0131\u015f ve bu de\u011fi\u015fken <code>\"Merhaba, D\u00fcnya!\"</code> de\u011feri ile initialize edilmi\u015ftir. Ard\u0131ndan <code>in</code> anahtar kelimesi ile bu de\u011fi\u015fkenin kullan\u0131ld\u0131\u011f\u0131 bir kapsam (scope) tan\u0131mlanm\u0131\u015ft\u0131r. <code>myVariable</code>, bu kapsam\u0131n i\u00e7inde ge\u00e7erli bir de\u011fi\u015fken haline gelir.</p> <p>Bir ba\u015fka \u00f6rnek ile bir dizi tan\u0131mlama ve bu dizi \u00fczerinde i\u015flem yapma:</p> <pre><code>let\n  myNumbers = [1 2 3 4 5];\n  doubledNumbers = builtins.map (x: x * 2) myNumbers;\nin\n  doubledNumbers\n</code></pre> <p>Bu \u00f6rnekte, <code>myNumbers</code> adl\u0131 bir dizi tan\u0131mlanm\u0131\u015f ve ard\u0131ndan bu dizi \u00fczerinde bir <code>map</code> i\u015flemi ger\u00e7ekle\u015ftirilerek her eleman\u0131 iki ile \u00e7arp\u0131lm\u0131\u015f yeni bir dizi olan <code>doubledNumbers</code> olu\u015fturulmu\u015ftur.</p> <p><code>let</code> ifadesi, Nix dilinde bir\u00e7ok durumda kullan\u0131labilir ve \u00f6zellikle fonksiyonlar veya derivasyonlar (derivation) i\u00e7inde ge\u00e7ici de\u011fi\u015fkenler tan\u0131mlamak i\u00e7in s\u0131kl\u0131kla kullan\u0131l\u0131r.</p>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#fonksiyon-tanmlama","title":"Fonksiyon Tan\u0131mlama","text":"<p>Tabii ki, Nix dilinde fonksiyonlar, genellikle <code>pkgs</code> (paketler), <code>lib</code> (standart k\u00fct\u00fcphane) ve di\u011fer Nix mod\u00fcllerinde yayg\u0131n olarak kullan\u0131l\u0131r. Bir fonksiyonu kullan\u0131m\u0131n\u0131 anlamak i\u00e7in, bir \u00f6rnek \u00fczerinden gitmek faydal\u0131 olabilir.</p> <p>\u00d6ncelikle, basit bir fonksiyon tan\u0131mlayal\u0131m. A\u015fa\u011f\u0131daki \u00f6rnekte, bir say\u0131n\u0131n karesini bulan bir fonksiyon tan\u0131mlanm\u0131\u015ft\u0131r:</p> <pre><code># Fonksiyon tan\u0131mlama\nsquare = x: x * x;\n\n# Fonksiyonu kullanma\nresult = square 5;  # result \u015fimdi 25 de\u011ferine sahip\n</code></pre> <p>Bu \u00f6rnekte <code>square</code> ad\u0131nda bir fonksiyon tan\u0131mlanm\u0131\u015ft\u0131r. Fonksiyon, bir arg\u00fcman olan <code>x</code>'i al\u0131r ve <code>x * x</code> i\u015flemi ile karesini hesaplar. Daha sonra <code>square</code> fonksiyonu, <code>5</code> say\u0131s\u0131 ile \u00e7a\u011fr\u0131larak <code>result</code> de\u011fi\u015fkenine atan\u0131r ve <code>result</code> de\u011feri 25 olur.</p> <p>Nix dilinde fonksiyonlar genellikle <code>lib</code> mod\u00fcl\u00fcndeki fonksiyonlar gibi standart k\u00fct\u00fcphane taraf\u0131ndan sa\u011flan\u0131r. A\u015fa\u011f\u0131da, <code>lib</code> mod\u00fcl\u00fcndeki <code>concatStrings</code> fonksiyonunu kullanarak bir \u00f6rnek bulunmaktad\u0131r:</p> <pre><code>{ lib }:\n\n# Fonksiyonu kullanma\nresult = lib.concatStringsSep \", \" [\"merhaba\", \"d\u00fcnya\"];\n</code></pre> <p>Bu \u00f6rnekte, <code>lib.concatStringsSep</code> fonksiyonu, bir liste i\u00e7indeki dizeleri belirtilen ay\u0131r\u0131c\u0131 (sep) ile birle\u015ftirir. Sonu\u00e7 olarak, <code>result</code> de\u011fi\u015fkeni <code>\"merhaba, d\u00fcnya\"</code> de\u011ferine sahip olacakt\u0131r.</p> <p>Fonksiyonlar, Nix dilinde ifadeleri daha mod\u00fcler ve yeniden kullan\u0131labilir hale getirmek i\u00e7in kullan\u0131l\u0131r. Bu fonksiyonlar genellikle \u00f6zellikle paket tan\u0131mlamalar\u0131nda, sistem konfig\u00fcrasyonunda ve di\u011fer Nix ifadelerinde yayg\u0131n olarak kullan\u0131l\u0131r.</p> <p>Biraz daha karma\u015f\u0131k bir \u00f6rnek. Bu \u00f6rnekte, iki say\u0131n\u0131n toplam\u0131n\u0131, fark\u0131n\u0131, \u00e7arp\u0131m\u0131n\u0131 ve b\u00f6l\u00fcm\u00fcn\u00fc hesaplayan bir fonksiyon tan\u0131mlayaca\u011f\u0131z:</p> <pre><code># Fonksiyon tan\u0131mlama\ncalculate = { a, b }:\n  let\n    sum = a + b;\n    difference = a - b;\n    product = a * b;\n    division = if b != 0 then a / b else \"B\u00f6lme hatas\u0131: b s\u0131f\u0131ra b\u00f6l\u00fcnemez!\";\n  in\n    { sum = sum; difference = difference; product = product; division = division; };\n\n# Fonksiyonu kullanma\nresult = calculate { a = 8; b = 4; };\n</code></pre> <p>Bu \u00f6rnekte, <code>calculate</code> adl\u0131 bir fonksiyon tan\u0131mlanm\u0131\u015ft\u0131r. Bu fonksiyon, <code>{ a, b }</code> \u015feklinde iki parametre al\u0131r. Ard\u0131ndan, <code>let</code> blo\u011fu i\u00e7inde toplam, fark, \u00e7arp\u0131m ve b\u00f6lme i\u015flemleri ger\u00e7ekle\u015ftirilir. B\u00f6lme i\u015fleminde <code>if</code> ifadesi kullan\u0131larak s\u0131f\u0131ra b\u00f6lme hatas\u0131 kontrol edilir. Son olarak, bir tuple i\u00e7inde hesaplanan de\u011ferler d\u00f6nd\u00fcr\u00fcl\u00fcr.</p> <p>Bu fonksiyonu kullanmak i\u00e7in, <code>calculate</code> fonksiyonuna bir parametre objesi g\u00f6nderilir ve d\u00f6nen de\u011fer <code>result</code> de\u011fi\u015fkenine atan\u0131r. <code>result</code> de\u011fi\u015fkeni, hesaplamalar\u0131n sonu\u00e7lar\u0131n\u0131 i\u00e7eren bir tuple'\u0131 temsil eder.</p> <pre><code>{\n  sum = 12;\n  difference = 4;\n  product = 32;\n  division = 2;\n}\n</code></pre> <p>Bu \u00f6rnekteki fonksiyon, Nix dilinde daha karma\u015f\u0131k ifadeler ve kontroller i\u00e7eren bir fonksiyonun nas\u0131l tan\u0131mlanabilece\u011fini g\u00f6stermektedir. Nix dilinde fonksiyonlar, \u00f6zellikle sistem konfig\u00fcrasyonu veya paket tan\u0131mlamalar\u0131 gibi karma\u015f\u0131k senaryolarda kullan\u0131larak kodu mod\u00fcler ve yeniden kullan\u0131labilir hale getirmenin bir yolu olarak de\u011ferlendirilir.</p> <p>\u00d6rnekte, <code>calculate</code> ifadesi bir fonksiyonu tan\u0131mlar. Nix dilinde fonksiyonlar, genellikle parametre listesi ve fonksiyonun g\u00f6vdesini i\u00e7eren bir ifade ile tan\u0131mlan\u0131r.</p> <pre><code>calculate = { a, b }:\n  let\n    sum = a + b;\n    difference = a - b;\n    product = a * b;\n    division = if b != 0 then a / b else \"B\u00f6lme hatas\u0131: b s\u0131f\u0131ra b\u00f6l\u00fcnemez!\";\n  in\n    { sum = sum; difference = difference; product = product; division = division; };\n</code></pre> <p>Yukar\u0131daki \u00f6rnekte, <code>calculate</code> fonksiyonu <code>{ a, b }</code> adl\u0131 bir parametre listesi al\u0131r. Daha sonra, <code>let</code> blo\u011fu i\u00e7inde <code>sum</code>, <code>difference</code>, <code>product</code>, ve <code>division</code> de\u011fi\u015fkenleri tan\u0131mlan\u0131r. <code>in</code> anahtar kelimesiyle ayr\u0131lan b\u00f6l\u00fcmde ise fonksiyonun geri d\u00f6n\u00fc\u015f de\u011feri belirlenir. Bu durumda, hesaplanan de\u011ferleri i\u00e7eren bir tuple d\u00f6nd\u00fcr\u00fcl\u00fcr.</p> <p>Bu tarz bir fonksiyon, <code>calculate { a = 8; b = 4; }</code> gibi bir \u015fekilde \u00e7a\u011fr\u0131labilir. Bu \u00e7a\u011fr\u0131, <code>a</code> ve <code>b</code> parametrelerini i\u00e7eren bir obje ile fonksiyonu \u00e7a\u011f\u0131r\u0131r ve sonu\u00e7 olarak hesaplamalar\u0131n yap\u0131ld\u0131\u011f\u0131 tuple'\u0131 d\u00f6nd\u00fcr\u00fcr.</p> <p><code>let</code> ve <code>in</code> ifadeleri, Nix dilinde bir blo\u011fu (scope) tan\u0131mlamak i\u00e7in kullan\u0131l\u0131r. Bu blok i\u00e7inde tan\u0131mlanan de\u011fi\u015fkenler sadece bu blok i\u00e7inde ge\u00e7erlidir ve d\u0131\u015far\u0131dan eri\u015filemez. Dolay\u0131s\u0131yla, <code>let</code> ve <code>in</code> ifadeleri, calculate fonksiyonunun g\u00f6vdesini olu\u015fturur.</p> <p>\u0130\u015fte detaylar:</p> <pre><code>calculate = { a, b }:\n  let\n    sum = a + b;\n    difference = a - b;\n    product = a * b;\n    division = if b != 0 then a / b else \"B\u00f6lme hatas\u0131: b s\u0131f\u0131ra b\u00f6l\u00fcnemez!\";\n  in\n    { sum = sum; difference = difference; product = product; division = division; };\n</code></pre> <ul> <li><code>let</code> ifadesi ile ba\u015flayan k\u0131s\u0131m, de\u011fi\u015fkenlerin tan\u0131mland\u0131\u011f\u0131 blo\u011fu olu\u015fturur.</li> <li><code>in</code> ifadesi ise bu blo\u011fun sona erdi\u011fini ve bu blok i\u00e7inde tan\u0131mlanan de\u011fi\u015fkenlerin art\u0131k kullan\u0131labilece\u011fini belirtir.</li> </ul> <p>Bu yap\u0131 sayesinde, fonksiyonun i\u00e7indeki hesaplamalara \u00f6zg\u00fc de\u011fi\u015fkenler (<code>sum</code>, <code>difference</code>, <code>product</code>, <code>division</code>) sadece <code>let</code> ve <code>in</code> blo\u011fu i\u00e7inde ge\u00e7erli olur ve fonksiyonun d\u0131\u015f\u0131nda g\u00f6r\u00fcnmez.</p> <p>Daha sade bir \u00f6rnek ile fonksiyon tan\u0131m\u0131</p> <pre><code>f = { a, b }: { result = a+b; };\n\nf {a=1;b=2;}\n\n# sonu\u00e7 { result = 3; }\n</code></pre>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#fonksiyonlarda-geri-deger-dondurmek","title":"Fonksiyonlarda geri de\u011fer d\u00f6nd\u00fcrmek","text":"<p>Fonksiyonlardan de\u011fer d\u00f6nd\u00fcrmek m\u00fcmk\u00fcnd\u00fcr. Nix dilinde fonksiyonlar, son de\u011feri otomatik olarak d\u00f6nd\u00fcr\u00fcr. Bu, fonksiyonun sonunda yer alan ifade veya blo\u011fun de\u011feridir. \u00d6nceki \u00f6rneklerde de g\u00f6r\u00fcld\u00fc\u011f\u00fc gibi, fonksiyon son de\u011feri belirli bir de\u011fer veya ifade olabilir.</p> <p>\u00d6rne\u011fin, basit bir fonksiyonun tan\u0131mlanmas\u0131 ve de\u011fer d\u00f6nd\u00fcrmesi:</p> <pre><code># Fonksiyon tan\u0131mlama\ndouble = x: x * 2;\n\n# Fonksiyonu \u00e7a\u011f\u0131rma ve de\u011fer d\u00f6nd\u00fcrme\nresult = double 5;  # result \u015fimdi 10 de\u011ferine sahip\n</code></pre> <p>Bu \u00f6rnekte, <code>double</code> fonksiyonu bir say\u0131n\u0131n iki kat\u0131n\u0131 hesaplar ve bu de\u011feri otomatik olarak d\u00f6nd\u00fcr\u00fcr.</p> <p>Fonksiyonlar, <code>let</code> ve <code>in</code> bloklar\u0131 i\u00e7inde daha karma\u015f\u0131k yap\u0131larda da kullan\u0131labilir. \u00d6rne\u011fin, iki say\u0131 aras\u0131ndaki asal say\u0131lar\u0131 bulan bir fonksiyon:</p> <pre><code>findPrimes = { start, end }:\n  let\n    isPrime = n: builtins.all (i: n % i != 0) (builtins.range 2 n);\n    primes = builtins.filter isPrime (builtins.range start end);\n  in\n    primes;\n\nresult = findPrimes { start = 10; end = 30; };  # result \u015fimdi [11 13 17 19 23 29] de\u011ferine sahip\n</code></pre> <p>Bu \u00f6rnekte, <code>findPrimes</code> fonksiyonu iki say\u0131 aras\u0131ndaki asal say\u0131lar\u0131 bulur ve bu asal say\u0131lar\u0131 i\u00e7eren bir liste olarak d\u00f6nd\u00fcr\u00fcr. <code>result</code> de\u011fi\u015fkeni, fonksiyonun d\u00f6nd\u00fcrd\u00fc\u011f\u00fc de\u011feri i\u00e7erir.</p>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#fonksiyonlarda-coklu-arguman-kullanm","title":"Fonksiyonlarda \u00e7oklu arguman kullan\u0131m\u0131","text":"<pre><code>let\n  multiply = a: b: a * b;\n  doubleIt = multiply 2; # at this point we have passed in the value for 'a' and\n                         # receive back another function that still expects 'b'\nin\n  doubleIt 15\n\n# yields 30\n</code></pre> <p>doubleIt fonksiyonu, <code>multiply</code> fonksiyonuna 2 de\u011ferini g\u00f6nderir ve <code>multiply</code> fonksiyonundan bir fonksiyon d\u00f6nd\u00fcr\u00fcr. in ifadesi i\u00e7inde \u00e7a\u011fr\u0131lan doubleIt 15 sat\u0131r\u0131nda ise multiply fonksiyonunun d\u00f6nd\u00fcrd\u00fc\u011f\u00fc fonksiyon 15 de\u011ferini al\u0131r ve 30 de\u011ferini d\u00f6nd\u00fcr\u00fcr.</p> <p>say\u0131s\u0131 belli olmayan arguman tan\u0131m\u0131 i\u00e7in ... kullan\u0131l\u0131r</p> <pre><code>let greeter = { name, age, ... }: \"${name} is ${toString age} years old\";\n    person = {\n      name = \"Slartibartfast\";\n      age = 42;\n      # the 'email' attribute is not expected by the 'greeter' function ...\n      email = \"slartibartfast@magrath.ea\";\n    };\nin greeter person # ... but the call works due to the ellipsis.\n</code></pre> <p>greeter ad\u0131nda bir fonksiyon name ve age ad\u0131nda iki arguman al\u0131yor. \u00fcn nokta ile e\u011fer daha fazla arguman gelirse onlar\u0131 da al\u0131yor. person ad\u0131nda bir obje tan\u0131mlan\u0131yor. bu obje name ve age ad\u0131nda iki attribute i\u00e7eriyor. email attribute'\u00fc ise greeter fonksiyonu taraf\u0131ndan beklenmiyor. fakat greeter fonksiyonu person objesini arguman olarak al\u0131yor ve \u00e7al\u0131\u015f\u0131yor. \u00e7\u00fcnk\u00fc person objesindeki attribute'lerin hepsi greeter fonksiyonu taraf\u0131ndan beklenen argumanlar aras\u0131nda yer al\u0131yor. bu durumda email attribute'\u00fc greeter fonksiyonu taraf\u0131ndan kullan\u0131lm\u0131yor. ancak sistem \u00fc\u00e7 nokta kullan\u0131ld\u0131\u011f\u0131 i\u00e7in hata vermiyor.</p> <p>Di\u011fer bir \u00f6rnekte b\u00fct\u00fcn argumanlar\u0131n ad\u0131n\u0131 yazal\u0131m</p> <pre><code>let func = { name, age, ... }@args: builtins.attrNames args;\nin func {\n    name = \"Slartibartfast\";\n    age = 42;\n    email = \"slartibartfast@magrath.ea\";\n}\n\n# sonu\u00e7: [ \"age\" \"email\" \"name\" ]\n</code></pre> <p>\u015fimdi de de\u011ferleri yazd\u0131lar\u0131m</p> <pre><code>let func = { name, age, ... }@args: builtins.attrValues args;\nin func {\n    name = \"Slartibartfast\";\n    age = 42;\n    email = \"slartibartfast@magrath.ea\";\n}\n\n# sonu\u00e7 : [ 42 \"slartibartfast@magrath.ea\" \"Slartibartfast\" ]\n</code></pre>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#kosullar","title":"Ko\u015fullar","text":"<p>Nix dilinde ko\u015ful ifadeleri kullanmak i\u00e7in <code>if</code> ve <code>else</code> anahtar kelimeleri kullan\u0131l\u0131r. Ko\u015fullar, genellikle bir de\u011ferin do\u011fru veya yanl\u0131\u015f olup olmad\u0131\u011f\u0131n\u0131 kontrol etmek amac\u0131yla kullan\u0131l\u0131r. \u0130\u015fte basit bir \u00f6rnek:</p> <pre><code># \u00d6rnek 1: Bir ko\u015fulu kontrol etmek\n{\n  condition = true;\n  result = if condition then \"Do\u011fru durum\" else \"Yanl\u0131\u015f durum\";\n}\n</code></pre> <p>Bu \u00f6rnekte, <code>condition</code> adl\u0131 bir de\u011fi\u015fken tan\u0131mlanm\u0131\u015f ve <code>if</code> ifadesi ile kontrol edilmi\u015ftir. E\u011fer <code>condition</code> do\u011fru ise \"Do\u011fru durum\", de\u011filse \"Yanl\u0131\u015f durum\" d\u00f6necektir.</p> <p>Ayr\u0131ca, bir ko\u015fulu daha karma\u015f\u0131k hale getirmek i\u00e7in <code>else if</code> de kullan\u0131labilir:</p> <pre><code># \u00d6rnek 2: Birden fazla ko\u015fulu kontrol etmek\n{\n  value = 10;\n  result =\n    if value &lt; 0 then \"Negatif\"\n    else if value == 0 then \"S\u0131f\u0131r\"\n    else \"Pozitif\";\n}\n</code></pre> <p>Bu \u00f6rnekte, <code>value</code> adl\u0131 bir de\u011fi\u015fkenin de\u011ferine ba\u011fl\u0131 olarak bir durum kontrol edilmektedir. E\u011fer <code>value</code> negatifse \"Negatif\", s\u0131f\u0131rsa \"S\u0131f\u0131r\", pozitifse \"Pozitif\" d\u00f6necektir.</p> <p>Ko\u015fullar genellikle fonksiyonel bir dilde kullan\u0131lan ifade y\u00f6ntemine benzer \u015fekilde \u00e7al\u0131\u015f\u0131r ve sadece belirli bir durum sa\u011fland\u0131\u011f\u0131nda veya sa\u011flanmad\u0131\u011f\u0131nda de\u011feri de\u011ferlendirirler.</p>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#inherit-kullanm","title":"Inherit kullan\u0131m\u0131","text":"<p>Bu asl\u0131nda \u00e7ok basit bir i\u015f yapar. Normalde de\u011fi\u015fkenler bildi\u011fimiz gibi in blo\u011fu d\u0131\u015f\u0131nda kullan\u0131lmaz. Ancak bazen bunlar\u0131 d\u0131\u015far\u0131 aktarmam\u0131z gerekir. Bundan dolay\u0131 da alttaki \u00f6rnekte oldu\u011fu gibi bunlar\u0131 in blo\u011fundan tekrar e\u015fitleriz.</p> <pre><code>let\n  name = \"Slartibartfast\";\n  # ... other variables\nin {\n  name = name; # set the attribute set key 'name' to the value of the 'name' var\n  # ... other attributes\n}\n</code></pre> <p>tabi de\u011fi\u015fken as\u0131y\u0131 \u00e7ok oldu\u011funda bun yazmak s\u0131k\u0131c\u0131 olabilir. Inherit keyword'\u00fc bunu kolayla\u015ft\u0131r\u0131r.</p> <pre><code>let\n  name = \"Slartibartfast\";\n  # ... other variables\nin {\n  inherit name;\n  # ... other attributes\n}\n</code></pre> <p>bu tabi sadece let i\u00e7inde tan\u0131ml\u0131 olanlar\u0131 ta\u015f\u0131mak i\u00e7in kullan\u0131lmaz. Hen\u00fcz g\u00f6rmedik ancak yine bahsetmek gerekiyor.Import etti\u011fimiz mod\u00fcllerdeki attribute'leri de ta\u015f\u0131mak i\u00e7in kullan\u0131l\u0131r. \u00d6rne\u011fin pkgs mod\u00fcl\u00fcn\u00fc import edelim. Bu mod\u00fcldeki b\u00fct\u00fcn attribute'leri ta\u015f\u0131mak i\u00e7in inherit kullanabiliriz.</p> <p><code>inherit</code>, bir \u00f6zellik veya de\u011feri ba\u015fka bir ifadeden veya bir mod\u00fclden miras almak i\u00e7in kullan\u0131l\u0131r. \u0130\u015fte birka\u00e7 \u00f6rnek:</p> <p>\u00d6rnek 1: Mod\u00fcldeki Bir \u00d6zelli\u011fi Miras Almak:</p> <pre><code># Bir mod\u00fcl tan\u0131mla\nmyModule = {\n  foo = \"Merhaba, D\u00fcnya!\";\n};\n\n# inherit kullanarak mod\u00fcldeki \u00f6zelli\u011fi miras al\nmyDerivation = {\n  inherit (myModule) foo;\n  buildInputs = [ foo ]; # Foo'yu kullanabilirsin\n};\n</code></pre> <p>Bu \u00f6rnekte, <code>myModule</code> adl\u0131 bir mod\u00fcl tan\u0131mlanm\u0131\u015f ve <code>foo</code> adl\u0131 \u00f6zelli\u011fi i\u00e7ermektedir. Daha sonra, <code>inherit</code> ifadesi ile <code>myDerivation</code> adl\u0131 bir derivasyon tan\u0131mlanm\u0131\u015ft\u0131r ve bu derivasyon, <code>myModule</code> mod\u00fcl\u00fcnden <code>foo</code> \u00f6zelli\u011fini miras alm\u0131\u015ft\u0131r.</p> <p>\u00d6rnek 2: Paket Tan\u0131mlamas\u0131nda inherit Kullan\u0131m\u0131:</p> <pre><code># inherit kullanarak bir paket tan\u0131mla\nmyPackage = pkgs.stdenv.mkDerivation rec {\n  pname = \"myPackage\";\n  version = \"1.0\";\n\n  inherit (pkgs) fetchurl; # fetchurl'\u00fc miras al\n  src = fetchurl {\n    url = \"https://example.com/myPackage-1.0.tar.gz\";\n    sha256 = \"...\"; # Ger\u00e7ek bir de\u011fer kullan\u0131lmal\u0131d\u0131r.\n  };\n};\n</code></pre> <p>Bu \u00f6rnekte, <code>myPackage</code> adl\u0131 bir paket tan\u0131mlamas\u0131 yap\u0131lm\u0131\u015ft\u0131r. <code>inherit</code> ifadesi, <code>pkgs</code> mod\u00fcl\u00fcnden <code>fetchurl</code>'\u00fc miras alarak, <code>src</code> \u00f6zelli\u011fini tan\u0131mlamak i\u00e7in kullan\u0131lm\u0131\u015ft\u0131r. <code>fetchurl</code> fonksiyonu, belirtilen URL'den kaynak dosyas\u0131n\u0131 \u00e7ekmek i\u00e7in Nix i\u00e7inde bulunan bir fonksiyondur.</p> <p><code>inherit</code> ifadesi, Nix dilinde mod\u00fclerlik ve tekrar kullan\u0131labilirlik sa\u011flamak i\u00e7in s\u0131k\u00e7a kullan\u0131l\u0131r, \u00f6zellikle de derivasyon tan\u0131mlamalar\u0131 ve paket ifadeleri i\u00e7inde.</p>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#with-kullanm","title":"With Kullan\u0131m\u0131","text":"<p>with anahtar kelimesi \u00e7ok fazla tekrar etmemizi \u00f6nler.</p> <pre><code># \u0130\u00e7 i\u00e7e ge\u00e7mi\u015f set'ler\nouterSet = {\n  innerSet1 = {\n    a = 1;\n    b = 2;\n  };\n\n  innerSet2 = {\n    c = 3;\n    d = 4;\n  };\n\n  innerSet3 = {\n    e = 5;\n    f = 6;\n  };\n};\n\n# `with` kullanarak i\u00e7 i\u00e7e ge\u00e7mi\u015f set'lerdeki \u00f6zelliklere eri\u015fim\nwith outerSet; innerSet1.a + innerSet2.d - innerSet3.f\n</code></pre> <p>Bu \u00f6rnekte, <code>outerSet</code> adl\u0131 bir set i\u00e7inde <code>innerSet1</code>, <code>innerSet2</code> ve <code>innerSet3</code> adl\u0131 \u00fc\u00e7 ayr\u0131 set bulunmaktad\u0131r. Daha sonra <code>with outerSet;</code> ifadesi ile <code>innerSet1</code>, <code>innerSet2</code> ve <code>innerSet3</code> set'lerine do\u011frudan eri\u015fim sa\u011flanmaktad\u0131r. Bu set'lerin i\u00e7indeki \u00f6zelliklere <code>innerSet1.a</code>, <code>innerSet2.d</code> ve <code>innerSet3.f</code> \u015feklinde eri\u015fim sa\u011flayarak bir matematiksel i\u015flem ger\u00e7ekle\u015ftirilmi\u015ftir.</p>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#path-veri-turu","title":"Path veri t\u00fcr\u00fc","text":"<p>Nix dilinde <code>path</code> veri tipi, dosya yollar\u0131n\u0131 temsil etmek i\u00e7in kullan\u0131l\u0131r. Bu veri tipi, bir dizeden ziyade bir dosya yolunu daha g\u00fcvenli ve ta\u015f\u0131nabilir bir \u015fekilde ifade etmek i\u00e7in tasarlanm\u0131\u015ft\u0131r. <code>path</code> tipi, dosya yollar\u0131n\u0131n karakter kodlamas\u0131, k\u00f6k dizin a\u011fac\u0131 (root) ve di\u011fer \u00f6zellikleri konusunda tutarl\u0131l\u0131\u011f\u0131 sa\u011flamak amac\u0131yla geli\u015ftirilmi\u015ftir.</p> <p>\u0130\u015fte <code>path</code> veri tipiyle ilgili temel bilgiler:</p> <ol> <li>Yol Olu\u015fturma: <code>path</code> tipinde bir yol olu\u015fturmak i\u00e7in <code>builtins.path</code> fonksiyonu kullan\u0131l\u0131r.</li> </ol> <pre><code>myPath = builtins.path \"/etc\";\n</code></pre> <ol> <li>Yol \u0130\u015flemleri: <code>path</code> tipi, standart dosya i\u015flemlerini ger\u00e7ekle\u015ftirmek i\u00e7in kullan\u0131labilir. \u00d6rne\u011fin, <code>myPath</code> adl\u0131 bir <code>path</code> nesnesinin i\u00e7indeki dosya ve dizinleri listelemek i\u00e7in:</li> </ol> <pre><code>filesInPath = builtins.readDir myPath;\n</code></pre> <ol> <li>G\u00fcvenli Dizin Birle\u015ftirme: <code>path</code> tipi, dizinleri g\u00fcvenli bir \u015fekilde birle\u015ftirmek i\u00e7in <code>//</code> operat\u00f6r\u00fcn\u00fc kullan\u0131r. Bu, dosya yollar\u0131n\u0131n sistem ba\u011f\u0131ms\u0131z bir \u015fekilde birle\u015ftirilmesini sa\u011flar.</li> </ol> <pre><code>combinedPath = \"/etc\" // \"nginx\" // \"conf.d\";\n</code></pre> <ol> <li>Karakter Kodlamas\u0131: <code>path</code> tipi, dosya yollar\u0131n\u0131n karakter kodlamas\u0131n\u0131 sa\u011flamak i\u00e7in \u00f6zel bir i\u015fleme tabi tutulur. Bu, dosya adlar\u0131n\u0131n yanl\u0131\u015fl\u0131kla de\u011fi\u015fmesini \u00f6nler.</li> </ol> <pre><code>encodedPath = builtins.path \"/home/user/\u00fcr\u00fcn\";\n</code></pre> <p>Bu \u00f6zellikler sayesinde <code>path</code> veri tipi, dosya i\u015flemlerini daha g\u00fcvenli ve ta\u015f\u0131nabilir bir \u015fekilde ger\u00e7ekle\u015ftirmenizi sa\u011flar. \u00d6zellikle dosya yollar\u0131n\u0131n ta\u015f\u0131nabilirli\u011fi ve sistem ba\u011f\u0131ms\u0131zl\u0131\u011f\u0131 \u00f6nemliyse, <code>path</code> tipini kullanmak iyi bir uygulamad\u0131r.</p>"},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#import-nix_path-ve-kavramlar-hakknda","title":"Import, NIX_PATH ve  kavramlar\u0131 hakk\u0131nda <p><code>import</code>, <code>NIX_PATH</code>, ve <code>&lt;entry&gt;</code> kavramlar\u0131, Nix dilinde paket ve mod\u00fcl y\u00f6netimi i\u00e7in kullan\u0131lan \u00f6nemli kavramlard\u0131r. \u0130\u015fte bu kavramlarla ilgili a\u00e7\u0131klamalar:</p> <ol> <li><code>import</code>:</li> <li><code>import</code> ifadesi, bir dosyada veya URL'de bulunan Nix ifadesini i\u00e7e aktarmak i\u00e7in kullan\u0131l\u0131r.</li> <li>\u00d6rne\u011fin, <code>import ./myFile.nix</code> ifadesi, mevcut dizindeki <code>myFile.nix</code> dosyas\u0131ndaki Nix ifadesini i\u00e7e aktar\u0131r.</li> <li> <p><code>import</code> ile uzak bir kaynaktan da i\u00e7e aktar\u0131m yap\u0131labilir, \u00f6rne\u011fin: <code>import https://example.com/myFile.nix</code>.</p> </li> <li> <p><code>NIX_PATH</code>:</p> </li> <li><code>NIX_PATH</code>, Nix dilinde mod\u00fcllerin ve di\u011fer kaynaklar\u0131n bulundu\u011fu dizinleri belirten bir ortam de\u011fi\u015fkenidir.</li> <li>Bu de\u011fi\u015fken, Nix'in mod\u00fcl sistemini ve kaynaklar\u0131n yerini bulmas\u0131n\u0131 sa\u011flar.</li> <li>\u00d6rne\u011fin, <code>NIX_PATH=nixpkgs=/path/to/nixpkgs</code> ifadesi, <code>nixpkgs</code> mod\u00fcl\u00fcn\u00fcn <code>/path/to/nixpkgs</code> dizininde bulundu\u011funu belirtir.</li> <li> <p><code>NIX_PATH</code> kullan\u0131larak, Nix dilinde farkl\u0131 mod\u00fcller ve kaynaklar aras\u0131nda ge\u00e7i\u015f yapabilirsiniz.</p> </li> <li> <p><code>&lt;entry&gt;</code>:</p> </li> <li><code>&lt;entry&gt;</code>, <code>NIX_PATH</code> i\u00e7inde belirtilmi\u015f olan bir mod\u00fcl\u00fcn veya kayna\u011f\u0131n ad\u0131d\u0131r.</li> <li>\u00d6rne\u011fin, <code>import &lt;nixpkgs&gt;</code> ifadesi, <code>NIX_PATH</code> i\u00e7inde belirtilmi\u015f olan <code>nixpkgs</code> mod\u00fcl\u00fcn\u00fc i\u00e7e aktar\u0131r.</li> </ol> <p>\u0130li\u015fki:</p> <ul> <li><code>import</code> ifadesi ile bir dosya veya URL i\u00e7eri aktar\u0131l\u0131rken, <code>NIX_PATH</code> i\u00e7inde belirtilen mod\u00fcller veya kaynaklar da kullan\u0131labilir.</li> <li><code>&lt;entry&gt;</code> kullan\u0131larak <code>NIX_PATH</code> i\u00e7inde belirtilen mod\u00fcller veya kaynaklar, <code>import</code> ifadesi i\u00e7inde referans olarak kullan\u0131labilir.</li> <li>\u00d6rne\u011fin, <code>import &lt;nixpkgs&gt;</code> ifadesi, <code>NIX_PATH</code> i\u00e7indeki <code>nixpkgs</code> mod\u00fcl\u00fcn\u00fc i\u00e7e aktar\u0131r.</li> </ul> <p>Bu kavramlar, Nix dilinde kod organizasyonunu ve mod\u00fclerli\u011fi destekleyen \u00f6nemli bile\u015fenlerdir. <code>import</code>, <code>NIX_PATH</code>, ve <code>&lt;entry&gt;</code> kullan\u0131m\u0131, Nix projelerinde kodun d\u00fczenlenmesi ve payla\u015f\u0131labilirli\u011fi a\u00e7\u0131s\u0131ndan \u00f6nemlidir.</p>","text":""},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#modul-kavram","title":"Mod\u00fcl Kavram\u0131 <p>Nix dilindeki mod\u00fcl kavram\u0131, Nix kodunu organize etmek, payla\u015fmak ve tekrar kullanmak i\u00e7in kullan\u0131lan bir yap\u0131d\u0131r. Mod\u00fcller, Nix ifadelerini i\u00e7eren ve genellikle belirli bir konsepti veya i\u015flevi temsil eden dosyalard\u0131r. Mod\u00fcller, Nix projelerini mod\u00fcler hale getirerek kodun d\u00fczenlenmesini ve y\u00f6netilmesini kolayla\u015ft\u0131r\u0131r.</p> <p>\u0130\u015fte Nix mod\u00fclleri hakk\u0131nda temel bilgiler:</p> <ol> <li>Mod\u00fcl Tan\u0131mlama:</li> <li>Mod\u00fcller, <code>.nix</code> uzant\u0131l\u0131 dosyalarda tan\u0131mlan\u0131r.</li> <li> <p>Genellikle, bir mod\u00fcl, bir fonksiyon, bir paket tan\u0131mlamas\u0131 veya belirli bir konsepti temsil eden bir grup ifade i\u00e7erir.</p> </li> <li> <p>Mod\u00fcl \u0130\u00e7indeki Kodun Kullan\u0131m\u0131:</p> </li> <li>Mod\u00fcl i\u00e7inde tan\u0131mlanan ifadeler, di\u011fer Nix dosyalar\u0131nda <code>import</code> ifadesi kullan\u0131larak i\u00e7e aktar\u0131labilir ve kullan\u0131labilir.</li> <li> <p>\u0130\u00e7e aktar\u0131lan mod\u00fcldeki fonksiyonlar, paket tan\u0131mlamalar\u0131 veya di\u011fer ifadeler, kullan\u0131ld\u0131klar\u0131 dosyada kullan\u0131labilir.</p> </li> <li> <p>Mod\u00fcl \u0130mport Etme:</p> </li> <li>Ba\u015fka bir Nix dosyas\u0131nda bir mod\u00fcl\u00fc i\u00e7e aktarmak i\u00e7in <code>import</code> ifadesi kullan\u0131l\u0131r.</li> <li>Mod\u00fcl\u00fcn bulundu\u011fu dosyan\u0131n yolunu veya <code>NIX_PATH</code> i\u00e7inde belirtilen bir mod\u00fcl\u00fc i\u00e7e aktarmak m\u00fcmk\u00fcnd\u00fcr.</li> </ol> <pre><code># Mod\u00fcl i\u00e7indeki fonksiyonlar\u0131 i\u00e7e aktarma\nlet\n  myModule = import ./myModule.nix;\nin\n  myModule.myFunction\n</code></pre> <ol> <li>Mod\u00fcler Kod Organizasyonu:</li> <li>Mod\u00fcller, kodu mant\u0131kl\u0131 bloklara b\u00f6lerek ve belirli i\u015flevleri temsil ederek projeyi daha d\u00fczenli hale getirir.</li> <li>\u00d6rne\u011fin, bir mod\u00fcl i\u00e7inde paket tan\u0131mlamalar\u0131, \u00f6zel fonksiyonlar veya sistem konfig\u00fcrasyonu ile ilgili ifadeler bulunabilir.</li> </ol> <p>\u00d6rnek bir mod\u00fcl tan\u0131m\u0131:</p> <pre><code># myModule.nix\n\n{ lib, buildInputs ? [] }:\n\n{\n  myFunction = args: {\n    inherit (args) packageName;\n    buildInputs = [ lib.iconv ] ++ buildInputs;\n  };\n}\n</code></pre> <p>Bu \u00f6rnek mod\u00fcl, bir fonksiyon i\u00e7erir ve bu fonksiyon, gelen arg\u00fcmanlara g\u00f6re bir paket tan\u0131mlamas\u0131 yapar. Ba\u015fka bir dosyada bu mod\u00fcl\u00fc i\u00e7e aktar\u0131p, <code>myFunction</code>'\u0131 kullanabilirsiniz. Bu \u015fekilde, kodunuzu mod\u00fcler ve yeniden kullan\u0131labilir hale getirebilirsiniz.</p>","text":""},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#overrride-kullanm","title":"Overrride kullan\u0131m\u0131 <p>Nix dilinde <code>override</code> ifadesi, var olan bir ifadeyi veya set'i de\u011fi\u015ftirmek veya geni\u015fletmek i\u00e7in kullan\u0131l\u0131r. Bu, \u00f6zellikle paket tan\u0131mlamalar\u0131n\u0131 de\u011fi\u015ftirmek veya var olan bir konfig\u00fcrasyonu g\u00fcncellemek i\u00e7in s\u0131k\u00e7a kullan\u0131l\u0131r. <code>override</code> ifadesi, bir set'in belirli \u00f6zelliklerini g\u00fcncellemenin yan\u0131 s\u0131ra, bir set'i geni\u015fletmek veya daraltmak i\u00e7in de kullan\u0131labilir.</p> <p><code>override</code> ifadesinin temel kullan\u0131m\u0131 \u015fu \u015fekildedir:</p> <pre><code># Set i\u00e7indeki bir \u00f6zelli\u011fi de\u011fi\u015ftirme\noriginalSet // { key = newValue; }\n\n# Set'i geni\u015fletme\noriginalSet // { newKey = newValue; }\n\n# Set'ten bir \u00f6zelli\u011fi kald\u0131rma\noriginalSet // { key = null; }\n</code></pre> <p>\u0130\u015fte birka\u00e7 \u00f6rnek:</p> <p>1. Set i\u00e7indeki bir \u00f6zelli\u011fi de\u011fi\u015ftirme:</p> <pre><code># Bir set tan\u0131mla\nmySet = {\n  key1 = \"value1\";\n  key2 = \"value2\";\n};\n\n# key1'i \"new_value\" ile de\u011fi\u015ftir\nupdatedSet = mySet // { key1 = \"new_value\"; };\n</code></pre> <p>2. Set'i geni\u015fletme:</p> <pre><code># Bir set tan\u0131mla\nmySet = {\n  key1 = \"value1\";\n};\n\n# Yeni bir \u00f6zellik ekleyerek set'i geni\u015flet\nextendedSet = mySet // { key2 = \"value2\"; };\n</code></pre> <p>3. Set'ten bir \u00f6zelli\u011fi kald\u0131rma:</p> <pre><code># Bir set tan\u0131mla\nmySet = {\n  key1 = \"value1\";\n  key2 = \"value2\";\n};\n\n# key1'i set'ten kald\u0131r\nremovedSet = mySet // { key1 = null; };\n</code></pre> <p><code>override</code> ifadesi, \u00f6zellikle Nix paket tan\u0131mlamalar\u0131nda ve konfig\u00fcrasyonlar\u0131nda g\u00fcncellemeler yapmak i\u00e7in kullan\u0131l\u0131r. Bu sayede var olan bir set \u00fczerinde de\u011fi\u015fiklik yapmak, yeni \u00f6zellikler eklemek veya mevcut \u00f6zellikleri de\u011fi\u015ftirmek m\u00fcmk\u00fcn olur.</p> <p><code>overrideAttrs</code> fonksiyonu, Nix dilinde paket tan\u0131mlamalar\u0131n\u0131 de\u011fi\u015ftirmek i\u00e7in kullan\u0131lan \u00f6zel bir fonksiyondur. Bu fonksiyon, bir paketin tan\u0131m\u0131ndaki \u00f6zellikleri de\u011fi\u015ftirmek ve g\u00fcncellemek i\u00e7in kullan\u0131l\u0131r. <code>overrideAttrs</code> fonksiyonu, paketin derleme (build) s\u00fcreci, ba\u011f\u0131ml\u0131l\u0131klar, isim ve di\u011fer \u00f6zellikleri \u00fczerinde de\u011fi\u015fiklikler yapma yetene\u011fi sa\u011flar.</p> <p>Temel kullan\u0131m \u015fu \u015fekildedir:</p> <pre><code>overrideAttrs (oldAttrs: {\n  // Yeni \u00f6zellikleri veya de\u011fi\u015fiklikleri tan\u0131mla\n})\n</code></pre> <p>Bu ifadede:</p> <ul> <li><code>oldAttrs</code>: Orijinal paket tan\u0131m\u0131ndaki \u00f6zellikleri temsil eden bir de\u011fi\u015fken.</li> <li><code>{ ... }</code>: De\u011fi\u015ftirilecek veya eklenen \u00f6zellikleri i\u00e7eren bir set.</li> </ul> <p>\u0130\u015fte bir \u00f6rnek:</p> <pre><code># Orijinal paket tan\u0131m\u0131\nmyPackage = pkgs.stdenv.mkDerivation {\n  name = \"myPackage\";\n  version = \"1.0\";\n  src = ./mySource;\n};\n\n# overrideAttrs ile paket tan\u0131m\u0131n\u0131 de\u011fi\u015ftirme\nmyUpdatedPackage = myPackage // (oldAttrs: {\n  name = \"myUpdatedPackage\";\n  buildInputs = [ pkgs.gcc ];\n});\n</code></pre> <p>Bu \u00f6rnekte, <code>overrideAttrs</code> fonksiyonu, <code>myPackage</code> adl\u0131 paketin tan\u0131m\u0131n\u0131 al\u0131r ve <code>name</code> \u00f6zelli\u011fini <code>\"myUpdatedPackage\"</code> olarak, <code>buildInputs</code> \u00f6zelli\u011fini ise <code>[ pkgs.gcc ]</code> olarak de\u011fi\u015ftirir.</p> <p><code>overrideAttrs</code> fonksiyonu, paket tan\u0131mlamalar\u0131n\u0131 g\u00fcncelleme ve \u00f6zelle\u015ftirme a\u00e7\u0131s\u0131ndan olduk\u00e7a g\u00fc\u00e7l\u00fc bir ara\u00e7t\u0131r. Bu sayede paketlerin derleme s\u00fcre\u00e7leri, ba\u011f\u0131ml\u0131l\u0131klar\u0131 veya di\u011fer \u00f6zellikleri \u00fczerinde ihtiya\u00e7 duyulan de\u011fi\u015fiklikler kolayl\u0131kla yap\u0131labilmektedir.</p> <p>Nix dilinde override fonksiyonu kullan\u0131m\u0131na benzer \u015fekilde ba\u015fka override fonksiyonlar\u0131 da bulunmaktad\u0131r. Bunlar, \u00f6zellikle paket tan\u0131mlamalar\u0131n\u0131, derivasyonlar\u0131 (build), ba\u011f\u0131ml\u0131l\u0131klar\u0131 ve di\u011fer \u00f6zellikleri de\u011fi\u015ftirmek veya geni\u015fletmek i\u00e7in kullan\u0131l\u0131r. \u0130\u015fte baz\u0131 \u00f6rnekler:</p> <ol> <li><code>overrideDerivation</code>: Bu fonksiyon, derivasyon tan\u0131m\u0131n\u0131 de\u011fi\u015ftirmek i\u00e7in kullan\u0131l\u0131r. Derivasyon, bir paketin derleme s\u00fcrecini ve di\u011fer ilgili \u00f6zellikleri tan\u0131mlayan bir yap\u0131d\u0131r.</li> </ol> <pre><code>myDerivation = pkgs.stdenv.mkDerivation {\n  name = \"myPackage\";\n  version = \"1.0\";\n  src = ./mySource;\n};\n\nmyUpdatedDerivation = pkgs.stdenv.overrideDerivation myDerivation (drv: {\n  builder = ./myCustomBuilder.sh;\n});\n</code></pre> <ol> <li><code>overrideAttrs</code>: Paket tan\u0131m\u0131ndaki \u00f6zellikleri de\u011fi\u015ftirmek i\u00e7in kullan\u0131l\u0131r. Bu, <code>override</code> ifadesiyle benzerdir.</li> </ol> <pre><code>myPackage = pkgs.stdenv.mkDerivation {\n  name = \"myPackage\";\n  version = \"1.0\";\n  src = ./mySource;\n};\n\nmyUpdatedPackage = myPackage // (oldAttrs: {\n  name = \"myUpdatedPackage\";\n  buildInputs = [ pkgs.gcc ];\n});\n</code></pre> <ol> <li><code>overrideDrv</code>: Bu fonksiyon, derivasyon tan\u0131m\u0131n\u0131 (build s\u00fcrecini) de\u011fi\u015ftirmek i\u00e7in kullan\u0131l\u0131r.</li> </ol> <pre><code>myDerivation = pkgs.stdenv.mkDerivation {\n  name = \"myPackage\";\n  version = \"1.0\";\n  src = ./mySource;\n};\n\nmyUpdatedDerivation = pkgs.stdenv.overrideDrv myDerivation (drv: {\n  builder = ./myCustomBuilder.sh;\n});\n</code></pre> <p>Bu fonksiyonlar, Nix dilinde paket tan\u0131mlamalar\u0131n\u0131 daha esnek ve \u00f6zelle\u015ftirilebilir hale getirmek i\u00e7in kullan\u0131l\u0131r. Asl\u0131nda normal bir programalama dilinde bir listeye elemen ekleme, \u00e7\u0131kartma ve ya de\u011fi\u015ftirme i\u015flemleri gibi d\u00fc\u015f\u00fcnebiliriz. Override kelimesi genellikle standart programlama dillerinde bir fonksiyonun ezilmesi/yeniden tan\u0131mlanas\u0131 olarak kullan\u0131l\u0131r.</p> <p>Nix tabi farketti\u011finiz gibi tamamen bir paket yonetimi ve sistem konfig\u00fcrasyonu \u00fczerine geli\u015ftirilmi\u015f bir dil. Dolay\u0131s\u0131yla buradaki kavramlar asl\u0131nda \u00e7ok i\u015f yapmas\u0131na ra\u011fmen asl\u0131nda kullan\u0131m\u0131 ve anlamas\u0131 \u00e7ok kolay. Ancak \u015fu bir ger\u00e7ek ki bizim \u00e7ok basit bir \u015fekilde de\u011fi\u015ftirdi\u011fimiz (override) bir attribute b\u00fct\u00fcn bir sistemin tekrar olu\u015fturulmas\u0131na sebep olabilir. Bu nedenle bu tabirler b\u00fcy\u00fck b\u00fcy\u00fck kelimelerle anlat\u0131l\u0131yor. Birde sonu\u00e7ta bir object-oriented bir dil de\u011fil Nix. Ancak geli\u015ftirdikleri kurgulara da bir isim vermeleri gerekiyor ve burada ama\u00e7 sadece bir de\u011fi\u015fkenin de\u011ferini de\u011fi\u015ftirmi\u015f olmak de\u011fil.</p>","text":""},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#overlay","title":"Overlay <p>Override sadece local mod\u00fcl\u00fc ve dosyay\u0131 de\u011fi\u015ftirebilir. Overlay ise daha global'dir birden fazla mod\u00fcl\u00fc veya paketi de\u011fi\u015ftirebilir .Genellikle overlay.nix dosyalar\u0131na yaz\u0131larak import edilir.</p> <p><code>overlay</code> kavram\u0131n\u0131 \u00f6rneklerle a\u00e7\u0131klayal\u0131m. <code>overlay</code> genellikle birden fazla set veya mod\u00fcl tan\u0131m\u0131n\u0131 birle\u015ftirmek veya bir konfig\u00fcrasyonu de\u011fi\u015ftirmek i\u00e7in kullan\u0131l\u0131r. \u0130\u015fte birka\u00e7 \u00f6rnek:</p> <ol> <li>Birden Fazla Set'i Birle\u015ftirme:</li> </ol> <pre><code># Birinci set tan\u0131m\u0131\nfirstSet = {\n  package1 = {\n    name = \"package1\";\n    version = \"1.0\";\n  };\n};\n\n# \u0130kinci set tan\u0131m\u0131\nsecondSet = {\n  package2 = {\n    name = \"package2\";\n    version = \"2.0\";\n  };\n};\n\n# overlay ile set'leri birle\u015ftirme\nmergedSets = pkgs.lib.composeExtensions [\n  firstSet\n  secondSet\n];\n\n# mergedSets i\u00e7indeki paketlere eri\u015fim\nmergedSets.package1.version  # \"1.0\"\nmergedSets.package2.version  # \"2.0\"\n</code></pre> <p>Bu \u00f6rnekte, <code>pkgs.lib.composeExtensions</code> fonksiyonu ile iki set (<code>firstSet</code> ve <code>secondSet</code>) birle\u015ftirilmi\u015f ve <code>mergedSets</code> adl\u0131 yeni bir set olu\u015fturulmu\u015ftur.</p> <ol> <li>Paket Tan\u0131mlamalar\u0131n\u0131 De\u011fi\u015ftirme:</li> </ol> <pre><code># Orijinal paket tan\u0131mlamalar\u0131\npackage1 = pkgs.stdenv.mkDerivation {\n  name = \"package1\";\n  version = \"1.0\";\n};\n\npackage2 = pkgs.stdenv.mkDerivation {\n  name = \"package2\";\n  version = \"2.0\";\n};\n\n# overlay ile paket tan\u0131mlamalar\u0131n\u0131 de\u011fi\u015ftirme\noverlayPackages = pkgs.lib.composeExtensions [\n  (self: super: {\n    package1 = super.package1 // (oldAttrs: {\n      version = \"1.1\";\n    });\n    package2 = super.package2 // (oldAttrs: {\n      version = \"2.1\";\n    });\n  })\n];\n\n# overlayPackages i\u00e7indeki paketlere eri\u015fim\noverlayPackages.package1.version  # \"1.1\"\noverlayPackages.package2.version  # \"2.1\"\n</code></pre> <p>Bu \u00f6rnekte, <code>pkgs.lib.composeExtensions</code> fonksiyonu ile iki paket tan\u0131m\u0131 (<code>package1</code> ve <code>package2</code>) birle\u015ftirilmi\u015f ve <code>overlayPackages</code> adl\u0131 yeni bir set olu\u015fturulmu\u015ftur. Her iki paketin versiyonu overlay ile de\u011fi\u015ftirilmi\u015ftir.</p> <p><code>overlay</code> kullan\u0131m\u0131, Nix dilinde mod\u00fcler ve \u00f6zelle\u015ftirilebilir konfig\u00fcrasyonlar olu\u015fturmak i\u00e7in \u00f6nemli bir ara\u00e7t\u0131r. Bu, farkl\u0131 paket tan\u0131mlamalar\u0131n\u0131 birle\u015ftirerek veya de\u011fi\u015ftirerek projenin ihtiya\u00e7lar\u0131na uygun bir yap\u0131 olu\u015fturmay\u0131 sa\u011flar.</p> <p>Overlay'ler genellikle d\u0131\u015f nix dosylalar\u0131 import edilerek kullan\u0131l\u0131r.</p> <p>genellikle <code>overlay.nix</code> dosyalar\u0131, Nix projelerinde overlay'lerin tan\u0131mland\u0131\u011f\u0131 ve organizasyon sa\u011flad\u0131\u011f\u0131 yerlerdir. Bu dosyalar, projenin k\u00f6k dizininde yer alabilir ve projenin genel konfig\u00fcrasyonunu, paket tan\u0131mlamalar\u0131n\u0131 veya di\u011fer \u00f6zellikleri de\u011fi\u015ftirmek i\u00e7in kullan\u0131labilir. <code>overlay.nix</code> dosyalar\u0131n\u0131n ad\u0131 genellikle standartla\u015fm\u0131\u015f bir \u015fekilde kullan\u0131l\u0131r, ancak adland\u0131rma konvansiyonlar\u0131na kat\u0131lmak zorunlu de\u011fildir.</p> <p>A\u015fa\u011f\u0131da, bir projede <code>overlay.nix</code> dosyas\u0131n\u0131 kullanarak overlay tan\u0131mlamak i\u00e7in basit bir \u00f6rnek bulunmaktad\u0131r:</p> <ol> <li><code>overlay.nix</code> Dosyas\u0131:</li> </ol> <pre><code># overlay.nix\n\nself: super: {\n  package1 = super.package1 // (oldAttrs: {\n    version = \"1.1\";\n  });\n\n  package2 = super.package2 // (oldAttrs: {\n    version = \"2.1\";\n  });\n}\n</code></pre> <p>Bu <code>overlay.nix</code> dosyas\u0131, <code>package1</code> ve <code>package2</code> adl\u0131 iki paketin versiyonlar\u0131n\u0131 de\u011fi\u015ftirmek i\u00e7in bir overlay tan\u0131mlar.</p> <ol> <li>Projedeki Kullan\u0131m:</li> </ol> <p>Proje k\u00f6k dizininde bu <code>overlay.nix</code> dosyas\u0131 bulunuyorsa, projenin di\u011fer b\u00f6l\u00fcmlerinde bu overlay'leri kullanmak olduk\u00e7a kolayd\u0131r.</p> <pre><code># default.nix veya ba\u015fka bir nix dosyas\u0131\n\nlet\n  overlays = import ./overlay.nix;\nin\n\n{\n  inherit (overlays) package1 package2;\n}\n</code></pre> <p>Bu \u00f6rnekte, <code>import ./overlay.nix;</code> ifadesi ile <code>overlay.nix</code> dosyas\u0131ndaki overlay'leri i\u00e7e aktar\u0131yoruz ve ard\u0131ndan bu overlay'leri <code>inherit</code> ifadesi ile projenin genel konfig\u00fcrasyonuna ekliyoruz.</p> <p>Bu kullan\u0131m, projenin temel konfig\u00fcrasyonunu <code>overlay.nix</code> dosyas\u0131na ta\u015f\u0131yarak, projenin \u00e7e\u015fitli b\u00f6l\u00fcmlerinde bu overlay'leri kullanmay\u0131 kolayla\u015ft\u0131r\u0131r ve organizasyonu art\u0131r\u0131r. Ayr\u0131ca, bu sayede overlay'leri projenin di\u011fer k\u0131s\u0131mlar\u0131na uygulamak daha tutarl\u0131 ve y\u00f6netilebilir hale gelir.</p>","text":""},{"location":"nix_lang/01_nix_dili_ve_ozellikleri.html#referanslar","title":"Referanslar <ul> <li>https://nix.dev/tutorials/first-steps/</li> <li>https://nixos.org/guides/nix-pills/</li> <li>https://nixos.org/guides/how-nix-works</li> <li>https://nixos.org/manual/nix/unstable/language/operators.html</li> <li>https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55</li> <li>https://en.wikipedia.org/wiki/Nix_(package_manager)</li> <li>https://nix.dev/concepts/faq</li> </ul>","text":""},{"location":"nix_lang/02_nix_dili_alistirmalari.html","title":"Nix Dili ile \u0130lgili Al\u0131\u015ft\u0131rmalar","text":"<p>Bu yaz\u0131da ilk makalede \u00e7ok h\u0131zl\u0131 de\u011findi\u011fimiz Nix dilini aktif olarak kullanmak. Tamamen syntax ve dil \u00f6zelliklerine de\u011finece\u011fiz. Herhangi bir k\u00fct\u00fcphane ve paket kullanmayaca\u011f\u0131z.</p> <p>Belki ilk etapta Nix paket y\u00f6neticisini veya NixOS'u kullan\u0131rken ba\u015ftan sonra s\u0131f\u0131rdan bir \u015feyler yazmayaca\u011f\u0131z, b\u00fcy\u00fck ihtimal bir \u00e7o\u011fumuz i\u00e7in sadece NixOS'a paketlerimizi kurmak yeterli olacak. Ancak haz\u0131r kodlar\u0131 al\u0131p kullan\u0131rken bile kodun ne yapmaya \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 anlamak isteyeceksiniz.</p>"},{"location":"nix_lang/02_nix_dili_alistirmalari.html#nix-kurulumu-ve-repl","title":"Nix Kurulumu ve repl","text":"<p>NixOS d\u0131\u015f\u0131nda herhangi bir Linux distribution'da kurulum i\u00e7in sadece alttaki komutu \u00e7al\u0131\u015ft\u0131rmak yetecektir.</p> <pre><code>sh &lt;(curl -L https://nixos.org/nix/install) --daemon\n</code></pre> <p>Amac\u0131m\u0131z sadece dili biraz \u00f6\u011frenmek uzman\u0131 olmak de\u011fil. Bir nix dosyas\u0131na bakt\u0131\u011f\u0131m\u0131zda onu anlamak, iste\u011fimize g\u00f6re de\u011fi\u015fiklikler yapabilmek. Kendi nix dosyalar\u0131m\u0131z\u0131 yazmaya ba\u015flad\u0131\u011f\u0131m\u0131zda zaten dilde ilerlemek m\u00fcmk\u00fcn olacak. S\u0131kl\u0131kla dok\u00fcmanlara bakarak di\u011fer kullan\u0131c\u0131lar\u0131n dosyalar\u0131n\u0131 inceleyerek kendimizi geli\u015ftirece\u011fiz.</p> <p>Terminalde nix repl yazarak nix-repl uygulamas\u0131n\u0131 \u00e7al\u0131\u015ft\u0131r\u0131yoruz. Bundan sonra altta bahsetti\u011fimiz b\u00fct\u00fcn komutlar\u0131 bu komut ekran\u0131nda \u00e7al\u0131\u015ft\u0131raca\u011f\u0131z. Art\u0131k \u00f6rnek uygulamalarla dili biraz daha peki\u015ftirmeye \u00e7al\u0131\u015fal\u0131m.</p>"},{"location":"nix_lang/02_nix_dili_alistirmalari.html#nix-file-kullanm-ve-ornek-uygulamalar","title":"Nix File Kullan\u0131m\u0131 ve \u00d6rnek Uygulamalar","text":"<p>Yukar\u0131daki baz\u0131 ba\u015fl\u0131klar\u0131 sadece okuyarak anlamak zorunda kald\u0131k \u00e7\u00fcnk\u00fc dosyalar\u0131 dolay\u0131s\u0131yla da mod\u00fclleri kullanamad\u0131k</p> <p>Nix-repl i\u00e7indeyken :? komutu ile yard\u0131m alabiliriz.</p> <pre><code>:?\nThe following commands are available:\n\n  &lt;expr&gt;                       Evaluate and print expression\n  &lt;x&gt; = &lt;expr&gt;                 Bind expression to variable\n  :a, :add &lt;expr&gt;              Add attributes from resulting set to scope\n  :b &lt;expr&gt;                    Build a derivation\n  :bl &lt;expr&gt;                   Build a derivation, creating GC roots in the\n                               working directory\n  :e, :edit &lt;expr&gt;             Open package or function in $EDITOR\n  :i &lt;expr&gt;                    Build derivation, then install result into\n                               current profile\n  :l, :load &lt;path&gt;             Load Nix expression and add it to scope\n  :lf, :load-flake &lt;ref&gt;       Load Nix flake and add it to scope\n  :p, :print &lt;expr&gt;            Evaluate and print expression recursively\n  :q, :quit                    Exit nix-repl\n  :r, :reload                  Reload all files\n  :sh &lt;expr&gt;                   Build dependencies of derivation, then start\n                               nix-shell\n  :t &lt;expr&gt;                    Describe result of evaluation\n  :u &lt;expr&gt;                    Build derivation, then start nix-shell\n  :doc &lt;expr&gt;                  Show documentation of a builtin function\n  :log &lt;expr&gt;                  Show logs for a derivation\n  :te, :trace-enable [bool]    Enable, disable or toggle showing traces for\n                               errors\n  :?, :help                    Brings up this help menu\n</code></pre> <p>:l komutunun bir nix doyas\u0131n\u0131 (daha do\u011frusu bniz ifadesini) load etti\u011fini g\u00f6rebiliyoruz.</p> <p>Repl'de biraz detaya girmek isterseniz \u015fu sayfay\u0131 tavsiye ederim.</p> <p>\u00d6ncelikle bir klas\u00f6r olu\u015ftural\u0131m ve i\u00e7ine default.nix ad\u0131nda bir dosya olu\u015ftural\u0131m. Bir tane de functions.niz ad\u0131nda bir dosya olu\u015ftural\u0131m. Bu dosyalar\u0131 olu\u015fturduktan sonra functions.nix dosyas\u0131na \u015fu kodlar\u0131 yazal\u0131m.</p> <p>Nix dilinde bir\u00e7ok builtin fonksiyon bulunmaktad\u0131r. Bunlar\u0131n bir\u00e7o\u011funu zaten g\u00f6rece\u011fiz. Altta bunlardan bir ka\u00e7\u0131n\u0131 g\u00f6rebilirsiniz. Ne yapt\u0131klar\u0131 belli oldu\u011fu i\u00e7in detaylar\u0131na girmiyorum. Zaten resmi sayfas\u0131ndan her biri hakk\u0131nda detayl\u0131 bilgi alabilirsiniz.</p> <pre><code># functions.nix\n{ numbers ? [1 2], strings ? [\"merhaba\" \"nas\u0131ls\u0131n\"] }:\n\nlet\n  sumNumbers = list: if builtins.length list  &gt; 0 then builtins.foldl' (x: y: x + y) 0 list else 0;\n  concatenateStrings = list: if builtins.length list  &gt; 0 then builtins.concatStringsSep \" \" list else \"\";\nin\n{\n  sumNumbers = sumNumbers numbers;\n  concatenateStrings = concatenateStrings strings;\n}\n</code></pre> <p>\u00dcstteki kodda <code>builtins.foldl'</code> fonksiyonunun ad\u0131 hakikaten b\u00f6yle bu arada. Yani ad\u0131nda bir apostrof var.</p> <ul> <li>builtins.foldl' fonksiyonu, bir listenin elemanlar\u0131na bir fonksiyon uygular</li> <li>x: \u00f6nceki toplam de\u011feri, y: mevcut eleman</li> <li>0: ba\u015flang\u0131\u00e7 de\u011feri</li> </ul> <p>sumNumbers ise asl\u0131nda bir fonksion ve parametre olarak bir liste al\u0131yor. \u00d6rne\u011fin alttaki \u00f6rnekte 2 parametreli bir \u00f6rnek g\u00f6rebiliriz.</p> <pre><code># 2 parametreli \u00f6rnek\ntoplama = a: b: a + b\n\ntoplama 1 2\n\n# sonu\u00e7\n3\n</code></pre> <p>default.nix doyas\u0131 i\u00e7eri\u011fi de alttaki gibi olacak.</p> <pre><code># default.nix\n\nlet\n  functions = import ./functions.nix;\nin\n{\n  result = functions { numbers = [1 2 3 4];   strings = [\"Hello\" \" \" \"Nix\"];};\n}\n</code></pre> <p>\u00d6ncelikle repl i\u00e7inden functions.nix dosyas\u0131n\u0131 load edelim. \u00f6ncelikle absolute path'i al\u0131yoruz. daha sonra bunu import edip kullan\u0131yoruz.</p> <pre><code># path al\u0131n\u0131yor\nfunctionsPath = ./functions.nix\n\nfunctions = import functionsPath\n</code></pre> <p>Ard\u0131ndan functions nesnesini \u00e7a\u011f\u0131ral\u0131m</p> <pre><code>functions { numbers = [1 2 3 4]; strings = [\"Hello\" \" \" \"Nix\"]; }\n\n# ve sonuc\n\n{ concatenateStrings = \"Hello   Nix\"; sumNumbers = 10; }\n</code></pre> <p>Burada \u015funu hat\u0131rlamam\u0131zda fayda var. Nix bir fonksiyonel programlama dili. Buda functions nesnesi asl\u0131nda bir fonksiyon ve functions { numbers = [1 2 3 4]; strings = [\"Hello\" \" \" \"Nix\"]; } sat\u0131r\u0131 ile bu fonksiyonu \u00e7a\u011f\u0131rm\u0131\u015f oluyoruz. fonksiyon da bize bir set d\u00f6n\u00fcyor ve i\u00e7inde de concatenateStrings ve sumNumbers de\u011fi\u015fkenleri var.</p> <p>functions.nix dosyas\u0131n\u0131 biraz daha inceleyelim. sumNumbers = list: if builtins.length list &gt; 0 then builtins.foldl' (x: y: x + y) 0 list else 0; blo\u011funu anlamak i\u00e7in alttaki gibi yaz\u0131yoruz.</p> <pre><code># Fonksiyon tan\u0131m\u0131\nsumNumbers = list:\n\n# E\u011fer liste bo\u015f de\u011filse\nif builtins.length list &gt; 0 then\n  # builtins.foldl' fonksiyonu, bir listenin elemanlar\u0131na bir fonksiyon uygular\n  # x: \u00f6nceki toplam de\u011feri, y: mevcut eleman\n  # 0: ba\u015flang\u0131\u00e7 de\u011feri\n  builtins.foldl' (x: y: x + y) 0 list\nelse\n  # E\u011fer liste bo\u015fsa, toplam de\u011feri 0 olarak d\u00f6nd\u00fcr\n  0;\n</code></pre> <p>\u015eimdi kald\u0131\u011f\u0131m\u0131z yerden yani default.nix dosyas\u0131yla devam edelim.</p> <p>repl i\u00e7inden bu sefer default.nix dosyam\u0131z\u0131 y\u00fckleyelim.</p> <pre><code>:l ./default.nix\n\n# sonu\u00e7\nAdded 1 variables.\n</code></pre> <p>Art\u0131k result de\u011fi\u015fkenimizin sonucunu g\u00f6rebiliriz</p> <pre><code>result\n{ concatenateStrings = \"Hello   Nix\"; sumNumbers = 10; }\n</code></pre> <p>Daha basit \u00f6rnek \u00fczerinden devam edelim.</p> <p>calculator.nix ad\u0131ndan bir dosya olu\u015fturup alttaki kodlar\u0131 kopyalayal\u0131m.</p> <pre><code>let\n  numbers = {number1 = 10; number2 = 20;};\n  sum = x: y: x + y;\n  mul = x: y: x * y;\n\nin\n{\n  sum = sum numbers.number1 numbers.number2;\n  mul = mul numbers.number1 numbers.number2;\n}\n</code></pre> <p>Daha sonra kodumuzu test etmek i\u00e7in nix repl komutu repl'i a\u00e7\u0131p alttaki kodlar\u0131 \u00e7al\u0131\u015ft\u0131ral\u0131m.</p> <pre><code>calcPath = ./calculator.nix\n\ncalc = import calcPath\n\ncalc\n# sonu\u00e7\n{ mul = 200; sum = 30; }\n</code></pre> <p>Bu haliyle calculator.nix dosyas\u0131 sadece \u00fczerindeki kodu \u00e7al\u0131\u015ft\u0131r\u0131yor. Yani kendi rakamlar\u0131m\u0131zla toplama veya \u00e7arpma yapam\u0131yo\u0131ruz.</p> <p>\u015eimdi bu kodu biraz daha geli\u015ftirelim. \u00d6rne\u011fin calculator.nix dosyas\u0131n\u0131 bir fonksiyon olarak yazal\u0131m. Soru i\u015fareti default de\u011feri atam\u0131\u015f oluyoruz.</p> <pre><code># calculator.nix\n\n{ number1 ? 10, number2 ? 20 }:\n\nlet\n  sum = x: y: x + y;\n  mul = x: y: x * y;\nin\n{\n  sum = sum number1 number2;\n  mul = mul number1 number2;\n}\n</code></pre> <p>Art\u0131k yazd\u0131\u011f\u0131m\u0131z fonksiyonu repl i\u00e7inden \u00e7a\u011f\u0131rabiliriz.</p> <pre><code>calc = import ./calculator.nix\n\nresult = calc { number1 = 30; number2 = 40; }\n\nresult\n# sonu\u00e7\n{ mul = 1200; sum = 70; }\n</code></pre> <p>\u015fimdi bu dosyay\u0131 main.nix dosyas\u0131ndan \u00e7a\u011f\u0131ral\u0131m. main.nix dosyas\u0131 i\u00e7eri\u011fi alttaki gibi olacak.</p> <pre><code>let\n  calc = import ./calculator.nix;\n  result = calc { number1 = 30; number2 = 40; };\nin\n{\n  inherit result;\n}\n</code></pre> <p>Inherit anahtar kelimesini hat\u0131rlarsan\u0131z let blo\u011fundaki de\u011fi\u015fkenleri inherit ile d\u0131\u015far\u0131ya aktarabilmemizi sa\u011fl\u0131yordu.</p> <p>repl i\u00e7inden main.nix dosyas\u0131n\u0131 y\u00fckleyelim.</p> <pre><code>main = import ./main.nix\n\nmain.result\n# sonu\u00e7\n{ mul = 1200; sum = 70; }\n</code></pre> <p>\u015eimdi calculator mod\u00fcl\u00fcm\u00fcz\u00fc biraz daha karma\u015f\u0131k hale getirelim. calcSet de\u011fi\u015fkeninden sonra gelen soru i\u015fareti e\u011fer set i\u00e7in d\u0131\u015far\u0131dan bir de\u011fer gelmezse default de\u011ferin atanmas\u0131n\u0131 sa\u011fl\u0131yor. Onlarda zaten sumSet ve numSet de\u011fi\u015fkenleri.</p> <pre><code>{\n  calcSet ? {\n    sumSet = { numbers = { number1 = 10; number2 = 20; }; message = \"\"; };\n    mulSet = { numbers = { number1 = 10; number2 = 20; }; message = \"\"; };\n    }\n}:\nlet\n  sum = x: y: x + y;\n  mul = x: y: x * y;\n\n\n\nin\n{\n  sum = sum calcSet.sumSet.numbers.number1  calcSet.sumSet.numbers.number2;\n  mul = mul calcSet.mulSet.numbers.number1  calcSet.mulSet.numbers.number2;\n}\n</code></pre> <p>Art\u0131k veri yap\u0131m\u0131z i\u00e7 i\u00e7e set'lerden olu\u015fuyor. Repl \u00fczerinde alttaki komutlarla sonu\u00e7lar\u0131 g\u00f6rebiliriz.</p> <p>Bu sefer calc fonksiyonumuza parametre ge\u00e7medik.</p> <pre><code>calc = import ./calculator.nix\n\nresult = calc {}\n# sonu\u00e7\n{ mul = 200; sum = 30; }\n</code></pre> <p>\u015eimdi \u00f6rne\u011fi biraz daha geli\u015ftirelim. \"Overriding\" kavram\u0131n\u0131 da nix dosyalar\u0131 \u00fczerinden g\u00f6rm\u00fc\u015f olaca\u011f\u0131z.</p> <p>Alttaki kodu calculator.nix dosyam\u0131za kopyal\u0131yoruz. Daha do\u011frusu \u00f6nceki dosyam\u0131z\u0131n i\u00e7eri\u011fini alttaki kodla de\u011fi\u015ftiriyoruz.</p> <p>\u0130lk bak\u0131\u015fta kar\u0131\u015f\u0131k geldi\u011finin fark\u0131nday\u0131m ama asl\u0131nda \u00e7ok basit bir mant\u0131\u011f\u0131 var. \u00d6ncelikle ilk makalede bahsetti\u011fimiz dile ait bir \u00f6zelli\u011fi hat\u0131rlatmada fayda var. Nix dilinde bir de\u011fi\u015fkenin de\u011feri bir kere atand\u0131ktan sonra de\u011fi\u015ftirilemez. Yani immutable. Bu durumda bir de\u011fi\u015fkenin de\u011ferini de\u011fi\u015ftirmek istedi\u011fimizde asl\u0131nda yeni bir de\u011fi\u015fken olu\u015fturuyoruz.</p> <pre><code>{\n  calcSet ? {\n    sumSet = { numbers = { number1 = 10; number2 = 20; }; sumResult = 0; };\n    mulSet = { numbers = { number1 = 10; number2 = 20; }; mulResult = 0; };\n    }\n}:\nlet\n  sum = x: y: x + y;\n  mul = x: y: x * y;\n\n  sumResult = sum calcSet.sumSet.numbers.number1  calcSet.sumSet.numbers.number2;\n  mulResult = mul calcSet.mulSet.numbers.number1  calcSet.mulSet.numbers.number2;\n  result = calcSet // { sumSet = calcSet.sumSet // {sumResult = sumResult; }; mulSet = calcSet.mulSet // { mulResult = mulResult; };};\n\nin\n{\n   result = result;\n}\n</code></pre> <p>\u00d6rnekteki <code>result = calcSet // { sumSet = calcSet.sumSet // {sumResult = sumResult; }; mulSet = calcSet.mulSet // { mulResult = mulResult; };};</code> sat\u0131r\u0131 ile sumSet ve mulSet de\u011fi\u015fkenlerinin i\u00e7indeki sumResult ve mulResult de\u011fi\u015fkenlerini de\u011fi\u015ftirmi\u015f oluyoruz. \"//\" operat\u00f6r\u00fcn\u00fc hat\u0131rlarsan\u0131z sa\u011fdaki seti soldaki sete override ediyordu. Yani soldaki setin de\u011ferlerini sa\u011fdaki setin de\u011ferleriyle de\u011fi\u015ftiriyordu. Yada farkl\u0131 etiketli veriler varsa bunlarda ekleniyordu. Bu sat\u0131rda amac\u0131m\u0131z mulResult de\u011ferlerini de\u011fi\u015ftirmek dolay\u0131s\u0131yla di\u011fer b\u00fct\u00fcn de\u011ferlerin kalmas\u0131n\u0131 istiyoruz. Bu da di\u011fer de\u011ferleri yeni olu\u015fturdu\u011fumuz sete ta\u015f\u0131mam\u0131z gerekti\u011fi anlam\u0131na geliyor.</p> <p>Kodumuzu nix-repl ile \u00e7al\u0131\u015ft\u0131r\u0131yoruz. Repl i\u00e7indeyken alttaki komutlarla sonu\u00e7lar\u0131 g\u00f6rebiliriz.</p> <pre><code>calc = import ./calculator.nix\nCalcResult = calc{}\nCalcResult.result\n# result { mulSet = { ... }; sumSet = { ... }; }\nCalcResult.result.mulSet\n# result { mulResult = 200; numbers = { ... }; }\n</code></pre> <p>Kodumuzu biraz daha de\u011fi\u015ftirip with anahtar kelimesinin kullan\u0131m\u0131na bakal\u0131m. With anahtar kelimesi kullan\u0131lan set'i bir scope olarak size set i\u00e7indeki attribute'lara set'in ad\u0131n\u0131 tekrar tekrar yazmadan kullanman\u0131za olanak tan\u0131r. Alttaki \u00f6rnek \u00e7ok anlaml\u0131 gelmeyebilir. Ancak paket kullan\u0131mlar\u0131nda ve NixOS konfig\u00fcrasyonlar\u0131nda bir \u00e7ok paketin \u00f6zelli\u011fini de\u011fi\u015ftirmek durumunda olaca\u011f\u0131z. Bu gibi yerlerde ayn\u0131 kelimeyi y\u00fczlerce kez tekrar etmek hem vakit kayb\u0131 hem de okumay\u0131 zorla\u015ft\u0131r\u0131yor.</p> <p>In blo\u011fu i\u00e7indeki resul de\u011fi\u015fkenine bakacak olursak with calcResult; sat\u0131r\u0131 ile calcResult de\u011fi\u015fkenini scope olarak tan\u0131mlam\u0131\u015f oluyoruz. Bu sayede sumResult ve mulResult de\u011fi\u015fkenlerinin ba\u015f\u0131nda calcResult kelimesini tekrar kullanmak zorunda kalmad\u0131k.</p> <pre><code>{\n  calcSet ? {\n    sumSet = { numbers = { number1 = 10; number2 = 20; }; sumResult = 0; };\n    mulSet = { numbers = { number1 = 10; number2 = 20; }; mulResult = 0; };\n    }\n}:\nlet\n  sum = x: y: x + y;\n  mul = x: y: x * y;\n\n  calcResult = {\n                  sumResult = with calcSet; sum sumSet.numbers.number1  sumSet.numbers.number2;\n                  mulResult = with calcSet; mul mulSet.numbers.number1  mulSet.numbers.number2;\n                  allResult = calcSet // {\n                                            sumSet = calcSet.sumSet // {sumResult = sumResult; };\n                                            mulSet = calcSet.mulSet // { mulResult = mulResult;};\n                                          };\n\n              };\nin\n{\n   result = with calcResult;[sumResult mulResult (if sumResult&gt;mulResult\n                                                    then \"toplama sonucu \u00e7arpmadan daha b\u00fcy\u00fck\"\n                                                    else \"\u00e7arpma sonucu toplamadan daha b\u00fcy\u00fck\")\n                            ];\n}\n</code></pre> <p>Sonucu g\u00f6rmek i\u00e7in repl i\u00e7inden alttaki komutlar\u0131 \u00e7al\u0131\u015ft\u0131rabiliriz.</p> <pre><code>calc = import ./calculator.nix\n\nresult = calc{}\n\nresult.result\n\n# sonu\u00e7 [ 30 200 \"\u00e7arpma sonucu toplamadan daha b\u00fcy\u00fck\" ]\n</code></pre> <p>Bu arada biraz ara\u015ft\u0131rd\u0131\u011f\u0131n\u0131zda di\u011fer kullan\u0131c\u0131lar\u0131n yazm\u0131\u015f olduklar\u0131 nix dosyalar\u0131nda with kullan\u0131m\u0131n\u0131n \u00e7ok yayg\u0131n oldu\u011funu g\u00f6rebilirsiniz. Ancak genellikle paket kullan\u0131m\u0131 ile ilgili oldu\u011funu g\u00f6receksiniz. Bunun d\u0131\u015f\u0131nda kullan\u0131m\u0131 \u00e7ok tavsiye edilmiyor. En b\u00fcy\u00fck sebepleri ise namespace yap\u0131s\u0131n\u0131 bozmas\u0131, hataya \u00e7ok a\u00e7\u0131k olmas\u0131 ve kodun okunabilirli\u011fini azaltmas\u0131 diyebiliriz.</p> <p>Di\u011fer bilinmesi gereken bir konu da with'de scope'un d\u0131\u015f\u0131 \u00f6nceliklidir. Yani with anahtar s\u00f6zc\u00fc\u011f\u00fc set d\u0131\u015f\u0131n\u0131 override etmez. \u00d6rnekle daha iyi anlayaca\u011f\u0131z.</p> <pre><code>let\n  myattrset = { a = 1; b = 2; };\nin\n  with myattrset; \"a'n\u0131n de\u011feri: ${toString a} ve b'nin de\u011feri:  ${toString b}\"\n</code></pre> <p>Bu yaz\u0131mda myattrset kelimesini a ve b elemanlar\u0131n\u0131n ba\u015f\u0131na yazmadan kullanabildik. Buradan d\u00f6necek de\u011fer <code>a'n\u0131n de\u011feri: 1 ve b'nin de\u011feri: 2</code> \u015feklinde olacakt\u0131r. Bu zaten bekledi\u011fimiz bi durum. \u015eimdi alttaki kodu inceleyelim.</p> <pre><code>let\n  a = 3;\nin\n  with { a = 1; b = 2; }; \"a'n\u0131n de\u011feri: ${toString a} ve b'nin de\u011feri:  ${toString b}\"\n</code></pre> <p>Buran\u0131n sonucu ise <code>a'n\u0131n de\u011feri: 3 ve b'nin de\u011feri: 2</code> olacakt\u0131r. G\u00f6rd\u00fc\u011f\u00fcn\u00fcz \u00fczere burada scop d\u0131\u015f\u0131ndaki a'n\u0131n de\u011feri hala ge\u00e7erlidir. Yani Nix dili shadow variable kullan\u0131m\u0131na izin vermez.</p> <p>\u0130lerleyen yaz\u0131larda veya incelemelerinizde with anahtar s\u00f6zc\u00fc\u011f\u00fcn\u00fcn paketlerle ilgili i\u015flemlerde ne kadar \u00e7ok kullan\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6receksiniz. Community bunu \u00e7ok s\u0131k kullan\u0131yor \u00e7\u00fcnk\u00fc paketlerle alakal\u0131 i\u015flemlerde kodu daha okunabilir k\u0131l\u0131yor ve k\u0131salt\u0131yor. Di\u011fer bir fayda olarak <code>let myValue = ...; with lib; doSomethingWith myValue</code> gibi bir kod yazan developer do\u011fal olarak myvalue de\u011fi\u015fkeninin lib i\u00e7inde ezilmesini istemeyecektir.</p> <p>Shadow variable kullan\u0131m\u0131na bir tek nested with kullan\u0131m\u0131nda izin verilir. Alltaki \u00f6rnekte sonu\u00e7 inner olacakt\u0131r.</p> <pre><code>nix-repl&gt; with { x = \"outer\"; }; with { x = \"inner\"; }; x\n\"inner\"\n</code></pre>"},{"location":"nix_lang/02_nix_dili_alistirmalari.html#recursive-list-kullanm","title":"Recursive List Kullan\u0131m\u0131","text":"<p>Temel amac\u0131 set i\u00e7indeki herhangi bir elementin set i\u00e7indeki di\u011fer elementlerle birlikte kullan\u0131lmas\u0131n\u0131 sa\u011flamakt\u0131r.</p> <p>Ayr\u0131ca a\u011fa\u00e7 yap\u0131s\u0131nda bir veri yap\u0131s\u0131 olu\u015fturmak istedi\u011fimizde de kullanabiliriz.</p> <p>basit bir \u00f6rnekle ba\u015flayal\u0131m. Alttaki kodu rec.nix ad\u0131nda bir dosyaya kopyalayal\u0131m.</p> <p>mySet tan\u0131m\u0131na bakacak olursan\u0131z d de\u011fi\u015fkenine ait veri a de\u011fi\u015fkeninin bir artt\u0131r\u0131lmas\u0131yla olu\u015fturuluyor.</p> <pre><code>let\n\nmySet = rec {a= 1; b= 2; c= 3; d= a + 1;};\n\nin\n{\n   inherit mySet;\n}\n</code></pre> <p>kodu \u00e7al\u0131\u015ft\u0131rmak i\u00e7in repl i\u00e7inden alttaki komutlar\u0131 \u00e7al\u0131\u015ft\u0131rabiliriz.</p> <pre><code>:l ./rec.nix\n\n# Added 1 variables.\n mySet\n{ a = 1; b = 2; c = 3; d = 2; }\n</code></pre> <p>Daha karma\u015f\u0131k bir \u00f6rnek yapal\u0131m. Bu sefer bir a\u011fa\u00e7 yap\u0131s\u0131 olu\u015fturaca\u011f\u0131z. alttaki kodlar\u0131 family.nix ad\u0131nda bir dosyaya kopyalayal\u0131m.</p> <p>Dikkat ederseniz b\u00fct\u00fcn bireylerin soyadlar\u0131 lastname elementinden al\u0131nm\u0131\u015f. Annenin ya\u015f\u0131 babaya g\u00f6re ve \u00e7ocu\u011fun ya\u015f\u0131 da anneye g\u00f6re hesaplanm\u0131\u015f.</p> <p>Ayr\u0131ca birbirleriyle oan ili\u015fkileri de recursive list i\u00e7indeki di\u011fer element ile belirtilmi\u015f. \u00d6rne\u011fin baba elementi i\u00e7indeki wife elementi annenin kendisi. Ayn\u0131 \u015fekilde anne elementi i\u00e7indeki husband elementi baban\u0131n kendisi. \u00c7ocuk elementi i\u00e7indeki mother elementi annenin kendisi ve father elementi baban\u0131n kendisi.</p> <pre><code>let\n\n  family = rec {lastname = \"Y\u0131lmaz\";\n                father = {name=\"Mehmet\"; lastname=lastname; age = 40; wife = mother; child = child;};\n                mother = {name=\"Ay\u015fe\"; lastname=father.lastname; age = father.age - 3; husband = father; child = child;};\n                child = {name=\"Ali\"; lastname=mother.lastname; age = mother.age - 30; mother = mother; father = father;};\n                };\n\nin\n{\n   inherit family;\n}\n</code></pre> <p>\u00d6rne\u011fin baban\u0131n \u00e7ocu\u011funun annesinin ad\u0131n\u0131 almak i\u00e7in alttaki komutu \u00e7al\u0131\u015ft\u0131rabiliriz. \u00d6ncelikle repl</p> <pre><code>:l ./rec.nix\n\n# result Added 1 variables.\n\nfamily.father.child.mother.name\n\n# result \"Ay\u015fe\"\n</code></pre> <p>Bunu yapmam\u0131z\u0131 sa\u011flayan Nix dilinin laziness olmas\u0131d\u0131r. Bu sayede zaten dil i\u00e7indeki bir de\u011fi\u015fkenin de\u011feri hesaplanmadan ba\u015fka bir de\u011fi\u015fkende kullan\u0131labilir. Bu ayn\u0131 zamanda Nix dilinin \u00e7ok kuvvetli declarative bir dil olmas\u0131n\u0131 sa\u011fl\u0131yor.</p> <p>Bu arada bu durum mod\u00fcller import edilmesinde de ge\u00e7erlidir. Yani ayn\u0131 anda bir mod\u00fcl ba\u015fka bir mod\u00fcl\u00fc import ederken import edilen mod\u00fcl de import edeni import edebilir. B\u00f6yle yaz\u0131nca karma\u015f\u0131k geliyor ama asl\u0131nda \u00e7ok basit. Mesela \"A.nix\" dosyas\u0131 \"B.nix\" doyas\u0131n\u0131 import ederken \"B.nix\" dosyas\u0131 da \"A.nix\" doyas\u0131n\u0131 import edebilir.</p>"},{"location":"nix_lang/02_nix_dili_alistirmalari.html#nix-dilinde-loop-ve-recursive-fonksiyon-kullanm","title":"Nix Dilinde Loop ve Recursive Fonksiyon Kullan\u0131m\u0131","text":"<p>Nix dilinde bildi\u011fimiz anlamda di\u011fer dillerdeki gibi bir loop kavram\u0131 yoktur. Yani \u00f6rne\u011fin for, while, foreach gibi d\u00f6ng\u00fcleri kullanamay\u0131z. Ancak recursive fonksiyonlar kullanarak d\u00f6ng\u00fc mant\u0131\u011f\u0131n\u0131 olu\u015fturabiliriz. Altta recursive fonksiyon yaz\u0131l\u0131m\u0131n\u0131 g\u00f6rece\u011fiz ancak bu tabii ki \u00f6rne\u011fin bir listedeki elemanlar\u0131 dola\u015fmam\u0131z\u0131 sa\u011flamaz. Bunu i\u00e7in bir sonraki makalemizde paketlerin kullan\u0131m\u0131 ile birlikte loop kurgusunun da nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 g\u00f6rm\u00fc\u015f olaca\u011f\u0131z.</p> <p>Bunun i\u00e7in basit bir \u00f6rnek yapaca\u011f\u0131z. Amac\u0131m\u0131z verilen pozitif bir say\u0131ya kadar b\u00fct\u00fcn rakamlar\u0131n toplam\u0131n\u0131 almak.</p> <p>Bu sefer bir fonksiyon olarak tan\u0131mlayaca\u011f\u0131z.</p> <pre><code>{num? {num = 0;}}:\nlet\n    sumAll = num1: if num1 &lt; 1 then num1 else if  num1 &gt; 1 then num1 + sumAll (num1 - 1) else 1;\nin\n{\nresult = sumAll num.num;\n}\n</code></pre> <p>Test etmek i\u00e7in repl i\u00e7inden alttaki komutlar\u0131 \u00e7al\u0131\u015ft\u0131rabiliriz.</p> <pre><code>recursive = import ./recursive.nix\nresult = recursive(3)\n# result { result = 6; }\n</code></pre>"},{"location":"nix_lang/02_nix_dili_alistirmalari.html#formatter","title":"Formatter","text":"<p>Formetter'lar programlama dillerindeki ifadeleri d\u00fczenlemek ve bi\u00e7imlendirmek i\u00e7in kullan\u0131l\u0131r. Bu, kodumuzun okunabilirli\u011fini art\u0131r\u0131r ve genellikle kod taban\u0131nda tutarl\u0131l\u0131k sa\u011flamak i\u00e7in kullan\u0131l\u0131r.</p> <p>Nix ifadeleri, paketlerin ve sistem yap\u0131land\u0131rmas\u0131n\u0131n a\u00e7\u0131klanmas\u0131nda kullan\u0131lan bir dil oldu\u011fundan, kodun anla\u015f\u0131lmas\u0131 ve y\u00f6netilmesi i\u00e7in d\u00fczenli bir bi\u00e7imde tutulmas\u0131 \u00f6nemlidir. Formatter, bu t\u00fcr ifadeleri otomatik olarak bi\u00e7imlendirerek, kod taban\u0131n\u0131n bak\u0131m\u0131n\u0131 kolayla\u015ft\u0131r\u0131r ve farkl\u0131 geli\u015ftiriciler aras\u0131nda tutarl\u0131l\u0131k sa\u011flar. Bu, karma\u015f\u0131k sistem yap\u0131land\u0131rmalar\u0131n\u0131n veya paket setlerinin y\u00f6netilmesinde faydal\u0131d\u0131r.</p> <p>Formetter'lar daha \u00e7ok community deste\u011fiyle y\u00fcr\u00fcyor. Resmi Github sayfas\u0131 i\u00e7in \u015fu linki ziyaret edebilirsiniz.</p> <p>En \u00e7ok kullan\u0131lan formatter ve en g\u00fcncel tutulan\u0131 g\u00f6rd\u00fc\u011f\u00fcm kadar\u0131yla Alejandra g\u00f6r\u00fcn\u00fcyor. Bir \u00e7ok ide i\u00e7in plugin'leri bulunuyor. Nas\u0131l kullan\u0131laca\u011f\u0131na dair bilgiler sayfas\u0131nda mevcut zaten. \u0130kinci olarak da nixpkgs-fmt'a da bakabilirsiniz. ikissinin de VS Code i\u00e7in plugin'leri bulunuyor.</p> <p>Tam olarak nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 online g\u00f6rmek i\u00e7in \u015fu sayfay\u0131 ziyaret edebilirsiniz.</p>"},{"location":"nix_lang/02_nix_dili_alistirmalari.html#referanslar","title":"Referanslar","text":"<ul> <li>https://github.com/tazjin/nix-1p/blob/master/README.md</li> <li>https://nixos-and-flakes.thiscute.world/</li> <li>https://nixos.wiki/wiki/Overview_of_the_Nix_Language</li> <li>https://dram.page/p/nix-lang-with/</li> <li>https://stackoverflow.com/questions/46135417/trouble-understanding-with-statement-in-nix-expression</li> <li>https://nix.dev/guides/best-practices#with-attrset-expression</li> <li>https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55</li> </ul>"},{"location":"nix_lang/03_nix_dili_gomulu.html","title":"Nix Dilinde G\u00f6m\u00fcl\u00fc Fonksiyonlar","text":"<p>\u00d6nceki makalede Nix dilinin temel yap\u0131lar\u0131n\u0131 ve syntax'\u0131n\u0131 incelemi\u015ftik. Bu makalede ise Nix dilinin built-in fonksiyonlar\u0131n\u0131 ve ve \u00e7ok temel mod\u00fcllerini inceleyece\u011fiz.</p> <p>Bu fonksiyonlar olmadan diyebilir ki say\u0131 toplama \u00e7\u0131kartmadan ileriye gidemezdik. Bunu asl\u0131nda di\u011fer dillerde de gelen temel mod\u00fcllerle ayn\u0131 g\u00f6rebilirsiniz.</p> <p>Nix dilini dil olarak inceledi\u011fimizde asl\u0131nda \u00e7ok b\u00fcy\u00fck bir dil olmad\u0131\u011f\u0131n\u0131 g\u00f6rebiliyoruz. Yani bir \u00e7ok programlama diline g\u00f6re az kural\u0131 var. Onu karma\u015f\u0131km\u0131\u015f gibi yapan sebeplerden biri bir\u00e7o\u011fumuzun fonksiyonel bir dille daha \u00f6nce \u00e7al\u0131\u015fmam\u0131\u015f olmas\u0131 ve bir programlama dili olmas\u0131 yan\u0131nda bir konfig\u00fcrasyon dili olmas\u0131.</p> <p>Builtins fonksiyonlar zaten Nix dilinin bir par\u00e7as\u0131 oldu\u011fu i\u00e7in herhangi bir import i\u015flemi yapmam\u0131za gerek yok.</p> <p>Amac\u0131m\u0131z halen salt Nix dilinde uzmanla\u015fmak. Bu y\u00fczden NixOS veya Nixpkgs ile ilgili konulara girmeyece\u011fiz. Bu makalede daha \u00e7ok temel fonksiyonlar\u0131 g\u00f6rece\u011fiz ve m\u00fcmk\u00fcn olduk\u00e7a \u00f6rnekleri repl \u00fczerinde yapaca\u011f\u0131z. Bir sonraki makalemizde ise burada g\u00f6rd\u00fc\u011f\u00fcm\u00fcz fonksiyonlar\u0131 kullanarak bir mod\u00fcl olu\u015fturup bunu kullanaca\u011f\u0131z.</p> <p>Debugging ve Error Handling kavramlar\u0131yla ba\u015flayal\u0131m.</p>"},{"location":"nix_lang/03_nix_dili_gomulu.html#debug-ve-error-handling","title":"Debug ve Error Handling","text":"<p>Nix Dilinde do\u011frudan debug kavram\u0131 veya breakpoint veya IDE'nin deste\u011fi ile kodu sat\u0131r sat\u0131r \u00e7al\u0131\u015ft\u0131rma ne yaz\u0131k ki yok. Bunun yerine kod i\u00e7inde de\u011ferleri kontrol edebilece\u011fimiz yard\u0131mc\u0131 fonksiyonlar mevcut.</p>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinstrace-fonksiyonu","title":"<code>builtins.trace</code> fonksiyonu","text":"<p>Birinci birinci blo\u011fu \u00e7al\u0131\u015ft\u0131r\u0131p ekrana basar daha sonra ikinci blo\u011fu \u00e7al\u0131\u015ft\u0131r\u0131p sonucu ekrana basar.</p> <p>nix repl komutu ile repl'i a\u00e7\u0131p a\u015fa\u011f\u0131daki kodu \u00e7al\u0131\u015ft\u0131r\u0131yoruz.</p> <pre><code>builtins.trace (1 + 2) (4 + 5)\n# sonu\u00e7\n# trace: 3\n# 9\n</code></pre> <p>Biraz daha karma\u015f\u0131k bir \u00f6rnek yapal\u0131m.</p> <pre><code>d = a:b:a+b\nsum = a: b: a + (b (3 5))\nmul = a: b: a * b\nbuiltins.trace (sum (2 d)) (mul 4 5)\n\n# sonu\u00e7\n# trace: &lt;LAMBDA&gt;\n# 20\n</code></pre> <p>G\u00f6r\u00fclece\u011fi \u00fczere builtins.trace i\u00e7 i\u00e7e fonksiyonlarda veya yap\u0131larda \u00e7al\u0131\u015fam\u0131yor. \u00c7lk \u00e7a\u011fr\u0131lan fonksiyonun sadece i\u00e7inde bir lamda recursive yap\u0131 g\u00f6r\u00fcnce bunun bir LAMBDA oldu\u011funu s\u00f6yleyebildi o kadar.</p>"},{"location":"nix_lang/03_nix_dili_gomulu.html#assert-fonksiyonu","title":"<code>assert</code> fonksiyonu","text":"<p>\u00c7al\u0131\u015fma zaman\u0131nda bir de\u011ferin kontrolu i\u00e7in kullan\u0131l\u0131r. E\u011fer beklenen de\u011fer gelmezse hata f\u0131rlat\u0131r.</p> <pre><code>assert 2 == 2;\n(1 + 2)\nassert 2 == 3;\n(1 + 2)\n\n# error: assertion '(2 == 3)' failed\n\n#        at \u00abstring\u00bb:1:1:\n\n#             1| assert 2 == 3;\n#              | ^\n#             2| (1 + 2)\n</code></pre> <p>Bu trace'e g\u00f6re daha kullan\u0131\u015fl\u0131 bir fonksiyon gibi g\u00f6r\u00fcn\u00fcyor. En az\u0131ndan \u00e7al\u0131\u015fma zaman\u0131nda hatal\u0131 olmas\u0131 muhtemel de\u011ferlerin testinde kullan\u0131labilir.</p>"},{"location":"nix_lang/03_nix_dili_gomulu.html#throw-fonksiyonu","title":"<code>throw fonksiyonu</code>","text":"<p>Bazen de kendimiz \u00f6zellikle hata f\u0131rlatmak isteyebiliriz. Bu durumda throw fonksiyonunu kullanabiliriz.</p> <pre><code>if 1 == 1 then\n(1 + 1)\nelse\nthrow \"1 e\u015fit de\u011fil 1 de\u011fil\"\n\n# sonu\u00e7 2\n\nif 1 &gt; 1 then\n(1 + 1)\nelse\nthrow \"1 e\u015fit de\u011fil 1 de\u011fil\"\n\n# sonu\u00e7 error: 1 e\u015fit de\u011fil 1 de\u011fil\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinstryeval-fonksiyonu","title":"<code>builtins.tryEval</code> fonksiyonu","text":"<p>Hatalar\u0131 susturmak i\u00e7in kullan\u0131l\u0131r.</p> <pre><code>if 1 == 1 then\n(1 + 1)\nelse\nbuiltins.tryEval (throw \"1 e\u015fit de\u011fil 1 de\u011fil\")\n\n# result 2\n\n\nif 1 &gt; 1 then\n(1 + 1)\nelse\nbuiltins.tryEval (throw \"1 e\u015fit de\u011fil 1 de\u011fil\")\n# result { success = false; value = false; }\n\n\nbuiltins.tryEval (1 + 1)\n# result { success = true; value = 2; }\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#abort-kullanm","title":"<code>abort</code> kullan\u0131m\u0131","text":"<p>Asl\u0131nda throw'dan \u00e7ok da farkl\u0131 de\u011fil. Sadece throw'dan farkl\u0131 olarak \u00e7al\u0131\u015fman\u0131n bir hatadan dolay\u0131 sonland\u0131r\u0131ld\u0131\u011f\u0131n\u0131 belirtir.</p> <pre><code>abort \"1 e\u015fit de\u011fil 1 de\u011fil\"\n# result  error: evaluation aborted with the following error message: '1 e\u015fit de\u011fil 1 de\u011fil'\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#temel-liste-fonksiyonlar","title":"Temel Liste Fonksiyonlar\u0131","text":"<p>\u00d6ncelikle i\u015fimize yarayacak baz\u0131 fonksiyonlar\u0131 g\u00f6relim. Nix dilinde, listelerle \u00e7al\u0131\u015fmak i\u00e7in bir dizi kullan\u0131\u015fl\u0131 built-in fonksiyon bulunmaktad\u0131r. \u0130\u015fte Nix dilinde s\u0131k\u00e7a kullan\u0131lan baz\u0131 list fonksiyonlar\u0131:</p>"},{"location":"nix_lang/03_nix_dili_gomulu.html#length-liste-uzunlugu","title":"<code>length</code> (Liste Uzunlu\u011fu)","text":"<p>Bir listenin eleman say\u0131s\u0131n\u0131 d\u00f6nd\u00fcr\u00fcr.</p> <pre><code>   let\n     mylist = [1 2 3 4 5];\n   in\n     builtins.length mylist\n  # result 5\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#map-liste-elemanlarna-fonksiyon-uygulama","title":"<code>map</code> (Liste Elemanlar\u0131na fonksiyon Uygulama)","text":"<p>Bir listenin her eleman\u0131na belirli bir i\u015flevi uygular ve sonu\u00e7lar\u0131 i\u00e7eren yeni bir listeyi d\u00f6nd\u00fcr\u00fcr.</p> <pre><code>   let\n     mylist = [1 2 3 4 5];\n   in\n     map (x: x * 2) mylist\n  # result [ 2 4 6 8 10 ]\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#filter-liste-elemanlarn-filtreleme","title":"<code>filter</code> (Liste Elemanlar\u0131n\u0131 Filtreleme)","text":"<p>Bir ko\u015fulu sa\u011flayan liste elemanlar\u0131n\u0131 i\u00e7eren yeni bir liste d\u00f6nd\u00fcr\u00fcr.</p> <pre><code>   let\n     mylist = [1 2 3 4 5];\n   in\n     filter (x: x % 2 == 0) mylist\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#ile-listeleri-birlestirme","title":"<code>++ ile</code> (Listeleri Birle\u015ftirme)","text":"<p>Birden fazla listeyi birle\u015ftirir.</p> <pre><code>   let\n     list1 = [1 2 3];\n     list2 = [4 5 6];\n   in\n     concatLists = list1 ++ list2\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#sort-listeyi-sralama","title":"<code>sort</code> (Listeyi S\u0131ralama)","text":"<p>Bir listenin elemanlar\u0131n\u0131 s\u0131ralar.</p> <pre><code>   let\n     mylist = builtins.sort builtins.lessThan [ 483 249 526 147 42 77 ];\n   in\n     sort mylist\n# [ 42 77 147 249 483 526 ]\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinstail-fonksiyonu","title":"<code>builtins.tail</code> fonksiyonu","text":"<p>Listedeki ilk elema hrai\u015f di\u011fer elemenlar\u0131 alarak bir liste olu\u015fturur.</p> <pre><code>builtins.tail [1 2 3 4 5]\n# [ 2 3 4 5 ]\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinshead-fonksiyonu","title":"<code>builtins.head</code> fonksiyonu","text":"<p>Listedeki ilk eleman\u0131 d\u00f6nd\u00fcr\u00fcr.</p> <pre><code>builtins.head [1 2 3 4 5]\n# 1\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinsconcatlists-listeleri-birlestime","title":"<code>builtins.concatLists</code> (listeleri birle\u015ftime)","text":"<p>2 veya daha fazla listeden tek bir liste olu\u015fturur.</p> <pre><code>let\n  list1 = [1 2 3];\n  list2 = [4 5 6];\n  list3 = [7 8 9];\n  combinedList = builtins.concatLists [list1 list2 list3];\nin\n  combinedList\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinselemat-indekse-gore-listeden-eleman-getirmek","title":"<code>builtins.elemAt</code> (indekse g\u00f6re listeden eleman getirmek)","text":"<pre><code>let\n  list = [1 2 3];\n  result = builtins.elemAt list 2;\nin\n  result # 3\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinselem-ile-listede-eleman-aramak","title":"<code>builtins.elem</code> (ile listede eleman aramak)","text":"<p>verilen de\u011ferri liste i\u00e7inde arar ve bulursa true d\u00f6nd\u00fcr\u00fcr.</p> <pre><code>let\n  list = [1 2 3];\n  result = builtins.elem 2 list;\nin\n  result # true\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinsgenlist-ile-liste-olusturmak","title":"<code>builtins.genList</code> (ile liste olu\u015fturmak)","text":"<p>verilen fonksiyonu kullanarak bir liste olu\u015fturur.</p> <pre><code>let\n\nlist = builtins.genList (x: x * 2) 5;\n\nin\n\nlist # [ 0 2 4 6 8 ]\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinsgroupby-ile-liste-elemanlarn-gruplamak","title":"<code>builtins.groupBy</code> (ile liste elemanlar\u0131n\u0131 gruplamak)","text":"<p>verilen fonksiyondan d\u00f6nen string de\u011ferlerine g\u00f6re liste elemanlar\u0131n\u0131 gruplar. \u0130lk parametre olan fonksiyon alttaki \u00f6rnekte listedeki her bir eleman\u0131n 2. ve 3. karakterlerini al\u0131yor ( ar, az ve oo). GroupBy fonksiyonu da i\u00e7inde bu iki karaktere sahip olanlar\u0131 ayn\u0131 gruba dahil ediyor.</p> <pre><code>mySet = builtins.groupBy (builtins.substring 1 2) [\"foo\" \"bar\" \"baz\"]\n\nmySet\n# { b = [ ... ]; f = [ ... ]; }\n\nmySet.b\n# [ \"bar\" \"baz\" ]\n\nmySet.f\n# [ \"foo\" ]\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinssort-ile-listelerde-sralama-yapmak","title":"<code>builtins.sort</code> (ile listelerde s\u0131ralama yapmak)","text":"<p>\u0130lk parametre elemanlar\u0131 kar\u015f\u0131la\u015ft\u0131ran fonksiyon ikinci parametre ise liste.</p> <pre><code>myList = builtins.sort builtins.lessThan [ 483 249 526 147 42 77 ]\n\n:p myList\n# [ 42 77 147 249 483 526 ]\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinsmap","title":"<code>builtins.map</code>","text":"<p>Bir liste elemanlar\u0131na verilen fonksiyonu uygular.</p> <pre><code>myList = map (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]\n:p myList\n# [ \"foobar\" \"foobla\" \"fooabc\" ]\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinsfoldl","title":"<code>builtins.foldl\u2019</code>","text":"<p>Bu fonksiyon, bir listenin veya ba\u015fka bir veri yap\u0131s\u0131n\u0131n her eleman\u0131 \u00fczerinde bir i\u015flem ger\u00e7ekle\u015ftirerek sonu\u00e7 elde etmeyi sa\u011flar. foldl, soldan sa\u011fa do\u011fru birle\u015ftirme i\u015flemi yapar. Modern programlama dillerindeki reduce fonksiyonunun yapt\u0131\u011f\u0131n\u0131 yapar.</p> <pre><code>result = builtins.foldl' (x: y: x + y) 0 [1 2 3]\n:p result\n# 6\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#temel-set-fonksiyonlar","title":"Temel Set Fonksiyonlar\u0131","text":"<p>En \u00e7ok kullan\u0131lan set fonksiyonlar\u0131na bakal\u0131m.</p>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinshasattr","title":"<code>builtins.hasAttr</code>","text":"<p>Belirli bir \u00f6zelli\u011fin (attribute) bir k\u00fcmede bulunup bulunmad\u0131\u011f\u0131n\u0131 kontrol eder.</p> <pre><code>let\n  mySet = { foo = \"bar\"; baz = 42; };\nin\n  builtins.hasAttr \"foo\" mySet  # true\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinsattrnames","title":"<code>builtins.attrNames</code>","text":"<p>Bir k\u00fcmenin t\u00fcm \u00f6zellik isimlerini i\u00e7eren liste d\u00f6nd\u00fcr\u00fcr.</p> <pre><code>let\n  mySet = { foo = \"bar\"; baz = 42; };\nin\n  builtins.attrNames mySet  # [\"foo\" \"baz\"]\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinsattrvalues","title":"<code>builtins.attrValues</code>","text":"<p>Bir k\u00fcmenin t\u00fcm \u00f6zellik de\u011ferlerini i\u00e7eren liste d\u00f6nd\u00fcr\u00fcr.</p> <pre><code>let\n  mySet = { foo = \"bar\"; baz = 42; };\nin\n  builtins.attrValues mySet  # [\"bar\" 42]\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinselem","title":"<code>builtins.elem</code>","text":"<p>Bir de\u011ferin bir k\u00fcme i\u00e7inde bulunup bulunmad\u0131\u011f\u0131n\u0131 kontrol eder.</p> <pre><code>let\n  mySet = { foo = \"bar\"; baz = 42; };\nin\n  builtins.elem \"bar\" (builtins.attrValues mySet)  # true\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinsfilterattrs","title":"<code>builtins.filterAttrs</code>","text":"<p>Bir k\u00fcmedeki \u00f6zellikleri belirli bir ko\u015fula g\u00f6re filtreler.</p> <pre><code>let\n  mySet = { foo = \"bar\"; baz = 42; qux = true; };\nin\n  builtins.filterAttrs (name: value: value == true) mySet  # { qux = true; }\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#setin-eleman-saysn-almak","title":"Set'in eleman say\u0131s\u0131n\u0131 almak","text":"<p>Bunun i\u00e7in do\u011frudan bir fonksiyon yok ancak buraya kadar \u00f6\u011frendiklerimizle bunu yapabiliriz. \u00d6ncelikle setin \u00f6zelliklerini (attribute) al\u0131p bunlar\u0131 bir liste haline getirip daha sonra bu listenin uzunlu\u011funu alabiliriz.</p> <pre><code>let\n  mySet = { foo = \"bar\"; baz = 42; };\n  myList = builtins.attrNames mySet;\nin\n  builtins.length myList  # 2\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinszipattrswith","title":"builtins.zipAttrsWith","text":"<p>Verilen fonksiyonu verilen set'lere uygularak yeni bir set olu\u015fturur.</p> <p>Alttaki \u00f6rnekte set'lerin name'ine g\u00f6re</p> <pre><code>mySet = builtins.zipAttrsWith (name: vals: {name=name; vals=vals;}) [{ a = 1; b = 1; c = 1; }  { a = 10; }  { b = 100; } ]\n\n:p mySet\n\n# { a = { name = \"a\"; vals = [ 1 10 ]; }; b = { name = \"b\"; vals = [ 1 100 ]; }; c = { name = \"c\"; vals = [ 1 ]; }; }\n</code></pre> <p>Ayn\u0131 \u00f6rne\u011fi alttaki gibi de yazabilirdik.</p> <pre><code>mySet = builtins.zipAttrsWith (name: values: { inherit name values; }) [{ a = 1; b = 1; c = 1; }  { a = 10; }  { b = 100; } ]\n\n:p mySet\n\n# sonu\u00e7\n{ a = { name = \"a\"; values = [ [ 1 2 3 ] \"test1\" ]; }; b = { name = \"b\"; values = [ [ 1 2 3 ] \"test2\" [ \"4\" \"5\" \"6\" ] ]; }; c = { name = \"c\"; values = [ [ 7 \"sekiz\" 9 ] 9 ]; }; }\n</code></pre> <p>Asl\u0131nda \u00e7ok daha karma\u015f\u0131k zip fonksiyonlar\u0131 da yaz\u0131labilir. Ama burada o kadar derine inmeyece\u011fiz. Bu konuda yani zip fonksiyonlar\u0131 anlama konusunda di\u011fer dillerden de \u00f6rnekleri inceleyebilirsiniz. Ne yaz\u0131k ki Nix dilinde yaz\u0131lm\u0131\u015f \u00e7ok \u00f6rnek yok. Karma\u015f\u0131k \u00f6rnekleri bir sonraki makalemizde yapaca\u011f\u0131z. Bunun i\u00e7in daha fazla fonksiyonlar hakk\u0131nda daha \u00e7ok \u015fey \u00f6\u011frenmeliyiz.</p> <ol> <li>builtins.removeAttrs (ile set'den eleman silme)</li> </ol> <p>Verilen listedeki elentleri set name'leri i\u00e7inde arar ve buldu\u011fu elementi listeden siler.</p> <pre><code>mySet = removeAttrs { x = 1; y = 2; z = 3; } [ \"a\" \"x\" \"z\" ]\n:p mySet\n# { y = 2; }\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinsmapattrs","title":"builtins.mapAttrs","text":"<p>Bir fonksiyonu set'deki elamanlara uygular.</p> <pre><code>mySet = builtins.mapAttrs (name: value: value * 10) { a = 1; b = 2; }\np: mySet\n# { a = 10; b = 20; }\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#string-ile-ilgili-fonksiyonlar","title":"String ile ilgili fonksiyonlar","text":""},{"location":"nix_lang/03_nix_dili_gomulu.html#tostring-ile-degerleri-stringe-cevirmek","title":"<code>toString</code> (ile de\u011ferleri string'e \u00e7evirmek)","text":"<p>Bir de\u011fer'e string'e \u00e7evrilirken</p> <ul> <li>Path tipindekiler adres de\u011fi\u015fmeden string'e \u00e7evrilir (\u00f6rne\u011fin toString /foo/bar, \"/foo/bar\" \u015feklinde \u00e7evrilir.</li> <li>E\u011fer bir set <code>{ __toString = self: ...; }</code> veya <code>{ outPath = ...; }</code>\u015feklinde bir elamana sahipse ve bu eleman\u0131n i\u00e7eri\u011fi string ise onu d\u00f6nd\u00fcr\u00fcr.</li> <li>Rakamlar oldu\u011fu gibi string'e \u00e7evrilir</li> <li>Liste elemanlar\u0131 do\u011frudan string'e \u00e7evrilerek yine lite d\u00f6nd\u00fcr\u00fcr.</li> <li>Bool de\u011ferler\u015fde e\u011fer false ise bo\u015fluk de\u011fise string olarak 1 de\u011feri d\u00f6ner.</li> <li>null ise bo\u015f string d\u00f6nd\u00fcr\u00fcr</li> </ul> <pre><code>mySet = { a = 1; b = 2; __toString = self:\"merhaba\";}\ntoString mySet\n# result \"merhaba\"\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinssubstring-ile-bir-string-ifadeden-parca-almak","title":"<code>builtins.substring</code> (ile bir string ifadeden par\u00e7a almak)","text":"<p>\u0130lk say\u0131 ba\u015flang\u0131\u00e7 index'ini ikinci rakam ise biti\u015f index'ini g\u00f6sterir.</p> <pre><code>result = builtins.substring 8 12 \"Merhaba D\u00fcnya\"\n:p result\n# D\u00fcnya\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinsstringlength-ile-stringin-uzunlugunu-almak","title":"<code>builtins.stringLength</code> (ile string'in uzunlu\u011funu almak)","text":"<pre><code>result = builtins.stringLength \"Merhaba D\u00fcnya\"\n\n:p result\n# 14\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#builtinsreplacestrings-ile-bir-string-ifadeyi-degistirmek","title":"<code>builtins.replaceStrings</code> (ile bir string ifadeyi de\u011fi\u015ftirmek)","text":"<p>Listeler halinde aranacak string ifade ve yerine ge\u00e7ecek string ifadedeler verilir. En sona da \u00fczerinden i\u015flem yap\u0131lacak string ifade verilir.</p> <pre><code>result = builtins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\"\n:p result\n# fabir\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#is-ile-baslayan-fonksiyonlar","title":"<code>is</code> ile ba\u015flayan fonksiyonlar","text":"<p>Asl\u0131nda bu fonksiyonlar\u0131 belki ilgili veri tipinin alt\u0131na koymak mant\u0131kl\u0131 olabilir. Ancak ak\u0131lda kalmas\u0131 i\u00e7in tek ba\u015fl\u0131kta listelemek mant\u0131kl\u0131 geldi.</p> <ul> <li>builtins.isString</li> <li>builtins.isPath</li> <li>builtins.isNull</li> <li>builtins.isList</li> <li>builtins.isInt</li> <li>builtins.isFunction</li> <li>builtins.isFloat</li> <li>builtins.isBool</li> <li>builtins.isAttrs</li> </ul> <p>Bu fonksiyonlar\u0131n \u00e7al\u0131\u015fma mant\u0131\u011f\u0131 hep ayn\u0131, fonksiyona verilen de\u011ferin kontrol edilen tipten olup olmad\u0131\u011f\u0131n\u0131 kontrol ederler.</p> <pre><code>result = builtins.isList \"merhaba\"\n\n:p result\n\n# result false\n</code></pre>"},{"location":"nix_lang/03_nix_dili_gomulu.html#fetch-ile-baslayan-fonksiyonlar","title":"Fetch ile Ba\u015flayan Fonksiyonlar","text":"<ul> <li>builtins.fetchGit: Git repolar\u0131ndan dosya indirmek i\u00e7in kullan\u0131l\u0131r.</li> <li>builtins.fetchClosure: Nix store'da bulunan bir dosyay\u0131 indirmek i\u00e7in kullan\u0131l\u0131r.</li> <li>builtins.fetchTarball: Tarball dosyalar\u0131n\u0131 indirmek i\u00e7in kullan\u0131l\u0131r.</li> <li>builtins.fetchurl: URL'den dosya indirmek i\u00e7in kullan\u0131l\u0131r.</li> </ul> <p>Di\u011fer fetcher'lar i\u00e7in \u015fu linke ve resmi NixOS sayfas\u0131na g\u00f6z atabilirsiniz. NixOS sayfas\u0131ndakiler sadece builtins fonksiyonlar\u0131n\u0131 i\u00e7ermiyor.</p> <p>Biz asl\u0131nda nixpkgs reposunu kulland\u0131\u011f\u0131m\u0131zda repo bir tar dosays\u0131 oalrak sistemimize indirilir. Extract edildikten sonra lokal dosyalarla i\u015flem yap\u0131l\u0131r.</p>"},{"location":"nix_lang/03_nix_dili_gomulu.html#loop-kullanm","title":"Loop Kullan\u0131m\u0131","text":"<p>Daha \u00f6nce de bahsetti\u011fimiz gibi Nix dilinde loop yoktur. Ancak recursive fonksiyonlar kullanarak d\u00f6ng\u00fc mant\u0131\u011f\u0131n\u0131 olu\u015fturabiliriz. Bir \u00f6nceki makalede hen\u00fcz mod\u00fclleri g\u00f6rmedi\u011fimiz i\u00e7in bu konuya de\u011finmemi\u015ftik. Art\u0131k builtins fonksiyonlara de\u011findi\u011fimize g\u00f6re bu konuya tekrar d\u00f6nebiliriz.</p> <p>Loop kullan\u0131m\u0131nda map, fold ve filter gibi fonksiyonlar \u00e7ok i\u015fimize yarayacak. Sonu\u00e7ta amac\u0131m\u0131z liste elemanlar\u0131nda dola\u015fmak ve elamanlar \u00fczerinde i\u015flemler yapabilmek. Bu fonksiyonlarda bunu bize sa\u011flayacak. Bir iki \u00f6rnek yapal\u0131m.</p> <p>Bir nix dosyas\u0131 olu\u015fturup i\u00e7ine alttaki kodlar\u0131 kopyalayal\u0131m. Amac\u0131m\u0131z b\u00fct\u00fcn elemanlar\u0131 2 ile \u00e7arpmak.</p> <pre><code>let\nmyList = [1 2 3 4 5];\nresult = builtins.map (x : x * 2) myList;\nin\n{\ninherit result;\n}\n</code></pre> <p>repl'i a\u00e7\u0131p alttaki komutu \u00e7al\u0131\u015ft\u0131ral\u0131m.</p> <pre><code>:l ./loop-example1.nix\n\n:p result.result\n# [ 2 4 6 8 10 ]\n</code></pre> <p>Bir \u00f6rnek daha yapal\u0131m. Bu sefer iki listenin elemanlar\u0131n\u0131 birbiri ile \u00e7arp\u0131p yeni bir liste olu\u015ftural\u0131m. E\u011fer salt fonksiyonel olmayan bir dilde kod yaz\u0131yor olsayd\u0131k bu i\u015flem i\u00e7in iki tane d\u00f6ng\u00fc kullanmam\u0131z gerekirdi. Ancak Nix dili daha \u00f6nce bahsetti\u011fimiz gibi fonksiyonel bir dil oldu\u011fu i\u00e7in biraz farkl\u0131 d\u00fc\u015f\u00fcnmemiz gerekiyor. bu arada tabii ki bu yapt\u0131\u011f\u0131m\u0131z\u0131 builtins veya ileride g\u00f6rece\u011fimiz lib mod\u00fcl\u00fc i\u00e7indeki fonksiyonlarla yapabilirsiniz. Yani iki listedeki elemanlar\u0131 birbiriyle \u00e7arpman\u0131n ba\u015fka yollar\u0131 da var ancak bizim amac\u0131m\u0131z hakikaten 2 liste elamanlar\u0131n\u0131 i\u00e7 i\u00e7e gezmemiz gerekir ne yapabiliriz onu g\u00f6rmek. Birazda tabi beyin jimnasti\u011fi yapmak.</p> <pre><code>let\n\nlist1 = [1 2 3 4];\nlist2 = [5 6 7 8];\n\n\nmul = my-list1: my-list2:\n                if builtins.length my-list1 &gt; 0 &amp;&amp; builtins.length my-list2 &gt; 0\n                    then [(builtins.head my-list1 * builtins.head my-list2)] ++ mul (builtins.tail my-list1) (builtins.tail my-list2)\n                else\n                    [];\nmyList = mul list1 list2;\n\nin\n{\nmyList = myList;\nlist1 =  list1;\nlist2 =  list2;\n}\n</code></pre> <p>Yine recursive fonksiyondan faydalan\u0131yoruz. Head fonksiyonu listenin ilk eleman\u0131n\u0131 al\u0131rken tail fonksiyonu listenin ikinci eleman\u0131nda ba\u015flayarak son elemana kadar b\u00fct\u00fcn elemanlar\u0131 bir liste olarak d\u00f6nd\u00fcr\u00fcr. Yapt\u0131\u011f\u0131m\u0131z recursive fonksiyon asl\u0131nda \u015f\u00f6yle bir \u015fey yap\u0131yor.</p> <pre><code>list1 = [1 2 3 4];\nlist2 = [5 6 7 8];\n\nsum = [1 * 5] ++ [2 * 6] ++ [3 * 7] ++ [4 * 8] ++ [];\n</code></pre> <p>Yazd\u0131\u011f\u0131\u0131z kodu bir dosyaya kaydedip repl'de \u00e7al\u0131\u015ft\u0131ral\u0131m.</p> <pre><code> :l ./loop-example2.nix\n# Added 3 variables.\nmyList\n# [ 5 12 21 32 ]\n</code></pre> <p>\u015eimdilik bu kadar. Ancak Nix'de tabii ki bundan daha fazlas\u0131 var ancak baya bi i\u015fimizi g\u00f6recek kadarl\u0131k k\u0131sm\u0131n\u0131 g\u00f6rm\u00fc\u015f olduk. Bundan \u00e7ok daha fazlas\u0131 da nixpkgs i\u00e7indeki lib mod\u00fcl\u00fcnde var.</p> <p>Umar\u0131m faydal\u0131 olmu\u015ftur.</p> <p>Bir sonraki makalemizde Nix paket y\u00f6neticisine ge\u00e7ece\u011fiz. Zaten bundan sonra buraya kadar g\u00f6rd\u00fcklerimizin bol bol uygulamas\u0131n\u0131 yap\u0131yor olaca\u011f\u0131z.</p>"},{"location":"nix_lang/03_nix_dili_gomulu.html#referanslar","title":"Referanslar","text":"<ul> <li>https://nix.dev/tutorials/nix-language.html#lookup-paths</li> <li>https://nix.dev/tutorials/module-system/module-system</li> <li>https://nixos.org/manual/nixpkgs/stable/</li> <li>https://nixos.org/manual/nix/stable/command-ref/env-common.html</li> <li>https://nixos.wiki/wiki/Nix_by_example#Exceptions</li> <li>https://nixos.wiki/wiki/Nix_by_example#Assertions</li> <li>https://nixos.wiki/wiki/Nix_by_example#Debugging</li> <li>https://teu5us.github.io/nix-lib.html</li> <li>https://fasterthanli.me/series/building-a-rust-service-with-nix/part-10</li> <li>https://ertt.ca/nix/shell-scripts/</li> </ul>"},{"location":"nix_package/birden_cok_paketi_ayni_repo_uzerinden_yayinlamak.html","title":"Birden \u00c7ok Paketi Ayn\u0131 Repo \u00dczeriden Yay\u0131nlamak","text":"<p>Bir \u00f6nceki yaz\u0131m\u0131zda Nix diline yeni eklenmi\u015f olan Flake kavram\u0131 hakk\u0131nda konu\u015fmu\u015ftuk. Bu yaz\u0131m\u0131zda elimizdeki paketleri bir repo \u00fczerinden nas\u0131l yay\u0131nlar\u0131z onu g\u00f6rece\u011fiz.</p> <p>Bunun i\u00e7in isterseniz bir ka\u00e7 paket daha ekleyelim. Yeni paketlerinde eklendi\u011fi bu halini multi-app branch'inde bulabilirsiniz. \u015eu linkten kodlar\u0131 inceleyebilirsiniz.</p> <p>Repo ayn\u0131 zamanda farkl\u0131 paket t\u00fcrlerini de \u00f6rneklemi\u015f oluyor.</p> <ul> <li>default-app: Inline yaz\u0131lm\u0131\u015f bir shell script'ini nas\u0131l paket olarak yay\u0131nlayaca\u011f\u0131m\u0131z g\u00f6steriyor.</li> <li>default-alt-app: default-app'in alternatif bir versiyonu ancak \u00f6nemli bir farkl\u0131 var. Shell script'ini \u00e7al\u0131\u015ft\u0131rmak i\u00e7in kullan\u0131lan paketleri de ayr\u0131 birer paket olarak y\u00f6netmemizi sa\u011fl\u0131yor. B\u00f6ylece daha iyi yonetilebilir paket olu\u015fturabiliyoruz.</li> <li>default-file-app: defaul-alt-app'in alternatif gibi d\u00fc\u015f\u00fcnebiliriz. Temel farkl\u0131 script'i bir dosyadan okuyor olmas\u0131.</li> <li>nix-app: Nixpkgs'den bir paketin flake i\u00e7inden \u00e7a\u011fr\u0131l\u0131p ba\u015fka bir flake olarak sunulmas\u0131n\u0131 g\u00f6steren bir \u00f6rnek.</li> <li>message-app: Daha \u00f6nce yazm\u0131\u015f oldu\u011fumuz message-third paketinin ayn\u0131s\u0131 sadece derivation fonksiyonu flake.nix dosyas\u0131n\u0131n i\u00e7ine ta\u015f\u0131n\u0131d\u0131.</li> <li>test-app: daha \u00f6nce yazd\u0131\u011f\u0131m\u0131z message-third paketinin ayn\u0131s\u0131.</li> </ul> <p>Flake dosyalar\u0131n\u0131 biraz a\u00e7al\u0131m.</p> <ul> <li> <p>Default-app paketinin flake dosyas\u0131nda bakacak olursan\u0131z derivation ile ilgili bir tan\u0131m yok. Do\u011frudan bir paket olu\u015fturmuyoruz. Ancak sonu\u00e7ta bir script'imiz var ve bunu \u00e7al\u0131\u015ft\u0131r\u0131yoruz. Ancak Nix'in bir kolayl\u0131\u011f\u0131 olarak shell'i do\u011frudan bir uygulamaym\u0131\u015f gibi \u00e7al\u0131\u015ft\u0131rma \u015fans\u0131m\u0131z oluyor.   Uygulamadaki writeShellScriptBin fonksiyonu ile bir script file olu\u015fturabiliyoruz. 2 parametre al\u0131yor biri dosya ad\u0131 di\u011feride dosyan\u0131n i\u00e7eri\u011fi. \u00d6rnekle ile iligi daha detayl\u0131 bilgi i\u00e7in \u015fu sayfadaki \u00f6rnkelere ve Nix Cookbook sayfas\u0131na g\u00f6z atabilirsiniz.</p> </li> <li> <p>Default-alt-app ise default-app in yani bir versiyonu. Default-app'de \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131z script'ler i\u00e7in gerekli olan paketleri (cowsay ve ddate) sistem kendisi y\u00f6netiyor. Yani \u00f6rne\u011fin override edemiyorum yada fakrl\u0131 \u00f6zelliklerini kontrol edemiyoruz. Ayr\u0131ca b\u00fct\u00fcn paketler tek bir paketmi\u015f gibi \u00e7al\u0131\u015f\u0131yor. Daha iyi y\u00f6netebilmemiz i\u00e7in ilgili paketleri de ayr\u0131 ayr\u0131 ba\u011f\u0131ml\u0131l\u0131k olarak kurmak i\u015fimize gelecektir. Bu neden flake i\u00e7inde alttaki gibi bir blok ekledik.</p> </li> </ul> <pre><code>app-buildInputs = with pkgs; [ cowsay ddate ];\n\nin pkgs.symlinkJoin {\n        name = app-name;\n        paths = [ app-script ] ++ app-buildInputs; # override\n        buildInputs = [ pkgs.makeWrapper ];\n        postBuild = \"wrapProgram $out/bin/${app-name} --prefix PATH : $out/bin\";\n      };\n</code></pre> <p>Burada kullan\u0131lan symlinkJoin kullan\u0131lan paketler i\u00e7in kendi paketimiz i\u00e7inde sembolik linkler olu\u015fturarak ba\u011f\u0131ml\u0131l\u0131k paketlerini do\u011frudan kendi paketimizin bulundu\u011fu dizinde \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131n\u0131 sa\u011flar. postBuild de\u011fi\u015fkeni, derleme i\u015fleminden sonra \u00e7al\u0131\u015ft\u0131r\u0131lmas\u0131 gereken bir komut veya i\u015flevi temsil eder. Bu durumda wrapProgram komutu kullan\u0131l\u0131r ve app-name ile belirtilen uygulaman\u0131n bir kopyas\u0131 olu\u015fturulur. Bu kopya, $out/bin klas\u00f6r\u00fcne yerle\u015ftirilir ve PATH ortam de\u011fi\u015fkenine eklenir. yani wrapProgram fonksiyonu ile programlar\u0131n yap\u0131land\u0131rmas\u0131n\u0131 veya isimlerini de\u011fi\u015ftirmek i\u00e7in kullanabiliriz.</p> <p>Kodu tekil olarak test etmek i\u00e7in klas\u00f6r i\u00e7indeyken <code>nix run .#</code> komutunu kullanabilirsiniz. Ayr\u0131ca olu\u015fan paketi ve ba\u011f\u0131ml\u0131l\u0131k dosyalar\u0131n\u0131 g\u00f6rmek i\u00e7in ayn\u0131 dizinde olu\u015fan result dizinini inceleyebilirsiniz.</p> <ul> <li>default-file-app ise default-alt-app'in bir versiyonu. Tek fark\u0131 script'in bir dosyadan okunuyor olmas\u0131. Bu durumda dosya okuma i\u015flemi i\u00e7in builtins.readFile fonksiyonu kullan\u0131l\u0131yor. Lokal dosyalarla \u00e7al\u0131\u015fma konusunda nix.dev sayfas\u0131ndaki \u015fu linke bakabilirsiniz. Burada ayr\u0131ca patchShebangs ad\u0131nda bir fonksiyon kulland\u0131k. Bu fonksiyon yeni olu\u015fturulacak script dosyas\u0131n\u0131n shebang sat\u0131r\u0131n\u0131 d\u00fczenler.</li> </ul> <p>writeTextFile, writeText, writeTextDir, writeScript, writeScriptBin fonksiyonlar\u0131n hepsi Nix Store'a text dosyas\u0131 olu\u015fturamak ve metin yazmak i\u00e7in kullan\u0131l\u0131r. Ayn\u0131 zamanda script \u00e7al\u0131\u015ft\u0131rabilmemizi de sa\u011flar. \u015eu sayfadan detaylar\u0131 inceleyebilirsiniz.</p> <p>Daha overlay ve override kavramlar\u0131n\u0131 g\u00f6rmedik ancak buray\u0131 anlamak \u00e7ok da zor de\u011fil. <code>(pkgs.writeScriptBin app-name app-src).</code> fonsksiyonun \u00e7\u0131kt\u0131s\u0131 asl\u0131nda</p> <pre><code>  app-src = builtins.readFile ./script.sh;\n  app-script = (pkgs.writeScriptBin app-name app-src).overrideAttrs(old: {\n          buildCommand = \"${old.buildCommand}\\n patchShebangs $out\";\n        });\n</code></pre> <ul> <li>nix-app ise nix paket y\u00f6neticisinden br paketi al\u0131p tekrar bir paket olarak nas\u0131l sunar\u0131z onu g\u00f6steriyor.</li> </ul> <p>Ancak son tahlilde amac\u0131m\u0131z b\u00fct\u00fcn bu farkl\u0131 paketleri tek bir flake alt\u0131ndan kulland\u0131rmak. Yani farkl\u0131 flake'leri tek bir flake alt\u0131ndan nas\u0131l sunar\u0131z onu g\u00f6rmek istiyoruz. Tabi bunu yapman\u0131n daha g\u00fczel yollar\u0131 da var zaten bir sonraki \u00f6rne\u011fimiz bunun \u00fczerine olacak ancak illaki salt bir flake nas\u0131l ba\u015fka bir flake i\u00e7inden \u00e7a\u011fr\u0131l\u0131r buna da ihtiyac\u0131m\u0131z olabilir diye bu \u00f6rne\u011fi de eklemek istedim.</p> <p>Bif flake'in sonucunu al\u0131p kullanabilmek i\u00e7in flake'in outputs fonksiyonunu kullanmam\u0131z gerekiyor. Output fonksiyonunun \u00e7\u0131kt\u0131lar\u0131ndan biri de bildi\u011fimiz \u00fczere derivative. Onu da kendi flake'imiz i\u00e7inde bir output derivative'i olarak d\u0131\u015far\u0131 a\u00e7m\u0131\u015f oluyoruz.</p> <p>Tekrar hat\u0131rlat\u0131yorum kodun tamam\u0131n\u0131 multi-app branch'inde bulabilirsiniz. \u015eu linkten kodlar\u0131 inceleyebilirsiniz.</p> <p>Bunun i\u00e7in k\u00f6k dizinde yazd\u0131\u011f\u0131m\u0131z flake \u015fu \u015fekilde.</p> <pre><code>{\n  description = \"My Nix Flake\";\n  inputs = {\n      nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  };\n  outputs = { self, nixpkgs }:\n\n  let\n\n      default-app-flake = import ./default-app/flake.nix;\n      default-app-output = default-app-flake.outputs {inherit self; inherit nixpkgs;};\n\n      default-alt-app-flake = import ./default-alt-app/flake.nix;\n      default-alt-app-output = default-alt-app-flake.outputs {inherit self; inherit nixpkgs;};\n\n      default-file-app-flake = import ./default-file-app/flake.nix;\n      default-file-app-output = default-file-app-flake.outputs {inherit self; inherit nixpkgs;};\n\n      message-app-flake = import ./message-app/flake.nix;\n      message-app-output = message-app-flake.outputs {inherit self; inherit nixpkgs;};\n\n      test-app-flake = import ./test-app/flake.nix;\n      test-app-output = test-app-flake.outputs {inherit self; inherit nixpkgs;};\n\n      nix-app-flake = import ./nix-app/flake.nix;\n      nix-app-output = nix-app-flake.outputs {inherit self; inherit nixpkgs;};\n\n  in\n    {\n      packages.x86_64-linux.default = default-app-output.packages.x86_64-linux.default;\n\n      packages.x86_64-linux.default-alt-app = default-alt-app-output.packages.x86_64-linux.default;\n\n      packages.x86_64-linux.default-file-app = default-file-app-output.packages.x86_64-linux.default;\n\n      packages.x86_64-linux.test-app = test-app-output.packages.x86_64-linux.default;\n\n      packages.x86_64-linux.message-app = message-app-output.packages.x86_64-linux.default;\n\n      packages.x86_64-linux.nix-app = nix-app-output.packages.x86_64-linux.default;\n    };\n}\n</code></pre> <p>\u0130steseniz \u00f6ncelikle <code>nix flake show</code> komutu ile flake'in \u00e7\u0131kt\u0131lar\u0131n\u0131 g\u00f6relim.</p> <pre><code>nix flake show\n\ngit+file:///home/.........../nix-examples?ref=refs/heads/main&amp;rev=6837ce8a8da4c1e542d5b503f79e1a9733f7ff56\n\u2514\u2500\u2500\u2500packages\n    \u2514\u2500\u2500\u2500x86_64-linux\n        \u251c\u2500\u2500\u2500default: package 'default-script'\n        \u251c\u2500\u2500\u2500default-alt-app: package 'default-alt-app'\n        \u251c\u2500\u2500\u2500default-file-app: package 'default-file-app'\n        \u251c\u2500\u2500\u2500message-app: package 'message-app'\n        \u251c\u2500\u2500\u2500nix-app: package 'hello-2.12.1'\n        \u2514\u2500\u2500\u2500test-app: package 'test-app'\n</code></pre> <p>B\u00fct\u00fcn paketlerimizi g\u00f6rebiliyoruz. \u015eimdi bir paketi \u00e7a\u011f\u0131r\u0131p \u00e7al\u0131\u015ft\u0131ral\u0131m.</p> <pre><code>nix run .#message-app\n# s\u0131ras\u0131yla sorular sorup ekrana yazd\u0131racak\n</code></pre> <p>Bir shell script ile paket olu\u015fturman\u0131n ba\u015fka yollar\u0131 da var. \u00d6rnekler i\u00e7in \u015fu sayfay\u0131 inceleyebilirsiniz. Bir ka\u00e7\u0131n\u0131 buraya da ta\u015f\u0131d\u0131m.</p> <p>Bu fonksiyonlar mkDerivation fonksiyonunu sarmayalayarak bize kolayl\u0131k sa\u011flar.</p> <p><code>runCommand</code></p> <pre><code>(import &lt;nixpkgs&gt; {}).runCommand \"my-example\" {} ''\n  echo My example command is running\n\n  mkdir $out\n\n  echo I can write data to the Nix store &gt; $out/message\n\n  echo ls\n  ls\n\n  echo whoami\n  whoami\n\n  echo date\n  date\n''\n</code></pre> <p><code>writeTextFile</code>, <code>writeText</code>, <code>writeTextDir</code>, <code>writeScript</code>, <code>writeScriptBin</code></p> <pre><code># Writes my-file to /nix/store/&lt;store path&gt;\nwriteTextFile {\n  name = \"my-file\";\n  text = ''\n    Contents of File\n  '';\n}\n# See also the `writeText` helper function below.\n\n# Writes executable my-file to /nix/store/&lt;store path&gt;/bin/my-file\nwriteTextFile {\n  name = \"my-file\";\n  text = ''\n    Contents of File\n  '';\n  executable = true;\n  destination = \"/bin/my-file\";\n}\n# Writes contents of file to /nix/store/&lt;store path&gt;\nwriteText \"my-file\"\n  ''\n  Contents of File\n  '';\n# Writes contents of file to /nix/store/&lt;store path&gt;/share/my-file\nwriteTextDir \"share/my-file\"\n  ''\n  Contents of File\n  '';\n# Writes my-file to /nix/store/&lt;store path&gt; and makes executable\nwriteScript \"my-file\"\n  ''\n  Contents of File\n  '';\n# Writes my-file to /nix/store/&lt;store path&gt;/bin/my-file and makes executable.\nwriteScriptBin \"my-file\"\n  ''\n  Contents of File\n  '';\n# Writes my-file to /nix/store/&lt;store path&gt; and makes executable.\nwriteShellScript \"my-file\"\n  ''\n  Contents of File\n  '';\n# Writes my-file to /nix/store/&lt;store path&gt;/bin/my-file and makes executable.\nwriteShellScriptBin \"my-file\"\n  ''\n  Contents of File\n  '';\n</code></pre> <p><code>writeShellApplication</code></p> <pre><code>writeShellApplication {\n  name = \"show-nixos-org\";\n\n  runtimeInputs = [ curl w3m ];\n\n  text = ''\n    curl -s 'https://nixos.org' | w3m -dump -T text/html\n  '';\n}\n</code></pre>"},{"location":"nix_package/birden_cok_paketi_ayni_repo_uzerinden_yayinlamak.html#callpackages-fonksiyonunu-kullanarak-birden-fazla-paketi-sunmak","title":"callPackages Fonksiyonunu kullanarak Birden Fazla Paketi Sunmak","text":"<p>E\u011fer amac\u0131m\u0131z tamamen kendi yazd\u0131\u011f\u0131m\u0131z paketleri tek bir yerden yay\u0131nlamaksa bunu daha uygun bir yolla yapmal\u0131y\u0131z. En \u00e7ok kullan\u0131lan tekniklerden biri callPackages. Nixpkgs'i de inceleyecek olursan\u0131z bu fonksiyonunu \u00e7ok s\u0131k g\u00f6rebilirsiniz. Hatta en iyi \u00f6rne\u011fini b\u00fct\u00fcn paketlerin tek bir yerden y\u00fcklenmesini sa\u011flayan Nixpkgs GitHub sayfas\u0131ndaki pkgs/top-evel/all-packages.nix sayfas\u0131d\u0131r. Bu sayfada yakla\u015f\u0131k 40 bin paket callPackages fonksiyomnu ile y\u00fcklenmi\u015ftir. Detayl\u0131 bakacak olursan\u0131z b\u00fct\u00fcn repo i\u00e7inde 3-5 adet flake dosyas\u0131 g\u00f6rebilirsiniz.</p> <p>Ancak bu hali bize \u00e7ok daha geni\u015fletilebilir (extendible), maintable ve daha mod\u00fcler bir yap\u0131 sa\u011fl\u0131yor.</p> <ul> <li>Sa\u011flad\u0131\u011f\u0131 en \u00f6nemli fayda art\u0131k derivation'\u0131n\u0131m\u0131za parametre ge\u00e7ebiliyoruz. Bu sayede ayn\u0131 kod blo\u011funu farkl\u0131 versiyonlar i\u00e7in de kullanabilece\u011fiz. Tabi bu sadece bir \u00f6rnek, neler yapabilece\u011fimizi anlayabilmek i\u00e7in bir \u00f6rnek. E\u011fer bir uygulaman\u0131n farkl\u0131 versiyonlar\u0131n\u0131 sunacaksan\u0131z (ki bu \u00e7ok \u00e7ok nadiren olacak bir durumdur) o zaman her birini ayr\u0131 ayr\u0131 sunmak daha mant\u0131kl\u0131 olacakt\u0131r. \u00d6rne\u011fin Resmi paket y\u00f6neticisinde kontrol ederseniz bir programlama dilinin veya bir SDK'in farkl\u0131 versiyonlar\u0131n\u0131n farkl\u0131 dosyalarla yay\u0131nland\u0131\u011f\u0131n\u0131 g\u00f6rebilirsiniz.</li> <li>\u0130kinci \u00f6nemli faydas\u0131 ise bu haliyle paketi override etmek i\u00e7in daha esnek yap\u0131 sunmas\u0131. Bunu hen\u00fcz g\u00f6rmedik ancak sadece bilgi vermek i\u00e7in yaz\u0131yorum. \u0130leride g\u00f6rece\u011fiz.</li> </ul> <p>Basit bir \u00f6rnekle ba\u015flayal\u0131m. Daha sonra b\u00fct\u00fcn repo'muzu bu fonksiyonla nas\u0131l y\u00f6netebilece\u011fimizi g\u00f6rece\u011fiz.</p> <p>message-app ad\u0131nda bir klas\u00f6r olu\u015fturup i\u00e7ine default.nix dosyas\u0131 olu\u015fturuyoruz. Alttaki kodu i\u00e7ine kopyal\u0131yoruz. Kod dikkat ederseniz art\u0131k bir flake de\u011fil. Sadece bir derivation d\u00f6nd\u00fcren fonksiyon. Ben de callPackage-first ad\u0131ndan bir klas\u00f6r i\u00e7inde bu i\u015flemleri yap\u0131yorum. Github hesab\u0131mda kodlar\u0131 g\u00f6rebilirsiniz.</p> <pre><code>{version ? \"v1.0\"}:\n    let\n\n      # bu bile paketimizin \u00f6zellikle kulland\u0131\u011f\u0131 bir versiyon varsa ona g\u00f6re y\u00fcklenebilir.\n      nixpkgs = import &lt;nixpkgs&gt; {};\n\n      selectedVersion = {version = \"${version}\";};\n\n      simpleMessageAppSrc = \"https://github.com/muratcabuk/simple-message-app-with-c/archive/refs/tags/${selectedVersion.version}.tar.gz\";\n\n      shaSet = {v10=\"sha256:1aai9xdkgq2vd0ch10gxhg53qfv4ny2x3jgxlq4r9nrn4g9r8s1z\";\n                v20=\"sha256:11p3c793yjpm4z4j9shlidbii7wd0kf9qflx8jqhhnwwhqf93mam\";\n                v30=\"sha256:1a4a2i32da9shc2d3i1ndarmla97bald7lgs1vjmwyjlry0mk4m7\";};\n\n      shaVer = builtins.concatStringsSep \"\" (nixpkgs.lib.strings.splitString \".\" \"${selectedVersion.version}\");\n\n      versionSha = builtins.getAttr shaVer shaSet;\n\n      # Simple Message App'in kaynak dizini\n      src = builtins.fetchTarball {\n        url = simpleMessageAppSrc;\n        sha256 = versionSha;\n      };\n\n    in\n\n        nixpkgs.stdenv.mkDerivation (finalAttrs: {\n              name = \"message-app\";\n              version = \"${selectedVersion.version}\";\n\n              src = src;\n\n              buildInputs = [ nixpkgs.gcc ];\n              buildPhase = \"gcc -o message-app ${src}/message.c\";\n              installPhase = \"mkdir -p $out/bin; install -t $out/bin message-app\";\n\n              meta = with nixpkgs.lib; {\n                    description = \"Simple Message App with C\";\n                    license = licenses.mit;\n                    version =  \"${selectedVersion.version}\";\n                };\n        })\n</code></pre> <p>E\u011fer callPackage fonksiyonunu kullanmasayd\u0131k alttaki gibi bir flake dosyas\u0131 yazacakt\u0131k.</p> <pre><code>{\n  description = \"Flake i\u00e7in \u00f6rnek paketler\";\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  };\n\n  outputs ={ self, nixpkgs, ... }:\n    let\n\n        packages = rec {\n\n            x86_64-linux.default = import ./message-app {version = \"v3.0\";};\n            x86_64-linux.message-app = x86_64-linux.default;\n\n            aarch64-linux.message-app =  import ./message-app {version = \"v3.0\";};\n        };\n\n    in\n    {\n    packages = packages;\n    };\n}\n</code></pre> <p>CallPackage fonksiyonu ile yazmak i\u00e7in Message-app klas\u00f6r\u00fc ile ayn\u0131 dizinde flake.nix dosyas\u0131 olu\u015fturup i\u00e7ine alttaki kodlar\u0131 kopyal\u0131yoruz. Dikkat ederseniz art\u0131k istedi\u011fimiz versiyonu flake \u00fczerinden ge\u00e7ebiliyoruz. Tabi bu yetenek ileride override ve overlay i\u015flemlerimizde de i\u015fimize yarayacak.</p> <p>Koddaki di\u011fer bir farkl\u0131l\u0131kta art\u0131k sadece x86_64-linux de\u011fil ayn\u0131 zamanda aarch64-linux i\u00e7in de paket sunuyoruz.</p> <pre><code>{\n  description = \"Flake i\u00e7in \u00f6rnek paketler\";\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  };\n\n  outputs ={ self, nixpkgs, ... }:\n    let\n        pkgs = import &lt;nixpkgs&gt; { };\n        packages = rec {\n\n            x86_64-linux.default = pkgs.callPackage ./message-app {version = \"v3.0\";};\n            x86_64-linux.message-app = x86_64-linux.default;\n\n            aarch64-linux.message-app =  pkgs.callPackage ./message-app {version = \"v3.0\";};\n        };\n\n    in\n    {\n    packages = packages;\n    };\n}\n</code></pre> <p>\u00d6ncelikle paket detaylar\u0131n\u0131 g\u00f6relim.</p> <pre><code>nix flake show --impure --all-systems\npath:/home/..../callPackage-first?lastModified=1707332288&amp;narHash=sha256-FaBT3XCD%2BhhbvH2JkYuSbo1GjNrohFaTWE1YY%2B5pqDo%3D\n\u2514\u2500\u2500\u2500packages\n\u251c\u2500\u2500\u2500aarch64-linux\n\u2502   \u2514\u2500\u2500\u2500message-app: package 'message-app'\n\u2514\u2500\u2500\u2500x86_64-linux\n\u251c\u2500\u2500\u2500default: package 'message-app'\n\u2514\u2500\u2500\u2500message-app: package 'message-app'\n</code></pre> <p>\u015eimdi versiyon numaras\u0131n\u0131 flake.nix i\u00e7inden v3.0 olarak de\u011fi\u015ftirip \u00e7al\u0131\u015ft\u0131ral\u0131m. V3'de kodda hat\u0131rlarsan\u0131z 3 adet soru soruyordu.</p> <pre><code>nix run .# --impure\n</code></pre> <p>Devam etmeden \u00f6nce \u00e7ok kullan\u0131\u015fl\u0131 bir paketi daha inceleyelim.</p>"},{"location":"nix_package/birden_cok_paketi_ayni_repo_uzerinden_yayinlamak.html#flake-yonetimi-icin-frameworkler","title":"Flake Y\u00f6netimi i\u00e7in Framework'ler","text":"<p>En \u00e7ok bilinenler</p> <ul> <li>Flake-Utils</li> <li>Flake-Utils-Plus</li> <li>Flake-Part</li> <li>Flakelight</li> </ul> <p>Flake-Utils'i kullanmak zorundan de\u011filiz ancak e\u011fer geli\u015ftirdi\u011finiz paket hakikaten bir \u00e7ok sistemde tamamen ayn\u0131 konfig\u00fcrasyon ve kurguyla \u00e7al\u0131\u015f\u0131yorsa kod tekrar\u0131ndan kurtulmak ve daha okunabilir bir kod i\u00e7in faydal\u0131 olacakt\u0131r.</p> <p>callPackage-second klas\u00f6r\u00fcne \u00f6nceki dosyalar\u0131 kopyalayal\u0131m ve flake.nix'i alttaki gibi de\u011fi\u015ftirelim.</p> <pre><code>{\n  description = \"Flake utils demo\";\n\n  inputs.flake-utils.url = \"github:numtide/flake-utils\";\n\n  outputs = { self, nixpkgs, flake-utils }:\n    flake-utils.lib.eachDefaultSystem (system:\n      let pkgs = nixpkgs.legacyPackages.${system}; in\n      {\n        packages = rec {\n          default =pkgs.callPackage ./message-app { version = \"v3.0\"; };\n          message-app = default;\n        };\n\n      }\n    );\n}\n</code></pre> <p>Detaylar\u0131n\u0131 bi g\u00f6relim.</p> <pre><code>nix flake show --impure --all-systems\npath:/home/.../callPackage-first?lastModified=1707332163&amp;narHash=sha256-szc%2Bl9PZNAgwaH%2B7oSITJUTLIECgMn/GhuT/XT5d6HY%3D\n\u2514\u2500\u2500\u2500packages\n\u251c\u2500\u2500\u2500aarch64-darwin\n\u2502   \u251c\u2500\u2500\u2500default: package 'message-app'\n\u2502   \u2514\u2500\u2500\u2500message-app: package 'message-app'\n\u251c\u2500\u2500\u2500aarch64-linux\n\u2502   \u251c\u2500\u2500\u2500default: package 'message-app'\n\u2502   \u2514\u2500\u2500\u2500message-app: package 'message-app'\n\u251c\u2500\u2500\u2500x86_64-darwin\n\u2502   \u251c\u2500\u2500\u2500default: package 'message-app'\n\u2502   \u2514\u2500\u2500\u2500message-app: package 'message-app'\n\u2514\u2500\u2500\u2500x86_64-linux\n\u251c\u2500\u2500\u2500default: package 'message-app'\n\u2514\u2500\u2500\u2500message-app: package 'message-app'\n</code></pre> <p>Tabi bu arada sadece bu kadarla kalm\u0131yor ba\u015fka yetenekleri de var. \u00d6zellikle bu projeden fokr'lanarak geli\u015ftirilen flake-utils plus'\u0131 da incelemenizi tavsiye ederim. Birden fazla channel (registry) ile \u00e7al\u0131\u015fabilme, host aylar\u0131n\u0131 dinamik de\u011fi\u015ftirme, input'lar \u00fczerinden dinamik flake olu\u015fturma vb bir \u00e7ok yetenek kazand\u0131r\u0131yor. Resmi Github sayfas\u0131ndan \u00f6rnekleri incelebilirsiniz.</p> <p>Plus'\u0131n sayfas\u0131ndaki \u00f6rnekleri oldu\u011fu gibi ta\u015f\u0131yorum. Fikir vermesi i\u00e7in \u00e7ok g\u00fczel \u00f6rnekler vermi\u015fler.</p> <pre><code>let\n  inherit (builtins) removeAttrs;\n  mkApp = utils.lib.mkApp;\n  # E\u011fer nixpkgs'ye do\u011frudan bir referans almak gerekiyorsa,\n  pkgs = self.pkgs.x86_64-linux.nixpkgs;\nin flake-utils-plus.lib.mkFlake {\n\n\n  # `self` ve `inputs` arg\u00fcmanlar\u0131 GEREKL\u0130D\u0130R!\n  inherit self inputs;\n\n  # Paketler, uygulamalar, devShell ve di\u011fer tan\u0131mlamalar i\u00e7in kullan\u0131lan desteklenen sistemler. Varsay\u0131lan olarak `flake-utils.lib.defaultSystems`.\n  supportedSystems = [ \"x86_64-linux\" ];\n\n\n  ################\n  ### channels / registry ###\n  ################\n\n  # T\u00fcm kanallar aras\u0131nda payla\u015f\u0131lan yap\u0131land\u0131rma.\n  channelsConfig = { allowBroken = true; };\n\n  # T\u00fcm kanallara uygulanan katmanlar.\n  sharedOverlays = [ nur.overlay ];\n\n  # Kanallar i\u00e7in nixpkgs flake referans\u0131.\n  # Varsay\u0131lan olarak `inputs` taraf\u0131ndan otomatik olarak olu\u015fturulur.\n  channels.&lt;isim&gt;.input = nixpkgs;\n\n  # Kanala \u00f6zg\u00fc yap\u0131land\u0131rma se\u00e7enekleri.\n  channels.&lt;isim&gt;.config = { allowUnfree = true; };\n\n  # Se\u00e7ilen kanala uygulanacak yamalar.\n  channels.&lt;isim&gt;.patches = [ ./someAwesomePatch.patch ];\n\n  # Se\u00e7ilen kanala uygulanacak katmanlar.\n  channels.&lt;isim&gt;.overlaysBuilder = channels: [\n    (final: prev: { inherit (channels.unstable) neovim; })\n  ];\n\n\n  ####################\n  ### hostDefaults ###\n  ####################\n\n  # T\u00fcm hostlar i\u00e7in kullan\u0131lacak varsay\u0131lan mimari, varsay\u0131lan olarak \"x86_64-linux\".\n  hostDefaults.system = \"x86_64-linux\";\n\n  # T\u00fcm hostlara aktar\u0131lacak varsay\u0131lan mod\u00fcller.\n  hostDefaults.modules = [ ./module.nix ./module2 ];\n\n  # Host'lar taraf\u0131ndan kullan\u0131lacak varsay\u0131lan kanal\u0131n referans\u0131 olarak `channels.&lt;isim&gt;.*`. Varsay\u0131lan olarak \"nixpkgs\".\n  hostDefaults.channelName = \"unstable\";\n\n  # T\u00fcm mod\u00fcllere aktar\u0131lacak ek arg\u00fcmanlar. Hostlar\u0131n  extraArgs ile  birle\u015ftirilir.\n  hostDefaults.extraArgs = { inherit utils inputs; foo = \"foo\"; };\n\n\n  #############\n  ### Hosts ###\n  #############\n\n  # Sistem mimarisi. Varsay\u0131lan olarak `defaultSystem` arg\u00fcman\u0131.\n  hosts.&lt;hostname&gt;.system = \"aarch64-linux\";\n\n  # Kullan\u0131lacak kanal\u0131n &lt;isim&gt;. Varsay\u0131lan olarak `nixpkgs`;\n  hosts.&lt;hostname&gt;.channelName = \"unstable\";\n\n  # Mod\u00fcllere aktar\u0131lacak ek arg\u00fcmanlar.\n  hosts.&lt;hostname&gt;.extraArgs = { abc = 123; };\n\n  # Mod\u00fcller i\u00e7in bunlar mod\u00fcl sisteminin bir par\u00e7as\u0131 olmad\u0131\u011f\u0131ndan,\n  # mod\u00fcllere 'imports' sat\u0131rlar\u0131nda sonsuz d\u00f6ng\u00fc olmadan kullan\u0131labilir.\n  hosts.&lt;hostname&gt;.specialArgs = { thing = \"abc\"; };\n\n  # Host a \u00f6zg\u00fc yap\u0131land\u0131rma.\n  hosts.&lt;hostname&gt;.modules = [ ./configuration.nix ];\n\n  # Yap\u0131land\u0131rma i\u00e7in flake \u00e7\u0131kt\u0131s\u0131. Varsay\u0131lan olarak `nixosConfigurations`.\n  hosts.&lt;hostname&gt;.output = \"darwinConfigurations\";\n\n  # Sistem olu\u015fturucusu. Varsay\u0131lan olarak `channels.&lt;isim&gt;.input.lib.nixosSystem`.\n  hosts.&lt;hostname&gt;.builder = nix-darwin.lib.darwinSystem;\n\n\n#############################\n  ### flake outputs builder ###\n  #############################\n\n\n  outputsBuilder = channels: {\n    # `apps.&lt;sistem&gt;.custom-neovim = utils.lib.mkApp { drv = ...; exePath = ...; };` olarak de\u011ferlendirilir.\n    apps = {\n      custom-neovim = mkApp {\n        drv = fancy-neovim;\n        exePath = \"/bin/nvim\";\n      };\n    };\n\n    # `packages.&lt;sistem&gt;.package-from-overlays = &lt;unstable-nixpkgs-reference&gt;.package-from-overlays` olarak de\u011ferlendirilir.\n    packages = { inherit (channels.unstable) package-from-overlays; };\n\n    # `apps.&lt;sistem&gt;.firefox = utils.lib.mkApp { drv = ...; };` olarak de\u011ferlendirilir.\n    defaultApp = mkApp { drv = channels.nixpkgs.firefox; };\n\n    # `defaultPackage.&lt;sistem&gt;.neovim = &lt;nixpkgs-channel-reference&gt;.neovim` olarak de\u011ferlendirilir.\n    defaultPackage = channels.nixpkgs.neovim;\n\n    # `devShell.&lt;sistem&gt; = &lt;nixpkgs-channel-reference&gt;.mkShell { name = \"devShell\"; };` olarak de\u011ferlendirilir.\n    devShell = channels.nixpkgs.mkShell { name = \"devShell\"; };\n  };\n\n\n  #########################################################\n  ### Di\u011fer t\u00fcm \u00f6zellikler flake'e aktar\u0131l\u0131r ###\n  #########################################################\n\n  checks.x86_64-linux.someCheck = pkgs.hello;\n  packages.x86_64-linux.somePackage = pkgs.hello;\n  overlay = import ./overlays;\n  abc = 132;\n</code></pre> <ul> <li>Bunlar\u0131n haricinde birde CircleCI'\u0131n geli\u015ftirdi\u011fi flake-part var. Onu resmi GitHub sayfas\u0131ndan inceleyebilirsiniz. Temel amac\u0131 flake'leri daha mod\u00fcler ve daha okunabilir bir yap\u0131ya kavu\u015fturmak ve system baz\u0131nda y\u00f6netimini saplamak.</li> <li>Flakelight ise flake olu\u015fturma s\u00fcre\u00e7lerini otomatikle\u015ftirme, ortak yap\u0131land\u0131rma ve flake'leri daha mod\u00fcler hale getirme gibi \u00f6zellikler sunuyor.</li> </ul> <p>Hemen hemen hepsinde mkFlake, mkApp fonksiyonlar\u0131 bulunuyor. Hepsinin de sistemleri y\u00f6netmek i\u00e7in yap\u0131lar mevcut.Temel ama\u00e7lar\u0131 flake 'la\u0131 daha par\u00e7al\u0131 hala getirmek b\u00f6ylece \u00e7ok karma\u015f\u0131k flake'leri y\u00f6netmek daha kolay olmu\u015f oluyor.</p> <p>\u015eu sayfada Flakelight ve Flake-Part'\u0131 kar\u015f\u0131la\u015ft\u0131ran g\u00fczel \u00f6rnekler var.</p> <p>\u015eimdi as\u0131l konumuza d\u00f6nelim. Bu vakte kadar \u00f6\u011frendiklerimizle kendi repo'muzu hem di\u011fer sistemlerde de \u00e7al\u0131\u015facak hale getirelim hem de callPackage ile paketlerimizi y\u00fckleyelim.</p>"},{"location":"nix_package/birden_cok_paketi_ayni_repo_uzerinden_yayinlamak.html#repommuzu-callpackege-fonksiyonu-ile-yeniden-yazyoruz","title":"Repommuzu callPackege fonksiyonu ile Yeniden Yaz\u0131yoruz.","text":"<p>Github'daki projemizi de\u011fi\u015ftiriyoruz. Yeni flake dosyam\u0131z alttaki gibi olacak. Tabi yazd\u0131\u011f\u0131m\u0131z kodu da de\u011fi\u015ftirdik. \u00d6nceki versiyonda hat\u0131rlarsan\u0131z uygulama klas\u00f6rlerimizde flake olu\u015fturmu\u015ftuk. Ama art\u0131k module olarak de\u011fi\u015ftirdik. Art\u0131k daha okunakl\u0131lar. Ayr\u0131ca bu yeni versiyonda \u00e7al\u0131\u015ft\u0131r\u0131labilir (executable) mod\u00fcller yazd\u0131\u011f\u0131m\u0131z i\u00e7in her birini apps ad\u0131nda bir klas\u00f6r olu\u015fturup hepsini tek bir yere toplam\u0131\u015f olduk. Bunun bir amac\u0131da ileride ekleyece\u011fimiz di\u011fer klas\u00f6r ve dosyalarla kar\u0131\u015fmamalar\u0131n\u0131 sa\u011flamak.</p> <p>T\u00fcm kodlara multi-app-with-callpackages branch'inden eri\u015febilirsiniz.</p> <p>Dikkat ederseniz eachSystem fonksiyonu iki parametre al\u0131yor birincisi bir liste (systems) ikincisi ise fonksiyon.</p> <pre><code>{\n  description = \"Flake i\u00e7in \u00f6rnek paketler\";\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    flake-utils.url = \"github:numtide/flake-utils\";\n\n  };\n\n  outputs ={ self, nixpkgs, flake-utils, ... }:\n\n  let\n\n    systems = [\"x86_64-linux\" \"x86_64-darwin\"];\n\n  in\n\n    flake-utils.lib.eachSystem systems (system:\n      let pkgs = nixpkgs.legacyPackages.${system}; in\n      {\n        packages = rec {\n            default = pkgs.callPackage ./apps/default { pkgs = pkgs;};\n            defaultalt = pkgs.callPackage ./apps/defaultalt {pkgs = pkgs;};\n            defaultfile = pkgs.callPackage ./apps/defaultfile {pkgs = pkgs;};\n            message = pkgs.callPackage ./apps/message { version = \"v3.0\"; pkgs = pkgs;};\n            nixapp = pkgs.callPackage ./apps/nixapp {pkgs = pkgs;};\n            testapp = pkgs.callPackage ./apps/testapp {version = \"v2.0\"; pkgs = pkgs;};\n        };\n      }\n    );\n\n}\n</code></pre> <p>Evet art\u0131k basit anlamda kendi repo'muzu olu\u015fturduk ve birden fazla paketi ayn\u0131 andan yay\u0131nlad\u0131k. \u015eimdi de bence yeni \u00f6\u011frenenlerin en \u00e7ok zorland\u0131\u011f\u0131 konulardan birine ba\u015flatal\u0131m. Override ve Overlay konular\u0131 kendi ad\u0131ma beni en \u00e7ok zorlayan konu oldu. B\u00fcy\u00fck ihtimal siz okurken kolay gibi gelecek ancak dok\u00fcman yetersizli\u011finden dolay\u0131 anlama noktas\u0131na gelmek baya vaktimi alm\u0131\u015ft\u0131. Zaten ara\u015ft\u0131r\u0131rken de g\u00f6receksiniz en \u00e7ok sorulan konulardan biri de bu.</p> <p>Bu konuya da bir sonraki yaz\u0131m\u0131zda devam edelim.</p>"},{"location":"nix_package/birden_cok_paketi_ayni_repo_uzerinden_yayinlamak.html#kaynaklar","title":"Kaynaklar","text":"<ul> <li>https://zero-to-nix.com/concepts/flakes</li> <li>https://serokell.io/blog/practical-nix-flakes</li> <li>https://nixos.wiki/index.php?title=Flakes</li> <li>https://www.tweag.io/blog/2020-07-31-nixos-flakes/</li> <li>https://nixos.wiki/wiki/Flakes#Introduction</li> <li>https://determinate.systems/posts/nix-run</li> <li>https://nixos.wiki/wiki/Flakes</li> <li>https://ertt.ca/nix/shell-scripts/</li> <li>https://fasterthanli.me/series/building-a-rust-service-with-nix/part-10</li> <li>https://nix.dev/tutorials/file-sets.html</li> <li>https://nixos.wiki/wiki/Nix_Cookbook#Wrapping_packages</li> <li>https://nixos.org/manual/nixpkgs/stable/#part-stdenv</li> <li>https://ryantm.github.io/nixpkgs/builders/trivial-builders/</li> <li>https://serokell.io/blog/practical-nix-flakes#basic-flake-structure</li> <li>https://lantian.pub/en/article/modify-computer/nixos-packaging.lantian/</li> <li>https://github.com/samdroid-apps/nix-articles</li> <li>https://github.com/djhshih/biopkgs/tree/master</li> </ul>"},{"location":"nix_package/developer_ve_profile_ortamlari_olusturmak.html","title":"Nix Paket Y\u00f6neticisi ile Developer ve Profile Ortamlar\u0131 Olu\u015fturmak","text":"<p>\u00d6nceki yaz\u0131lar\u0131m\u0131zda <code>nix shell</code> ve <code>nix profile</code> komutlar\u0131n\u0131 g\u00f6rm\u00fc\u015ft\u00fck. Ancak oralara yat\u0131\u011f\u0131m\u0131z \u00f6rneklerde imperative bir yol izlemi\u015ftik. Kurmak istedi\u011fimiz developer ortam\u0131 i\u00e7in <code>nix shell</code> komutu ile b\u00fct\u00fcn uygulamalar\u0131 ve paketleri manuel olarak her defas\u0131ndan y\u00fcklemek zorundayd\u0131k. Yada olu\u015fturdu\u011fumuz bir profile her defas\u0131nda yeniden olu\u015fturmak durumundayd\u0131k. \u0130lgili yaz\u0131m\u0131zda da belirtti\u011fimiz gibi bu zaten Nix felsefesine \u00e7ok da uyan bir yakla\u015f\u0131m de\u011fil. Zaten o zamanda bunu declarative versiyonunu ileride g\u00f6rece\u011fimizden bahsetmi\u015ftik. \u00c7\u00fcnk\u00fc arada declarative kurguyu biraz anlamam\u0131z gerekiyordu. Art\u0131k kald\u0131\u011f\u0131m\u0131z yeren devam edebiliriz.</p>"},{"location":"nix_package/developer_ve_profile_ortamlari_olusturmak.html#nix-shell-declarative-kullanm","title":"Nix Shell Declarative Kullan\u0131m\u0131","text":"<p>Yeni kurguda asl\u0131nda <code>nix shell</code> do\u011frudan nix dosyalar\u0131 \u00fczerinden declarative olarak kurum yapm\u0131yor. Ancak <code>nix develop</code> komutu bu i\u015fi yap\u0131yor. Ancak declarative say\u0131labilecek g\u00fczel kullan\u0131mlar\u0131 mevcut. Detaylar\u0131 resmi dok\u00fcmanlar\u0131ndan da bakabilirsiniz. Bir k\u0131sm\u0131n\u0131 burada test edece\u011fiz.</p> <p>Mesela alttaki gibi kullan\u0131mlar\u0131 oldu\u011funu daha \u00f6nce g\u00f6rm\u00fc\u015ft\u00fck.</p> <pre><code>nix shell nixpkgs#youtube-dl\nyoutube-dl --version\n\n#2021.12.17\n\nnix shell nixpkgs/nixos-20.03#hello\nhello\n# Hello, world!\n\nnix shell nixpkgs#hello --command hello --greeting 'Hi everybody!'\n# Hi everybody!\n\n# ayn\u0131 diznide yer alan bir flake.nix dosyas\u0131n\u0131n export etti\u011fi paketleri y\u00fcklyebiliriz.\nnix shell .\n</code></pre> <p>Daha bir \u00e7ok \u00f6rnek bulabilirsiniz. Temel amac\u0131 terminal a\u00e7\u0131kken bir uygulamay\u0131 kullanmak veya sadece test emek i\u00e7in kurmam\u0131z\u0131 sa\u011fl\u0131yor. Bunu haricinde <code>nix shell</code> komutunu shebang interpreter olarak da kullan\u0131labilir.</p> <p>\u00d6rne\u011fin alttaki python kodunu bir dosyaya kaydedip (\u00f6rne\u011fin test.py) daha sonra <code>python3 test.py</code> komutuyla \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda <code>ModuleNotFoundError: No module named prettytable</code> hatas\u0131 al\u0131r\u0131z. \u00c7\u00fcnk\u00fc prettytable mod\u00fcl\u00fc y\u00fckl\u00fc de\u011fil.</p> <pre><code>import prettytable\n\n# Print a simple table.\nt = prettytable.PrettyTable([\"N\", \"N^2\"])\nfor n in range(1, 10): t.add_row([n, n * n])\nprint (t)\n</code></pre> <p>\u015eimdi ayn\u0131 dosyy\u0131 alttaki gibi editleyelim. <code>#!</code> ba\u015flayan sat\u0131rlara shebang diyoruz. Bu sat\u0131rlar ile ilgili dosyan\u0131n \u00f6ncelikle nix shell ile a\u00e7\u0131l\u0131p gerekli paketler y\u00fcklendikten sonra python ile \u00e7al\u0131\u015ft\u0131raca\u011f\u0131n\u0131 belirtiyoruz. <code>test.py</code> dosyas\u0131n\u0131 \u00f6ncelikle <code>chmod +x test.py</code> komutuyka \u00e7al\u0131\u015ft\u0131r\u0131labilir yap\u0131p daha sonra <code>./test.py</code> ile terminalden \u00e7al\u0131\u015ft\u0131r\u0131oyruz. B\u00f6yllece <code>prettytable</code> mod\u00fcl\u00fc y\u00fcklendikten sonra python kodu \u00e7al\u0131\u015ft\u0131r\u0131lm\u0131\u015f oluyor.</p> <pre><code>#! /usr/bin/env -S nix shell github:tomberek/-#python3With.prettytable --command python\n\nimport prettytable\n\n# Print a simple table.\nt = prettytable.PrettyTable([\"N\", \"N^2\"])\nfor n in range(1, 10): t.add_row([n, n * n])\nprint (t)\n</code></pre> <p>Mesela alttaki shell script'inde ise \u00e7ok sat\u0131rl\u0131 bir Nix expression \u00e7al\u0131\u015ft\u0131r\u0131l\u0131yor. Terraform \u00e7al\u0131\u015ft\u0131r\u0131lmadan \u00f6nce expression \u00e7al\u0131\u015ft\u0131r\u0131l\u0131yor ilgili plugin'ler y\u00fcklendikten sonra Terraform \u00e7al\u0131\u015ft\u0131r\u0131l\u0131yor.</p> <pre><code>#! /usr/bin/env nix\n#! nix shell --impure --expr ``\n#! nix with (import (builtins.getFlake ''nixpkgs'') {});\n#! nix terraform.withPlugins (plugins: [ plugins.openstack ])\n#! nix ``\n#! nix --command bash\n\nterraform \"$@\"\n</code></pre>"},{"location":"nix_package/developer_ve_profile_ortamlari_olusturmak.html#nix-develop-kullanm","title":"Nix Develop Kullan\u0131m\u0131","text":"<p><code>Nix develop</code> komutu daha \u00f6nce <code>nix-shell</code> komutu yerine geldi. \u00d6nceden (genellikle) ad\u0131 shell.nix olan bir dosya i\u00e7inde mkShell fonksiyonu yaz\u0131l\u0131r ve <code>nix shell</code> komutu shell.nix dosyas\u0131n\u0131n bulundu\u011fu dizinde \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda ilgili uygulamalar kurulurdu. Ancak yeni versiyonda art\u0131k bence daha anlaml\u0131 olan <code>nix develop</code> komutu geldi. Amac\u0131m\u0131z halen ayn\u0131 yani \u00fczerinden \u00e7al\u0131\u015fmakta oldu\u011fumuz projenin isterleri olan uygulama ve paketlerin kurulumunu yapmak. Ancak bu sefer tek tek y\u00fcklemiyoruz bunun yerine ilgili paketve uygulamalar\u0131 flake dosyam\u0131za yaz\u0131yoruz ve oradan y\u00fckl\u00fcyoruz.</p> <p>Flake doaylar\u0131m\u0131zla bu yaz\u0131ya kadar derivative ve paxkage olu\u015fturduk. \u015eimdi ise flake dosyalar\u0131m\u0131z\u0131 kullanarak <code>nix develop</code> komutu ile bir developer ortam\u0131 olu\u015fturaca\u011f\u0131z. Bunun i\u00e7inde daha \u00f6nce paket export ederken kulland\u0131\u011f\u0131m\u0131z <code>packages.&lt;system&gt;.default</code> yap\u0131s\u0131na bencer olan <code>devShells.&lt;system&gt;.default</code> yap\u0131s\u0131n\u0131 kullan\u0131yoruz. Resmi dok\u00fcmanlardan da konuyu detayl\u0131 inceleyebilirsiniz.</p> <p>\u015eimdi biraz \u00f6rnek yapal\u0131m. Diyelimki bir backend'i dotnet 8, frontend'i ise NodeJs 18 olan bir web uygulamas\u0131 geli\u015ftiriyoruz. Bu uygulama i\u00e7in gerekli olan .net core sdk's\u0131n\u0131, nodejs'i, npm'i, yarn'\u0131 ve pnpm'i kullanmak istiyoruz. Bunun i\u00e7in a\u015fa\u011f\u0131daki gibi bir flake dosyas\u0131 olu\u015fturabiliriz.</p> <p>Burada bir \u00e7ok \u015fey tan\u0131d\u0131k zaten tek fark in blo\u011fundaki <code>devShells.&lt;system&gt;.default</code> yap\u0131s\u0131. Bu yap\u0131n\u0131n i\u00e7ine gerekli paketleri yaz\u0131yoruz. Dikkat ederseniz <code>node2nix</code> paketini de ekledim. Bu paketin amac\u0131 nodejs paketlerini nix paketlerine d\u00f6n\u00fc\u015ft\u00fcrmek. Detaylar i\u00e7in Github sayfas\u0131n\u0131 ziyaret edebilirsiniz. Ayr\u0131ca Javascript development ortam\u0131 i\u00e7in resmi dok\u00fcmanlar\u0131 da kesinlikle ziyaret edin. Dotnet i\u00e7in de yine resmi dok\u00fcmanlara bi g\u00f6z atman\u0131z\u0131 tavsiye ederim.</p> <pre><code>{\n  description = \"Dotnet \u00e7al\u0131\u015fma ortam\u0131m\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n\n  outputs = {\n    self,\n    nixpkgs,\n  }: let\n    system = \"x86_64-linux\";\n\n    overlays = [\n        (final: prev: rec {\n          nodejs = prev.nodejs_18;\n          # nodejs paketlerinden birini y\u00fckl\u00fcyoruz\n          pnpm = prev.nodePackages.pnpm;\n          # yarn'\u0131 nodejs ile uyumlu y\u00fckl\u00fcyoruz\n          yarn = (prev.yarn.override { inherit nodejs; });\n        })\n      ];\n\n    pkgs = import nixpkgs {inherit system overlays;};\n\n\n  in {\n     devShells.${system}.default = pkgs.mkShell {\n                packages = with pkgs;\n                        [\n                          dotnet-sdk_8\n                          # https://github.com/svanderburg/node2nix\n                          # npm yerine bunu kullanmak \u00f6zellikle nix paketi olu\u015fturulacaksa daha efektif\n                          node2nix\n                          nodejs\n                          pnpm\n                          yarn\n                        ];\n                };\n  };\n}\n</code></pre> <p>Asp.net core ile proje olu\u015fturdu\u011fumuz klas\u00f6r\u00fcn root dizinine bu flake dosyas\u0131n\u0131 koyup <code>nix develop</code> komutunu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda ilgili paketler y\u00fcklenecek. Kurulum bitti\u011finde de bizi otomatik olarak terminal bu ara\u00e7lar\u0131n kurulu oldu\u011fu bir terminal olacak. E\u011fer terminalde <code>which dotnet</code> komutunu \u00e7al\u0131\u015ft\u0131r\u0131rsak /nix/store/ ile ba\u015flayan bir dizin g\u00f6rece\u011fiz. Ba\u015fka bir terminalde ayn\u0131 komutu test etti\u011finizde e\u011fer nix paket y\u00f6neticisi d\u0131\u015f\u0131nda dotnet y\u00fcklediysek onun adresini g\u00f6rece\u011fiz, y\u00fcklemediysek bo\u015f d\u00f6necektir. Herhangi bir terminalde proje dizinideyken <code>nix develop</code> komutunu \u00e7al\u0131\u015ft\u0131r\u0131rsak terminalimiz projemizin b\u00fct\u00fcn ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131n y\u00fcklenmi\u015f oldu\u011fu bir terminale d\u00f6n\u00fc\u015fecektir.</p> <p>Terminalde alttaki testleri yaparak i\u015flemin do\u011fru yap\u0131ld\u0131\u011f\u0131ndan emin olabiliriz.</p> <pre><code>node --version\n# v18.19.1\n\ndotnet --version\n# 8.0.101\n\nnpm --version\n# 10.2.4\n\n\nwhich node\n# /nix/store/1ihd9lyhn8q73n9s3iaxbilx4mn4nc5b-nodejs-18.19.1/bin/node\n</code></pre> <p>Birden fazla sistem i\u00e7in alttaki gibi bir yap\u0131 kullanabilirsiniz.</p> <pre><code>{\n  description = \"Dotnet \u00e7al\u0131\u015fma ortam\u0131m\"\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n\n  outputs = {\n    self,\n    nixpkgs,\n  }: let\n    supportedSystems = [\"x86_64-linux\" \"aarch64-linux\" \"x86_64-darwin\" \"aarch64-darwin\"];\n    forEachSupportedSystem = f:\n      nixpkgs.lib.genAttrs supportedSystems (system:\n        f {\n          pkgs = import nixpkgs {inherit system;};\n        });\n  in {\n    devShells = forEachSupportedSystem ({pkgs}: {\n      default = pkgs.mkShell {\n        packages = with pkgs; [\n          dotnet-sdk_7\n        ];\n      };\n    });\n  };\n}\n</code></pre> <p>mkshell fonksiyonunu resmi repo'daki adresinden inceleyecek olursak alttaki gibi bir yap\u0131 g\u00f6rece\u011fiz. \u00dcstte yapt\u0131\u011f\u0131m\u0131z \u00f6rnekte do\u011frudan development ortam\u0131n\u0131n ihtiyac\u0131 olan paketleri belirledik. Alttaki listede g\u00f6rd\u00fc\u011f\u00fcm\u00fcz input'lar ise bu paketlerin input'lar\u0131ndan development ortam\u0131n\u0131n ihtiyac\u0131 olan paketleri belirlemek i\u00e7in kullan\u0131l\u0131yor.</p> <pre><code>{ lib, stdenv, buildEnv }:\n\n# A special kind of derivation that is only meant to be consumed by the\n# nix-shell.\n{ name ? \"nix-shell\"\n, # a list of packages to add to the shell environment\n  packages ? [ ]\n, # propagate all the inputs from the given derivations\n  inputsFrom ? [ ]\n, buildInputs ? [ ]\n, nativeBuildInputs ? [ ]\n, propagatedBuildInputs ? [ ]\n, propagatedNativeBuildInputs ? [ ]\n, ...\n}@attrs:\n</code></pre> <p>\u00d6rne\u011fin daha \u00f6nceki uygulamalar\u0131m\u0131zda kulland\u0131\u011f\u0131m\u0131z message uygulamam\u0131z\u0131 kullanarak mevzuyu anlamaya \u00e7al\u0131\u015fal\u0131m.</p> <p>Bu C diliyle yaz\u0131lm\u0131\u015f uygulamadan derivative olu\u015fturacak message.nix ad\u0131nda ayn\u0131 dizinde bir dosya olu\u015ftural\u0131m.</p> <pre><code>{pkgs}:\n        pkgs.stdenv.mkDerivation (finalAttrs: rec{\n              name = \"message\";\n              version = \"v3.0\";\n\n              src = builtins.fetchTarball {\n                        url = \"https://github.com/muratcabuk/simple-message-app-with-c/archive/refs/tags/${version}.tar.gz\";\n                        sha256 = \"sha256:1a4a2i32da9shc2d3i1ndarmla97bald7lgs1vjmwyjlry0mk4m7\";\n                    };\n\n              buildInputs = [ pkgs.gcc ];\n              nativeBuildInputs = [ pkgs.autoconf pkgs.libtool pkgs.makeWrapper ];\n              buildPhase = \"gcc -o message ${src}/message.c\";\n              installPhase = \"mkdir -p $out/bin; install -t $out/bin message\";\n\n              meta = with pkgs.lib; {\n                    description = \"message uygulams\u0131\";\n                    license = licenses.mit;\n                    version =  \"${version}\";\n                };\n        })\n</code></pre> <p>Amac\u0131m\u0131z hem derivative olu\u015fturmak hem de development ortam\u0131nda ihtiyac\u0131m olan paketlerin bir k\u0131sm\u0131n\u0131 da bu derivative'in input'lar\u0131ndan belirlemek. Bunun i\u00e7in alttaki gibi bir flake yaz\u0131yoruz.</p> <pre><code>{\n  description = \"Message uygulamas\u0131 development ortam\u0131\";\n\n  inputs.nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n\n  outputs = {\n    self,\n    nixpkgs,\n  }: let\n    system = \"x86_64-linux\";\n\n    pkgs = import nixpkgs {inherit system;};\n\n    packages.${system}.default = pkgs.callPackage ./message.nix {pkgs = pkgs;};\n  in {\n    devShells.${system}.default = pkgs.mkShell {\n      packages = with pkgs; [dotnet-sdk_7];\n      inputsFrom = [packages.${system}.default];\n      nativeBuildInputs = [packages.${system}.default];\n    };\n\n    packages = packages;\n  };\n}\n</code></pre> <p>Dikkat ederseniz development ortam\u0131m\u0131z i\u00e7in do\u011frudan belirledi\u011fimiz paket sadece dotnet-sdk_7 oldu. Di\u011fer paketleri ise <code>inputsFrom</code> ve <code>nativeBuildInputs</code> ile <code>message.nix</code> dosyas\u0131ndan al\u0131yoruz. Bu sayede <code>nix develop</code> komutu ile development ortam\u0131m\u0131z\u0131 olu\u015fturdu\u011fumuzda <code>message.nix</code> dosyas\u0131nda belirledi\u011fimiz paketler de otomatik olarak y\u00fcklenecek. Test etmek amac\u0131yla <code>nix develop</code> komutu \u00e7al\u0131\u015ft\u0131r\u0131p terminalde gcc komutunu \u00e7al\u0131\u015ft\u0131r\u0131rsak onunda y\u00fcklendi\u011fini g\u00f6rece\u011fiz. Ayr\u0131ca yazd\u0131\u011f\u0131m\u0131z uygulamay\u0131 da test edebiliriz. Ayr\u0131ca istersek <code>nix run .#</code> komutu ile yazd\u0131\u011f\u0131m\u0131z uygulamay\u0131 da test edebiliriz.</p> <p>Asl\u0131nda bu konu belki de Nix paket y\u00f6neticisi i\u00e7in paket yazmay\u0131 d\u00fc\u015f\u00fcnen developer'lar i\u00e7in daha fazla vakit ay\u0131rmalar\u0131 gereken bir konu.</p> <ul> <li>Farkl\u0131 programlama dillerini i\u00e7eren development ortamlar\u0131 olu\u015fturmak i\u00e7in template'ler i\u00e7in g\u00fczel bir Github reposu</li> <li>Bir \u00e7ok programlama dilini i\u00e7eren \u00f6rnek development ortamlar\u0131. \u00d6rnek uygulamalar da mevcut. NixOS resmi repos'undan inceleyebilirsiniz</li> <li>Verloper'lar i\u00e7in faydal\u0131 bir derleme olmu\u015f. Genel anlamda resmi dok\u00fcmanlar\u0131n \u00f6rneklerle anlat\u0131lm\u0131\u015f bir \u00f6zeti gibi. \u015eu linkten inceleyebilirsiniz. Soldaki men\u00fcden ilgilendi\u011finiz dili se\u00e7melisiniz</li> </ul>"},{"location":"nix_package/developer_ve_profile_ortamlari_olusturmak.html#developer-ortamlar-icin-nix-tabanl-diger-araclar","title":"Developer Ortamlar\u0131 i\u00e7in Nix Tabanl\u0131 Di\u011fer Ara\u00e7lar","text":"<p>Developer ortamlar\u0131n\u0131z i\u00e7in bu i\u015fe daha fazla odaklanm\u0131\u015f, daha profesyonel ve daha fazla \u00f6zellik sunan bir \u00e7ok ara\u00e7 mevcut. Bunlardan baz\u0131lar\u0131n\u0131 altta listeledim. \u00d6zellikle birden fazla ki\u015fiyle \u00e7al\u0131\u015f\u0131yorsan\u0131z ve herkesin do\u011frudan NixOS veya Nix paket y\u00f6neticisi le muhatap olmas\u0131n\u0131 da istemiyorsan\u0131z bu ara\u00e7lar\u0131 kullanman\u0131z\u0131 tavsiye ederim. Hatta bir \u00e7ok yerde dev ortamlar\u0131 i\u00e7in developer'lar\u0131n alttaki ara\u00e7lar\u0131 nix develop komutu yerine tercih ettiklerini okudum.</p> <ul> <li> <p>devbox: Aralar\u0131nda en \u00e7ok kullan\u0131lan ve en \u00e7ok y\u0131ld\u0131z alan proje bu. \u0130ncelemenizi kesinlikle tavsiye ederim. Dockerhub benzeri nixhub ad\u0131nda bir paket deposu var. Burada arama yapabiliyorsunuz. Go dili ile yaz\u0131lm\u0131\u015f bir cli'\u0131 var. Quickstart i\u00e7in \u015fu sayfay\u0131 ziyaret edebilirsiniz.</p> </li> <li> <p>devshell</p> </li> <li> <p>devpacks</p> </li> <li> <p>devenv</p> </li> </ul>"},{"location":"nix_package/developer_ve_profile_ortamlari_olusturmak.html#nix-profile-ile-kalc-profil-olusturmak","title":"Nix Profile ile Kal\u0131c\u0131 Profil Olu\u015fturmak","text":"<p>Daha \u00f6nce \"nix profile\" komutunu g\u00f6rm\u00fc\u015ft\u00fck. Temelde <code>niz shell</code> komutu ge\u00e7ici kurulum yaparken <code>nix profile</code> ise kal\u0131c\u0131 kurulum yapar demi\u015ftik. Yukar\u0131da g\u00f6rd\u00fc\u011f\u00fcm\u00fcz <code>nix develop</code> ise proje bazl\u0131 kurulum yap\u0131yordu. Ancak <code>nix profile</code> komutu inceledi\u011fimiz yaz\u0131m\u0131zda declarative bir kullan\u0131m\u0131 yoktu. Ancak <code>nix profile</code> komutu ile de declarative bir \u015fekilde kal\u0131c\u0131 bir profile olu\u015fturabiliriz. B\u00f6ylece sistemimizi kurduktan sonra b\u00fct\u00fcn uygulama kurulumlar\u0131n\u0131 tek bir yerden y\u00f6netebiliriz.</p> <p>Basit bir \u00f6rnekle ba\u015flayal\u0131m. Alttaki kodlar\u0131 flake.nix ad\u0131nda bir doya olu\u015fturup i\u00e7ine kopyalayal\u0131m.</p> <pre><code>{\n  description = \"Murat Cabuk Profile\";\n\n  inputs = {\n      nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    };\n\n  outputs = { self, nixpkgs, }:\n        {\n        packages.x86_64-linux.default = let\n           system = \"x86_64-linux\";\n           pkgs = import nixpkgs {inherit system;};\n           # pkgs = nixpkgs.legacyPackages.\"x86_64-linux\";\n        in pkgs.buildEnv {\n                name = \"murat-cabuk-profile\";\n                paths = with pkgs; [\n                                    ffmpeg\n                                    jq.override { name = \"pjq\"; }\n                                    vim\n                                    ];\n                pathsToLink = [ \"/share/man\" \"/share/doc\" \"/share/info\" \"/bin\" \"/etc\" ];\n                extraOutputsToInstall = [ \"man\" \"doc\" \"info\" ];\n                postBuild = ''\n                                echo i\u015fleme tamam &gt;&gt; log.txt\n                            '';\n                        };\n\n\n        };\n}\n</code></pre> <p>Bu flake dosyas\u0131n\u0131n oldu\u011fu dizinde <code>nix profile install .</code> komutunu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda ekledi\u011fimiz uygulamalar kurulacakt\u0131r. E\u011fer uygulamada bir g\u00fcncelleme yaparsak <code>nix profile upgrade &lt;profile_index&gt;</code> komutu ile g\u00fcncelleyebiliriz. Profile indeksini almak i\u00e7in <code>nix profile list</code> komutu ile \u00f6\u011frenebiliriz.</p> <p>Burada art\u0131k overlay ve override gibi konulara girmiyorum eski yaz\u0131lardan bak\u0131labilir. Ayr\u0131ca <code>nix profile</code> komutu ile ilgili daha fazla bilgi i\u00e7in resmi dok\u00fcmanlar\u0131 inceleyebilirsiniz.</p> <p>Daha karma\u015f\u0131k \u00f6rnekler i\u00e7in de NixOS resmi dok\u00fcmanlar\u0131n\u0131 da okuyabilirsiniz.</p> <p>Evet buraya kadar g\u00f6rd\u00fcklerimizde NixOS'a hi\u00e7 ihtiyac\u0131m\u0131z olmad\u0131. Zaten ilk yaz\u0131larda da belirtti\u011fim gibi Nix temelde distro ba\u011f\u0131ms\u0131z bir paket y\u00f6neticisi yani temel amac\u0131 asl\u0131nda bu. NixOS ise Nix Dilinin ve paket y\u00f6neticisinin yetenekleri \u00fczerine in\u015fa edilmi\u015f bir Linux da\u011f\u0131t\u0131m\u0131.</p> <p>Bir \u00e7ok developer \u00fcstteki dev ortamlar\u0131 olu\u015fturma arac\u0131n\u0131 NixOS'a hi\u00e7 bula\u015fmadan hatta hi\u00e7 Nix dilini \u00f6\u011frenmeden kullan\u0131yor. Yada bir \u00e7ok kullan\u0131c\u0131 NixOS'u sadece Konfig\u00fcrasyon yapacak kadar \u00f6\u011freniyor. Yani Nix dilinden bile habersiz NixOS kullanan dolusuyla son kullan\u0131c\u0131 var.</p> <p>Tabi bizim amac\u0131m\u0131z Nix dilini de paket y\u00f6neticisini de ve NixOS'u da m\u00fcmk\u00fcn olduk\u00e7a hakk\u0131n\u0131 vererek \u00f6\u011frenebilmek. Tabi b\u00fct\u00fcn bunlar sadece bu yaz\u0131lar\u0131 okuyarak olmayacakt\u0131r. Ancak size ciddi bir ba\u015flang\u0131\u00e7 yapman\u0131z\u0131 sa\u011flayacakt\u0131r.</p> <p>Sonraki yaz\u0131m\u0131zda NixOS'a ge\u00e7i\u015f yapaca\u011f\u0131z ancak ilk etapta nas\u0131l kurulur konusuna girmeyece\u011fiz. \u00c7\u00fcnk\u00fc ilk kurulum i\u00e7in asl\u0131nda normal herhangi bir Linux da\u011f\u0131t\u0131m\u0131ndan farkl\u0131 kurulmuyor. Ancak elimizde bir Nix konfig\u00fcrasyonu varsa durum biraz de\u011fi\u015fiyor. E\u011fer elimizde konfig\u00fcrasyon dosyalar\u0131 varsa bu durumda sadece flake.nix dosyas\u0131n\u0131 da i\u00e7eren root dizinin vermemiz kurulum i\u00e7in yeterli olacakt\u0131r.</p> <p>\u0130lk etapta Youtube'dan bulaca\u011f\u0131n\u0131z herhangi bir kurulum video'su ile sisteminizi kurabilirsiniz. MEvzumuz ilk etapta zaten kurulum detaylar\u0131 ile ilgilenmek de\u011fil. Ancak elimizde orta halli bir NixOS konfig\u00fcrasyonu olu\u015ftu\u011funda art\u0131k s\u0131f\u0131rdan manuel kurulu yerine declarative y\u00f6ntemle kurulum yapaca\u011f\u0131z.</p>"},{"location":"nix_package/developer_ve_profile_ortamlari_olusturmak.html#kaynaklar","title":"Kaynaklar","text":"<ul> <li>https://nixos.wiki/wiki/Development_environment_with_nix-shell</li> <li>https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-mkShell</li> <li>https://nixos.wiki/wiki/Nixpkgs/Create_and_debug_packages</li> <li>https://github.com/nix-community/nixpkgs-fmt</li> <li>https://blog.ysndr.de/posts/guides/2021-12-01-nix-shells/</li> <li>https://github.com/the-nix-way/dev-templates</li> <li>https://discourse.nixos.org/t/problem-combining-multiple-dotnet-sdks-in-usable-flake/32431</li> <li>https://github.com/NixOS/nixpkgs/blob/master/doc/languages-frameworks/dotnet.section.md</li> <li>https://nixos.org/manual/nixpkgs/stable/#sec-building-environment</li> <li>https://ianthehenry.com/posts/how-to-learn-nix/how-to-learn-nixpkgs/</li> <li>https://jade.fyi/blog/flakes-arent-real/</li> </ul>"},{"location":"nix_package/nix_flake_nedir.html","title":"Nix Flake Nedir?","text":"<p>Nix Flake, Nix dilindeki paketleri, mod\u00fclleri ve konfig\u00fcrasyonlar\u0131 daha etkili bir \u015fekilde y\u00f6netmek i\u00e7in tasarlanm\u0131\u015ft\u0131r.</p> <p>Flake, \u00f6zellikle projeleri ve paketleri tan\u0131mlamak, payla\u015fmak ve bir arada tutmak i\u00e7in tasarlanm\u0131\u015f bir yap\u0131 sunar. Flake'lar kullan\u0131larak paket olu\u015fturma, ba\u011f\u0131ml\u0131l\u0131klar\u0131 y\u00f6netme ve da\u011f\u0131tma i\u015flemleri standart hale getirilmi\u015f oluyor. Flake'leri tam kar\u015f\u0131l\u0131\u011f\u0131 olmasa da NodeJs'deki gibi package.json dosyas\u0131 veya dotnet'deki csproj dosyas\u0131na benzetebiliriz. Flake biraz daha geni\u015f kapsaml\u0131 bir kavram bir nevi hem proje dosyam\u0131z hem de \u00e7al\u0131\u015ft\u0131r\u0131labilir kodlar\u0131m\u0131z\u0131n oldu\u011fu bir yap\u0131d\u0131r.</p> <p>Flake yap\u0131s\u0131 ile Nix eko sisteminde bir \u00e7ok yeni komut ve \u00f6zellikler de eklenmi\u015f oluyor. Eski komutlar\u0131n neredeyse hepsi de\u011fi\u015fmi\u015f veya yeni komutlar ile birle\u015ftirilmi\u015f.</p> <p>Bir paket olu\u015fturacak \u00f6nce flake.nix olu\u015fturuyoruz ve onun arkas\u0131nda geli\u015ftirdi\u011fimiz bir \u00e7ok nix dosyas\u0131n\u0131 kullanarak derivation olu\u015fturup bunu build al\u0131yoruz. Bu sayede nix paketimiz olu\u015fuyor. Ancak art\u0131k yeni versiyonda ileride g\u00f6rece\u011fimiz NixOS konfig\u00fcrasyonunu yaparken kulland\u0131\u011f\u0131m\u0131z konfig\u00fcrasyon dosyalar\u0131 bile art\u0131k flake'in bir mod\u00fcl\u00fc durumunda.</p> <p>Flake dedi\u011fimiz \u015feyde asl\u0131nda halen bir nix dosyas\u0131. Sadece belli bir formatta ve belirli baz\u0131 mod\u00fclleri kullanarak olu\u015fturulmu\u015f bir nix dosyas\u0131. Daha fazla detay i\u00e7in \u015fuan 2.8 versiyon i\u00e7in \u015fu resmi sayfay\u0131 inceleyebilirsiniz.</p>"},{"location":"nix_package/nix_flake_nedir.html#temel-flake-komutlar","title":"Temel Flake Komutlar\u0131","text":"<ul> <li>nix flake clone: Flake repo'sunu klonlar.</li> <li>nix flake info: Flake metadata verileri g\u00f6sterir.</li> <li>nix flake init: Aktif dizinde flake olu\u015fturur.</li> <li>nix flake lock: Lock dosyas\u0131 olu\u015fturur. Bu bildi\u011fimiz NodeJs deki package-lock.json dosyas\u0131 ile ayn\u0131 i\u015fi yapar.</li> <li>nix flake new: Haz\u0131r template'leri kullanarak yeni bir flake olu\u015fturur.</li> <li>nix flake show: Flake output'unu g\u00f6sterir.</li> <li>nix flake update: Flake lock dosyas\u0131n\u0131 g\u00fcnceller.</li> <li>nix flake archive: Flake'i ve b\u00fct\u00fcn input'lar\u0131n\u0131 Stor'a kopyalar.</li> </ul> <p>Flake dosyas\u0131n\u0131n standart bir \u015femas\u0131 var. \u015eimdilik basit Bir Flake dosyas\u0131n\u0131 inceleyelim. C dilinde yaz\u0131lm\u0131\u015f basit bir uygulamay\u0131 paketleyen (yani derivation) nix kodu. Daha detayl\u0131 flake anlat\u0131m\u0131 i\u00e7in \u015fu linki ve ziyaret edebilirsiniz.</p> <pre><code>{\n  description = \"A flake for building Hello World\";\n\n  inputs.nixpkgs.url = \"github:NixOS/nixpkgs/nixos-20.03\";\n\n  outputs = { self, nixpkgs }: {\n\n    packages.x86_64-linux.default = with import nixpkgs { system = \"x86_64-linux\"; };\n            stdenv.mkDerivation {\n                        name = \"hello\";\n                        src = self;\n                        buildPhase = \"gcc -o hello ./hello.c\";\n                        installPhase = \"mkdir -p $out/bin; install -t $out/bin hello\";\n                    };\n\n              };\n}\n</code></pre> <p>Bu Flake kodu, \"Hello World\" adl\u0131 basit bir C program\u0131n\u0131 derleyip kurmak i\u00e7in bir Nix Flake'ini temsil eder. Kodu ad\u0131m ad\u0131m inceleyelim:</p> <ol> <li> <p>description: Flake'in k\u0131sa bir a\u00e7\u0131klamas\u0131. Bu durumda, \"Hello World\" program\u0131n\u0131 derlemek i\u00e7in bir Flake olu\u015fturdu\u011funu belirtir.</p> </li> <li> <p>inputs.nixpkgs.url: Bu, Flake'in ba\u011f\u0131ml\u0131l\u0131klar\u0131ndan biri olan <code>nixpkgs</code>'in kaynak konumunu belirtir. Bu \u00f6rnekte, <code>nixos-20.03</code> branch'ini GitHub \u00fczerinden al\u0131r.</p> </li> <li> <p>outputs: fonksiyonu, self ve nixpkgs'i parametre olarak al\u0131r. Yani, self ve nixpkgs fonksiyona giri\u015f parametreleridir ve fonksiyonun i\u00e7inde bu parametreler kullan\u0131larak \u00e7\u0131kt\u0131lar \u00fcretilir.</p> </li> <li> <p>packages.x86_64-linux.default: Bu, \u00e7\u0131kt\u0131n\u0131n bir par\u00e7as\u0131 olan bir paketin tan\u0131mland\u0131\u011f\u0131 b\u00f6l\u00fcmd\u00fcr. Bu paket, <code>x86_64-linux</code> sistem i\u00e7in derlenmi\u015f bir <code>hello</code> adl\u0131 basit bir programd\u0131r.</p> </li> <li> <p>with import nixpkgs { system = \"x86_64-linux\"; }: <code>nixpkgs</code>'i belirli bir sistemle (burada x86_64-linux) i\u00e7e aktar\u0131r ve onu kullan\u0131labilir hale getirir.</p> </li> <li> <p>stdenv.mkDerivation {...}: Bir t\u00fcretilmi\u015f (derivation) ifadesini ba\u015flat\u0131r ve gerekli \u00f6zellikleri belirtir. Di\u011fe bir versiyonu daha basit hali builtins.derivation fonksiyonudur. ise Standart Environment'\u0131n k\u0131saltmas\u0131d\u0131r. Paket i\u00e7in gerekli olan environment'i ifade eder. Biz bu \u00f6rnek flake'de buildPhase ve installPhase kulland\u0131k ancak daa bir \u00e7ok safha var tabii ki. Hem standard environment hem de di\u011fer safhalar i\u00e7in NisOs manual sayfas\u0131ndaki Standard Environment ve Phases sayfalar\u0131n\u0131 kesinlikle incelemenizi \u00f6neririm.</p> <ul> <li>name: derivation ad\u0131, bu durumda \"hello\".</li> <li> <p>src: Kaynak dosyalar\u0131n bulundu\u011fu dizin. Bu \u00f6rnekte <code>self</code> ifadesi, bu flake'in bulundu\u011fu dizini ifade eder.</p> </li> <li> <p>buildPhase: Derleme a\u015famas\u0131n\u0131 tan\u0131mlar. Bu durumda, <code>gcc</code> kullan\u0131larak <code>hello.c</code> dosyas\u0131n\u0131n derlenmesini sa\u011flar.</p> </li> <li> <p>installPhase: Kurulum a\u015famas\u0131n\u0131 tan\u0131mlar. Derlenen <code>hello</code> program\u0131n\u0131 \u00e7\u0131kt\u0131 dizinine kopyalar.</p> </li> </ul> </li> </ol> <p>Bu Flake, <code>nix flake build</code> komutu kullan\u0131larak derlenebilir. Derleme sonucunda hello ad\u0131nda bir uygulama (paket) olu\u015fur.</p> <p>Flake \u015femas\u0131 detaylar\u0131 hakk\u0131nda \u015eu sayfay\u0131 da ziyaret edeblirsiniz.</p> <p>Tabi flake dedi\u011fimiz kurgu bu kadar yal\u0131n olmuyor. Ayr\u0131ca i\u00e7ine y\u00fczlerce ba\u011f\u0131ml\u0131l\u0131k alan hatta onlarca lokal nix mod\u00fcl\u00fc import eden flake'ler yaz\u0131l\u0131yor.</p> <p>Bir flake output olarak alttakileri \u00fcretebilir.</p> <ul> <li>Nix Paketleri</li> <li>Nix Geli\u015ftirme Ortamlar\u0131</li> <li>NixOS Mod\u00fclleri (Nix Configuration)</li> <li>Nix Template'leri (haz\u0131r flake dosyalar\u0131)</li> </ul> <p>Hepsini de vakti geldi\u011finde g\u00f6rece\u011fiz. \u015eimdilik sadece paket olu\u015fturmay\u0131 ve Flake yap\u0131s\u0131n\u0131 \u00f6\u011frenmeye \u00e7al\u0131\u015fal\u0131m.</p>"},{"location":"nix_package/nix_flake_nedir.html#flake-olusturma","title":"Flake Olu\u015fturma","text":"<p>Basitden karma\u015f\u0131\u011fa do\u011fru gidelim. \u00d6nce basit bir flake olu\u015ftural\u0131m.</p> <p>Bir klas\u00f6r olu\u015fturup i\u00e7ine flake.nix dosyas\u0131 olu\u015ftural\u0131m. Kendim flake-first ad\u0131nda bir klas\u00f6r olu\u015fturup onun i\u00e7ine flake.nix dosyas\u0131 olu\u015fturdum.</p> <pre><code>{\n  outputs = { self }: {\n    mesaj = \"Merhaba D\u00fcnya!\";\n  };\n}\n</code></pre> <p>Yaz\u0131labilecek en k\u00fc\u00e7\u00fck flake dosyas\u0131 bu olabilir. Burada self kelimesi do\u011frudan flake'in kedisini ifade eder. Laziness i\u00e7in bu gereklidir. Self kelimesi sayesinde hem nested (i\u00e7 i\u00e7e) flake'ler olu\u015fturulabilir Ayr\u0131ca flake i\u00e7inde kendi \u00e7\u0131kt\u0131lar\u0131na (output) ve attribute'lar\u0131na (\u00f6zellik) eri\u015fim sa\u011flanabilir.</p> <p>\u015eimdi kodumuzu bir test edelim. Bunun i\u00e7in alttaki komutu kullanabiliriz. Eval komutu asl\u0131nda nix expression'lar\u0131 de\u011ferlendirmek i\u00e7in kullan\u0131l\u0131r. Dolay\u0131s\u0131yla bizim kodumuz da bir nix expression.</p> <pre><code>nix eval .#mesaj\n\n# sonu\u00e7\n#\"merhaba d\u00fcnya\"\n</code></pre> <p>Yava\u015f yava\u015f kosumuzu geli\u015ftirelim.</p> <pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs\";\n  };\n\n  outputs = { self, nixpkgs }: {\n    mesaj = \"Merhaba D\u00fcnya!\";\n  };\n}\n</code></pre> <p>\u00d6Zel bir\u015fey yapmad\u0131\u011f\u0131m\u0131z i\u00e7in kodu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda bir de\u011fi\u015fiklik olmayacakt\u0131r.</p> <p>\u015eimdi basit bir uygulamay\u0131 build al\u0131p \u00e7al\u0131\u015ft\u0131rmay\u0131 deneyelim.</p> <p>\u00d6rneklerde en \u00e7ok kullan\u0131lan hello world uygulamas\u0131n\u0131 kullanaca\u011f\u0131z.</p> <p>Bir klas\u00f6r olu\u015fturup (ben merhaba ad\u0131nda olu\u015fturdum). Daha sonra klas\u00f6re merhaba.c ad\u0131nda bir dosya olu\u015ftural\u0131m ve i\u00e7ine alttaki kodlar\u0131 kopyalayal\u0131m.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Merhaba D\u00fcnya!\\n\");\n    return 0;\n}\n</code></pre> <p>Ayn\u0131 dizine flake.nix dosyas\u0131 olu\u015fturup i\u00e7ine alttaki kodlar\u0131 kopyalayal\u0131m.</p> <pre><code>{\n  description = \"Merhaba D\u00fcnya! i\u00e7in flake\";\n\n  # input olarak nixpkgs'i al\u0131yoruz.\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs\";\n  };\n\n  # output olarak self ve nixpkgs'i al\u0131yoruz.\n  outputs = { self, nixpkgs }: {\n\n    # bu standart olarak kullan\u0131lmal\u0131. flake \u015femas\u0131n\u0131n zorunlu tuttu\u011fu bir attribute\n    packages.x86_64-linux.default = with import nixpkgs { system = \"x86_64-linux\"; };\n\n    stdenv.mkDerivation {\n                         name = \"merhaba\";\n                         src = self;\n                         buildPhase = \"gcc -o merhaba ./merhaba.c\";\n                         installPhase = \"mkdir -p $out/bin; install -t $out/bin merhaba\";\n\n    };\n}\n</code></pre> <p>Kodumuzu \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce neler d\u00f6nd\u00fc\u011f\u00fcne bakal\u0131m.</p> <ul> <li>nixpkgs.stdenv.mkDerivation: Bu, bir t\u00fcretilmi\u015f (derivation) ifadesini ba\u015flat\u0131r ve gerekli \u00f6zellikleri belirtir. Bu fonksiyonun i\u00e7indeki \u00f6zellikler \u015fu \u015fekilde:</li> <li>name: derivation ad\u0131, bu durumda \"merhaba\".</li> <li>src: Kaynak dosyalar\u0131n bulundu\u011fu dizin. Bu \u00f6rnekte self ifadesi, bu flake'in bulundu\u011fu dizini ifade eder.</li> <li>buildPhase: Derleme a\u015famas\u0131n\u0131 tan\u0131mlar. Bu durumda, gcc kullan\u0131larak merhaba.c dosyas\u0131n\u0131n derlenmesini sa\u011flar.</li> <li>installPhase: Kurulum a\u015famas\u0131n\u0131 tan\u0131mlar. Derlenen merhaba program\u0131n\u0131 \u00e7\u0131kt\u0131 dizinine kopyalar.</li> <li>builder: Burada yok ancak istersek builder i\u00e7in bir executable tan\u0131mlayabiliriz. Mesela bash'i kullan\u0131p ona bir script'i (args) parametre olarak ge\u00e7irebiliriz.</li> <li>args: builder i\u00e7in gerekli olan di\u011fer parametreler mesela bir script dosyas\u0131. E\u011fer Docker hakk\u0131nda bilginiz varsa bunu entrypoint.sh gibi d\u00fc\u015f\u00fcnebilirsiniz. Daha fazla detay i\u00e7in \u015fu sayfay\u0131 ziyaret edebilirsiniz. Ayr\u0131ca nixpkgs alt\u0131nda bulunan builder'lar\u0131 da \u015fu resmi Github sayfas\u0131nda g\u00f6rebilirsiniz.   <pre><code>  builder = \"${pkgs.bash}/bin/bash\";\n  args = [ ./hello_builder.sh ];\n</code></pre></li> <li>packages.x86_64-linux.default: Bu zorunlu bir attribute. x86_64-linux k\u0131sm\u0131 build ald\u0131\u011f\u0131m\u0131z sisteme g\u00f6re de\u011fi\u015fiklik g\u00f6sterir yani hedef sistemimize g\u00f6re buraya uygun sistem ad\u0131n\u0131 yazmal\u0131y\u0131z. \u00d6rne\u011fin aarch64-apple-darwin14, aarch64-pc-linux-gnu, x86_64-w64-mingw32, aarch64-apple-ios.</li> </ul> <p>Art\u0131k bir uygulamam\u0131z var. Build almadan \u00e7al\u0131\u015ft\u0131ramay\u0131z haliyle. Amac\u0131m\u0131z uygulamam\u0131z\u0131 flake \u00fczerinden sadece build almak. Bunun i\u00e7in <code>nix build</code> komutunu \u00e7al\u0131\u015ft\u0131r\u0131yoruz. Komut \u00e7al\u0131\u015ft\u0131ktan sonra klas\u00f6re gidip bakt\u0131\u011f\u0131m\u0131zda alttaki gibi merhaba ad\u0131nda bir klas\u00f6r ve bir de flake.lock ad\u0131nda bir dosya g\u00f6rece\u011fiz.</p> <p></p> <p>Result klas\u00f6r\u00fcnde uygulamam\u0131z\u0131n binary'sini g\u00f6rebilirsiniz. Uygulamam\u0131z\u0131 do\u011frudan bu dizinden \u00e7a\u011f\u0131rabiliriz.</p> <pre><code>./result/bin/merhaba\n# Merhaba D\u00fcnya!\n</code></pre> <p>Yada daha \u00f6nce g\u00f6rd\u00fc\u011f\u00fcm\u00fcz <code>nix shell</code> komutu ile de \u00e7a\u011f\u0131rabiliriz.</p> <pre><code>nix shell --command merhaba\n# Merhaba D\u00fcnya!\n</code></pre> <p>Lock dosyas\u0131 ise Nix ve Nix Flake ba\u011flam\u0131nda, kilit dosya (lock file), bir derleme s\u0131ras\u0131nda kullan\u0131lan ba\u011f\u0131ml\u0131l\u0131klar\u0131n tam s\u00fcr\u00fcmlerini kaydetmek i\u00e7in kullan\u0131lan bir mekanizmad\u0131r. nix build komutunu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131n\u0131zda, Nix, derlemenin her seferinde belirli ba\u011f\u0131ml\u0131l\u0131klar\u0131n kullan\u0131ld\u0131\u011f\u0131ndan emin olmal\u0131d\u0131r. Kilit dosyas\u0131, bu s\u00fcr\u00fcmleri belirli bir i\u015fleme sabitleyerek bu amaca hizmet eder. Tabi bizim paketimizde henuz ciddi bir ba\u011f\u0131ml\u0131l\u0131k yok ancak \u00f6rnek flake dosyalar\u0131n\u0131 incelerseniz ba\u011f\u0131ml\u0131l\u0131k versiyonlar\u0131n\u0131n ne kadar \u00f6nemli oldu\u011funu anlayabilirsiniz. Zaten e\u011fer bir yaz\u0131l\u0131m geli\u015ftiriciyseniz bunu \u00e7om defa deneyimlemi\u015fsinizdir.</p> <p>Lock dosyas\u0131 sayesinde sistem \u00e7\u0131kt\u0131lar\u0131 cache'leyebilir. Girdilerde mesela bir de\u011fi\u015fiklik yoksa sistem baz\u0131 ad\u0131mlar\u0131 cache'den \u00e7al\u0131\u015ft\u0131rabilir. Diyelim ki flake.ini dosyas\u0131nda baz\u0131 de\u011fi\u015fiklikler yapt\u0131k. E\u011fer sistem build al\u0131rken bu de\u011fi\u015fiklikleri g\u00f6rmezse <code>nix flake update</code> komutunu \u00e7al\u0131\u015ft\u0131rmay\u0131 unutmay\u0131n. Zaten update yap\u0131p tekrar build al\u0131rsan\u0131z s\u00fcrenin tekrar uzad\u0131\u011f\u0131n\u0131 g\u00f6rebilirsiniz.</p> <p>\u0130leride i\u015fimize yarayacak baz\u0131 flake komutlar\u0131na bakal\u0131m. Flake yazmaya devam edece\u011fiz bu arada, daha karma\u015f\u0131k flake'ler yazaca\u011f\u0131z.</p> <p>Az \u00f6nce yazd\u0131\u011f\u0131m\u0131z flake dizininde alttaki komutlar\u0131 \u00e7al\u0131\u015ft\u0131ral\u0131m.</p> <p><code>nix flake show</code></p> <p>Build al\u0131nan uygulaman\u0131n paket bilgilerini g\u00f6sterir.</p> <pre><code>nix flake show\n\n# alttaki gibi bir sonu\u00e7 g\u00f6rmeniz laz\u0131m\n\npath:.../flake-merhaba?lastModified=1705065665&amp;narHash=sha256-uvTQB%2ByMrr/2qA0OseVV/8FYeGIA31RUTG9%2Bhql7WmU%3D\n\u2514\u2500\u2500\u2500packages\n\u2514\u2500\u2500\u2500x86_64-linux\n\u2514\u2500\u2500\u2500default: package 'merhaba'\n</code></pre> <p>Bu ekrana bakarak mesela alttaki komutlar\u0131 \u00e7al\u0131\u015ft\u0131rabiliriz.</p> <pre><code>nix run .#default\n# Merhaba D\u00fcnya!\n\n# shell ile kurulum yap\u0131yoruz\nnix shell .#default\n# merhaba uygulamas\u0131n\u0131 \u00e7al\u0131\u015ft\u0131r\u0131yoruz\nmerhaba\n# Merhaba D\u00fcnya!\n</code></pre> <p><code>nix flake metadata</code></p> <p>Flake dosyas\u0131ndaki metadata verileri ve lock dosyas\u0131ndaki metadata verilerini g\u00f6sterir.</p> <pre><code>nix flake metadata\n\nResolved URL:  path:...flake-merhaba\nLocked URL:    path:.../flake-merhaba?lastModified=1705065665&amp;narHash=sha256-uvTQB%2ByMrr/2qA0OseVV/8FYeGIA31RUTG9%2Bhql7WmU%3D\nDescription:   Merhaba D\u00fcnya! i\u00e7in flake\nPath:          /nix/store/m2wlbd9g2yzagxv4zhv7rx8n4n3wwlvg-source\nLast modified: 2024-01-12 16:21:05\nInputs:\n\u2514\u2500\u2500\u2500nixpkgs: github:nixos/nixpkgs/c6b7be9ad761d5e74bf3132971e155d41c91925d\n</code></pre> <p>\u015eimdi ba\u015fka bir haz\u0131r flake'i kendi flake'imizde kullanal\u0131m. Ba\u015fka bir klas\u00f6rde deneyelim. Ben merhaba-hello ad\u0131nda bir klas\u00f6re alttaki kodu bir flake.nix dosyas\u0131na kopyalad\u0131m. Ancak \u00f6nceki \u00f6rne\u011fimizden <code>merhaba.c</code> dosyam\u0131z\u0131 da al\u0131p bu klas\u00f6re koymal\u0131y\u0131z.</p> <pre><code>{\n  description = \"Merhaba D\u00fcnya! i\u00e7in flake\";\n\n  # input olarak nixpkgs'i al\u0131yoruz.\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs\";\n  };\n\n  # output olarak self ve nixpkgs'i al\u0131yoruz.\n  outputs = { self, nixpkgs }: {\n\n    # bu standart olarak kullan\u0131lmal\u0131. flake \u015femas\u0131n\u0131n zorunlu tuttu\u011fu bir attribute\n    packages.x86_64-linux.default = with import nixpkgs { system = \"x86_64-linux\"; };\n\n    stdenv.mkDerivation {\n                         name = \"merhaba\";\n                         src = self;\n                         buildPhase = \"gcc -o merhaba ./merhaba.c\";\n                         installPhase = \"mkdir -p $out/bin; install -t $out/bin merhaba\";\n\n    };\n\n    packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;\n\n\n};\n}\n</code></pre> <p>\u015eimdi build al\u0131p bir \u00e7\u0131kt\u0131lar\u0131na bakal\u0131m</p> <pre><code>nix build\n\nnix flake show\n\npath:.../flake-merhaba?lastModified=1705068716&amp;narHash=sha256-HztHa%2BdkFp2jYbItkr9llJy7bBSsKYj1EqkvsndIji8%3D\n\u2514\u2500\u2500\u2500packages\n\u2514\u2500\u2500\u2500x86_64-linux\n\u251c\u2500\u2500\u2500default: package 'merhaba'\n\u2514\u2500\u2500\u2500hello: package 'hello-2.12.1'\n</code></pre> <p>O zaman hello paketini \u00e7a\u011f\u0131rabiliriz.</p> <pre><code>nix run .#hello\n\n# Hello, world!\n</code></pre> <p>Peki o zaman \u015funu soral\u0131m kendimize. E\u011fer <code>nix flake show</code> komutu bir flake'in bilgilerini g\u00f6steriyorsa biz nixpkgs'yi de bu \u015fekilde inceleyebilir miyiz? Sonu\u00e7ta \u015funu demi\u015ftik nixpkgs'de asl\u0131nda bir flake.</p> <pre><code>nix flake show github:NixOS/nixpkgs\n\ngithub:NixOS/nixpkgs/391d29cb04fe2ca9a4744c10d6b8a7783f6b0f6d\n\u251c\u2500\u2500\u2500checks\n\u2502   \u2514\u2500\u2500\u2500x86_64-linux\n\u2502       \u251c\u2500\u2500\u2500nixosSystemAcceptsLib: derivation 'nixos-system-nixos-24.05.20240112.391d29c'\n\u2502       \u2514\u2500\u2500\u2500tarball: derivation 'nixpkgs-tarball-24.05pre20240112.391d29c'\n\u251c\u2500\u2500\u2500htmlDocs: unknown\n\u251c\u2500\u2500\u2500legacyPackages\n\u2502   \u251c\u2500\u2500\u2500aarch64-darwin omitted (use '--legacy' to show)\n\u2502   \u251c\u2500\u2500\u2500aarch64-linux omitted (use '--legacy' to show)\n\u2502   \u251c\u2500\u2500\u2500armv5tel-linux omitted (use '--legacy' to show)\n\u2502   \u251c\u2500\u2500\u2500armv6l-linux omitted (use '--legacy' to show)\n\u2502   \u251c\u2500\u2500\u2500armv7l-linux omitted (use '--legacy' to show)\n\u2502   \u251c\u2500\u2500\u2500i686-linux omitted (use '--legacy' to show)\n\u2502   \u251c\u2500\u2500\u2500mipsel-linux omitted (use '--legacy' to show)\n\u2502   \u251c\u2500\u2500\u2500powerpc64le-linux omitted (use '--legacy' to show)\n\u2502   \u251c\u2500\u2500\u2500riscv64-linux omitted (use '--legacy' to show)\n\u2502   \u251c\u2500\u2500\u2500x86_64-darwin omitted (use '--legacy' to show)\n\u2502   \u2514\u2500\u2500\u2500x86_64-linux omitted (use '--legacy' to show)\n\u251c\u2500\u2500\u2500lib: unknown\n\u2514\u2500\u2500\u2500nixosModules\n\u251c\u2500\u2500\u2500notDetected: NixOS module\n\u2514\u2500\u2500\u2500readOnlyPkgs: NixOS module\n</code></pre> <p>Sonu\u00e7lara bakt\u0131\u011f\u0131m\u0131zda legacyPackage'lar i\u00e7in komuta --legacy etiketini eklememiz gerekti\u011fini g\u00f6r\u00fcyoruz. Sonu\u00e7ta benim amac\u0131m hello paketini listede g\u00f6rmek.</p> <pre><code>nix flake show github:NixOS/nixpkgs --legacy\n</code></pre> <p>Komutu bu \u015fekilde \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda listenin ekrana s\u0131\u011fmas\u0131na imkan yok. O y\u00fczden filtreleme yapal\u0131m. Bunu i\u00e7in Nix json format\u0131nda liste veriyor. Jq kullanarak filtreleme yapabiliriz.</p> <pre><code>nix flake show --json github:NixOS/nixpkgs --legacy|jq '.legacyPackages.\"x86_64-linux\" | with_entries(select(.key | contains(\"hello\")))'\n\n# SONU\u00c7\n\nwarning: legacyPackages.aarch64-darwin omitted (use '--all-systems' to show)\nwarning: legacyPackages.aarch64-linux omitted (use '--all-systems' to show)\nwarning: legacyPackages.armv5tel-linux omitted (use '--all-systems' to show)\nwarning: legacyPackages.armv6l-linux omitted (use '--all-systems' to show)\nwarning: legacyPackages.armv7l-linux omitted (use '--all-systems' to show)\nwarning: legacyPackages.i686-linux omitted (use '--all-systems' to show)\nwarning: legacyPackages.mipsel-linux omitted (use '--all-systems' to show)\nwarning: legacyPackages.powerpc64le-linux omitted (use '--all-systems' to show)\nwarning: legacyPackages.riscv64-linux omitted (use '--all-systems' to show)\nwarning: legacyPackages.x86_64-darwin omitted (use '--all-systems' to show)\n{\n\"hello\": {\n\"description\": \"A program that produces a familiar, friendly greeting\",\n\"name\": \"hello-2.12.1\",\n\"type\": \"derivation\"\n},\n\"hello-unfree\": {\n\"description\": \"An example package with unfree license (for testing)\",\n\"name\": \"example-unfree-package-1.0\",\n\"type\": \"derivation\"\n},\n\"hello-wayland\": {\n\"description\": \"Hello world Wayland client\",\n\"name\": \"hello-wayland-unstable-2023-10-26\",\n\"type\": \"derivation\"\n}\n}\n</code></pre> <p>Listede ilk s\u0131radaki paket bizim yukar\u0131da \u00e7a\u011f\u0131r\u0131p kulland\u0131\u011f\u0131m\u0131z hello paketi. Versiyonunu da 2.12.1 olarak g\u00f6r\u00fcyoruz.</p> <p>Birde nixpkgs'nin metadata's\u0131na bakal\u0131m.</p> <pre><code>nix flake metadata  github:NixOS/nixpkgs\n\nResolved URL:  github:NixOS/nixpkgs\nLocked URL:    github:NixOS/nixpkgs/e52366c4d82286ccb62bd6812e370141466d53c0\nDescription:   A collection of packages for the Nix package manager\nPath:          /nix/store/jqypdy1dcvlz7i9qlgd7g5wvmjknzs6f-source\nRevision:      e52366c4d82286ccb62bd6812e370141466d53c0\nLast modified: 2024-01-14 16:17:14\n</code></pre> <p>Lokal makinemde nixpkgs <code>/nix/store/jqypdy1dcvlz7i9qlgd7g5wvmjknzs6f-source</code> dizininde g\u00f6r\u00fcn\u00fcyor. Bu dizine gitti\u011fimizde nixpkgs'nin b\u00fct\u00fcn kodlar\u0131n\u0131 g\u00f6rebiliriz.</p> <p></p> <p>Yani asl\u0131nda nixpkgs de bizim yazd\u0131\u011f\u0131m\u0131z flake'ler gibi bir flake. Tek fark\u0131 b\u00fct\u00fcn paketleri i\u00e7inde bar\u0131nd\u0131r\u0131yor olmas\u0131. Dolay\u0131s\u0131yla neredeyse her g\u00fcn commit al\u0131yor. Mesele NixOS kullan\u0131yor olsayd\u0131k onunla ilgili repolar\u0131'da yine buradan kullanacakt\u0131k.</p> <p></p> <p>Biz asl\u0131nda nixpkgs kulland\u0131\u011f\u0131m\u0131zda sistem onu GitHub'dan indirip kullan\u0131yor. Dolay\u0131s\u0131yla yukar\u0131da hello paketini arad\u0131\u011f\u0131m\u0131z kodu \u015fu \u015fekilde de \u00e7al\u0131\u015ft\u0131rabiliriz. Sonu\u00e7 ayn\u0131 olacakt\u0131r.</p> <pre><code>nix flake show --json /nix/store/jqypdy1dcvlz7i9qlgd7g5wvmjknzs6f-source --legacy|jq '.legacyPackages.\"x86_64-linux\" | with_entries(select(.key | contains(\"hello\")))'\n</code></pre> <p>Kod standartlar\u0131 i\u00e7in resmi repo'sunda yer alan contribution sayfas\u0131ndaki Code Convention sayfas\u0131 \u00f6rnek olabilir.</p>"},{"location":"nix_package/nix_flake_nedir.html#git-uzerinden-kaynak-kodu-almak","title":"Git \u00dczerinden Kaynak Kodu Almak","text":"<p>\u015eimdiki \u00f6rne\u011fimizde C ile yazm\u0131\u015f olu\u011fumuz kodu GitH\u0131b \u00fczerinden al\u0131p build alaca\u011f\u0131z. Kendim message ad\u0131nda bir klas\u00f6re flake.nix dosyam\u0131 olu\u015fturup alttaki kodlar\u0131 kopyalad\u0131m. Github'a nas\u0131l kod konulur ve nas\u0131l tag at\u0131l\u0131r vb konulara burada girmemiz \u00e7ok m\u00fcmk\u00fcn de\u011fil. Zaten konuyla akal\u0131 bir \u00e7ok kaynak bulabilirsiniz. Kendim ufak bir uygulama koydum kendi Github hesab\u0131ma size onu kullanabilirsiniz ilk testlerinizde.</p> <pre><code># flake.nix\n\n{\n  description = \"Simple Message App with C\";\n\n  inputs = {\n    nixpkgs.url = github:NixOS/nixpkgs/nixos-unstable;\n  };\n\n  outputs ={ self, nixpkgs, ... }:\n\n    let\n\n      simpleMessageAppSrc = \"https://github.com/muratcabuk/simple-message-app-with-c/archive/refs/tags/v1.0.tar.gz\";\n\n      # Simple Message App'in kaynak dizini\n      src = builtins.fetchTarball {\n        url = simpleMessageAppSrc;\n        sha256 = \"sha256:1aai9xdkgq2vd0ch10gxhg53qfv4ny2x3jgxlq4r9nrn4g9r8s1z\";\n      };\n\n       # Program\u0131 derleme komutu\n      buildCommand = ''\n                        gcc -o simple-message-app ${src}/message.c\n                     '';\n\n    in\n    {\n\n      packages.x86_64-linux.default = with import nixpkgs { system = \"x86_64-linux\"; };\n\n      stdenv.mkDerivation {\n        name = \"simple-message-app\";\n        version = \"v1.0\";\n        src = src;\n        buildInputs = [ gcc ];\n        nativeBuildInputs = [ autoconf libtool makeWrapper ];\n        buildPhase = buildCommand;\n        installPhase = \"mkdir -p $out/bin; install -t $out/bin simple-message-app\";\n\n        meta = with nixpkgs.lib; {\n          description = \"Simple Message App with C\";\n          license = licenses.mit;\n          version = \"v1.0\";\n        };\n      };\n\n\n\n\n    };\n}\n</code></pre> <p>Kodda GitHub'dan release edilmi\u015f kodlar\u0131 ald\u0131\u011f\u0131m\u0131z i\u00e7in fetchTarball kulland\u0131k ama di\u011ferleri de hatta alttakilerden daha fazlas\u0131 da mevcut.</p> <ul> <li>builtins.fetchGit: Git repo'lar\u0131ndan dosya indirmek i\u00e7in kullan\u0131l\u0131r. Mesela her zaman en s\u00fcr\u00fcm\u00fc almak i\u00e7in kullan\u0131labilir.</li> <li>builtins.fetchClosure: Nix store'da bulunan bir dosyay\u0131 indirmek i\u00e7in kullan\u0131l\u0131r.</li> <li>builtins.fetchTarball: Tarball dosyalar\u0131n\u0131 indirmek i\u00e7in kullan\u0131l\u0131r.</li> <li>builtins.fetchurl: URL'den dosya indirmek i\u00e7in kullan\u0131l\u0131r.</li> </ul> <p>Builtins fonksiyonlar\u0131 d\u0131\u015f\u0131nda da nixpkgs alt\u0131nda daha bir \u00e7ok fonksiyon bulunmaktad\u0131r. \u015eu sayfadan bakabilirsiniz.</p> <ul> <li>fetchDebianPatch</li> <li>fetchsvn</li> <li>fetchgit</li> <li>fetchcvs</li> <li>fetchFromGitea</li> <li>fetchFromGitHub</li> <li>fetchFromGitLab</li> <li>fetchFromGitiles</li> <li>fetchFromBitbucket</li> <li>fetchFromSavannah</li> <li>fetchFromRepoOrCz</li> <li>fetchFromSourcehut</li> <li>requireFile</li> <li>fetchtorrent</li> </ul> <p>\u015eimdi kodumuzu built al\u0131p test edelim.</p> <pre><code>nix build --impure\nnix run .#default\n# sonu\u015fta size bir kelime sorup onu ekrana yazacak\n</code></pre> <p>Ancak bu haliyle kodumuz geni\u015fleyebilir ve kullan\u0131\u015fl\u0131 de\u011fil. Ayr\u0131ca tabi burada \u00e7ok karma\u015f\u0131k i\u015fler yapm\u0131yoruz ancak hakikaten ciddi bir uygulamay\u0131 paket yap\u0131yor olsak belki onlarca ba\u011f\u0131ml\u0131l\u0131k ve build ve deploy i\u015flemleri i\u00e7in y\u00fczlerce sat\u0131r yazmam\u0131z gerekebilirdi. Bundan dolay\u0131 daha moduler yazmak i\u015fimizi kolayla\u015ft\u0131racakt\u0131r.</p> <p>Mesela derivative olu\u015fturma k\u0131sm\u0131n\u0131 biraz daha parametrik yazsak her versiyonda kullanabilir. \u015eu haliyle kodumuz sadece tek bir versiyon i\u00e7in kullan\u0131labilir g\u00f6r\u00fcn\u00fcyor. E\u011fer paketimizi her zaman en son versiyonu build alacak \u015fekilde yazsayd\u0131k o zaman bu kod i\u015fimizi g\u00f6rebilirdi. Tabi o zaman release edilmi\u015f bir tar dosyas\u0131n\u0131 de\u011filde do\u011frudan \u00f6rne\u011fim master branch'in en son commit'ini kullanabilirdik.</p> <p>\u015eimdi Bunun i\u00e7in yeni bir klas\u00f6r (message-second) a\u00e7\u0131yorum ve \u00f6ncelikle derivative k\u0131sm\u0131n\u0131 ay\u0131rmak i\u00e7in alttaki kodlar\u0131 <code>derivation.nix</code> ad\u0131nda bir dosya olu\u015fturup kopyal\u0131yorum.</p> <p>Daha \u00f6nceki derslerden hat\u0131rlayabilece\u011fimiz \u00fczere bu bir fonksiyon tan\u0131m\u0131. Bu sayede daha karma\u015f\u0131k s\u00fcre\u00e7leri y\u00f6netmemiz kolayla\u015facak.</p> <pre><code># derivation.nix\n{pkgs, stdenv, gcc, selectedVersion, ...}:\n\n\n    let\n\nsimpleMessageAppSrc = \"https://github.com/muratcabuk/simple-message-app-with-c/archive/refs/tags/${selectedVersion.version}.tar.gz\";\n\n      shaSet = {v10=\"sha256:1aai9xdkgq2vd0ch10gxhg53qfv4ny2x3jgxlq4r9nrn4g9r8s1z\";\n                v20=\"sha256:11p3c793yjpm4z4j9shlidbii7wd0kf9qflx8jqhhnwwhqf93mam\";\n                v30=\"sha256:1a4a2i32da9shc2d3i1ndarmla97bald7lgs1vjmwyjlry0mk4m7\";};\n\n      shaVer = builtins.concatStringsSep \"\" (pkgs.lib.strings.splitString \".\" \"${selectedVersion.version}\");\n\n\n      versionSha = builtins.getAttr shaVer shaSet;\n\n      # Simple Message App'in kaynak dizini\n      src = builtins.fetchTarball {\n        url = simpleMessageAppSrc;\n        sha256 = versionSha;\n      };\n\n    in\n        stdenv.mkDerivation (finalAttrs: {\n              name = \"simple-message-app\";\n              version = \"${selectedVersion.version}\";\n\n              src = src;\n\n              buildInputs = [ gcc ];\n              buildPhase = \"gcc -o simple-message-app ${src}/message.c\";\n              installPhase = \"mkdir -p $out/bin; install -t $out/bin simple-message-app\";\n\n              meta = with pkgs.lib; {\n                    description = \"Simple Message App with C\";\n                    license = licenses.mit;\n                    version =  \"${selectedVersion.version}\";\n                };\n        })\n</code></pre> <p>Kod asl\u0131nda \u00e7ok karma\u015f\u0131k de\u011fil. Verilen versiyon numaras\u0131na g\u00f6re tar dosyas\u0131 i\u00e7in gerekli hash \u00fcretiliyor ve kod indirilip build a\u015famas\u0131na kaynak kodu src parametresi ile ta\u015f\u0131n\u0131yor.</p> <p>Bir tane de <code>flake.nix</code> ad\u0131nda br dosya olu\u015fturup alttaki kodlar\u0131 da ona kopyalad\u0131m.</p> <pre><code># flake.nix\n{\n  description = \"Simple Message App with C\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  };\n\n  outputs ={ self, nixpkgs, ... }:\n    let\n\n      derivation = import ./derivation.nix;\n      selectedVersion = {version = \"v1.0\";};\n\n    in\n    {\n      packages.x86_64-linux.default = with import nixpkgs { system = \"x86_64-linux\"; config.allowUnfree = true; };\n\n      derivation {pkgs = import nixpkgs { system = \"x86_64-linux\"; config.allowUnfree = true; };\n                  stdenv = stdenv; gcc = gcc;\n                  selectedVersion = selectedVersion;\n                  };\n    };\n}\n</code></pre> <p>'Derivation.nix' dosyam\u0131z bir module olarak i\u00e7eri import ediliyor ve in blo\u011fu i\u00e7inde derivation fonksiyonu olarak \u00e7a\u011fr\u0131l\u0131yor. Bu versiyonun g\u00fczel taraf\u0131 bir kere derivation fonksiyonun karma\u015fas\u0131 ba\u015fka bir mod\u00fcle b\u0131rak\u0131lm\u0131\u015f olmas\u0131 ve bu fonksiyonun \u00e7al\u0131\u015fabilmesi i\u00e7in gerekli parametrelerin haz\u0131rlanma i\u015finin de flake i\u00e7inde halledilmi\u015f olmas\u0131. B\u00f6ylece istedi\u011fimiz versiyon numaras\u0131n\u0131 parametre olarak fonksiyona ge\u00e7ip paketimizi olu\u015fturabiliyoruz.</p> <p>Ancak bu haliyle de kodumuz \u00e7ok kullan\u0131\u015fl\u0131 de\u011fil. \u00d6rne\u011fin derivative s\u00fcrecini y\u00f6neten fonksiyonumuz neden ilgili versiyonun kaynak kodunu indirme s\u00fcrecini de y\u00f6netiyor? yani kaynak kod derivation i\u00e7in bir girdi asl\u0131nda. Her yeni versiyon i\u00e7in bu kodu de\u011fi\u015ftirmek zorunda kalaca\u011f\u0131z. Ayr\u0131ca birde diyelim ki versiyonda bir g\u00fcncelleme oldu yine bu kodu de\u011fi\u015ftirmek zorunda kalaca\u011f\u0131z \u00e7\u00fcnk\u00fc kod de\u011fi\u015fince hash de de\u011fi\u015fmi\u015f olacak. Daha dinamik bir yap\u0131 kursak daha olacak gibi.</p> <p>Bunun i\u00e7in yeni bir klas\u00f6r olu\u015ftural\u0131m ad\u0131 message-third olsun. Daha sonra alttaki kodlar\u0131 <code>derivation.nix</code> ad\u0131nda bir dosyaya kopyalayal\u0131m.</p> <pre><code># derivaiton.nix\n{pkgs, stdenv, gcc, selectedVersion, src, ...}:\n\n    let\n\n    # Simple Message App'in kaynak dizini\n      srcDrv = src;\n\n\n    in\n        stdenv.mkDerivation (finalAttrs: {\n              name = \"simple-message-app\";\n              version = \"${selectedVersion.version}\";\n\n              src = srcDrv;\n\n              buildInputs = [ gcc ];\n              buildPhase = \"gcc -o simple-message-app ${src}/message.c\";\n              installPhase = \"mkdir -p $out/bin; install -t $out/bin simple-message-app\";\n\n              meta = with pkgs.lib; {\n                    description = \"Simple Message App with C\";\n                    license = licenses.mit;\n                    version =  \"${selectedVersion.version}\";\n                };\n        })\n</code></pre> <p>Flake.nix i\u00e7inde alttaki kodu kullan\u0131yoruz.</p> <pre><code># flake.nix\n\n{\n  description = \"Simple Message App with C\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  };\n\n  outputs ={ self, nixpkgs, ... }:\n    let\n\n      selectedVersion = {version = \"v1.0\";};\n\n      simpleMessageAppSrc = \"https://github.com/muratcabuk/simple-message-app-with-c/archive/refs/tags/${selectedVersion.version}.tar.gz\";\n\n      shaSet = {v10=\"sha256:1aai9xdkgq2vd0ch10gxhg53qfv4ny2x3jgxlq4r9nrn4g9r8s1z\";\n                v20=\"sha256:11p3c793yjpm4z4j9shlidbii7wd0kf9qflx8jqhhnwwhqf93mam\";\n                v30=\"sha256:1a4a2i32da9shc2d3i1ndarmla97bald7lgs1vjmwyjlry0mk4m7\";};\n\n      shaVer = builtins.concatStringsSep \"\" (nixpkgs.lib.strings.splitString \".\" \"${selectedVersion.version}\");\n\n      versionSha = builtins.getAttr shaVer shaSet;\n\n      # Simple Message App'in kaynak dizini\n      src = builtins.fetchTarball {\n        url = simpleMessageAppSrc;\n        sha256 = versionSha;\n      };\n\n      derivation = import ./derivation.nix;\n\n    in\n    {\n      packages.x86_64-linux.default = with import nixpkgs { system = \"x86_64-linux\"; config.allowUnfree = true; };\n\n      derivation {pkgs = import nixpkgs { system = \"x86_64-linux\"; config.allowUnfree = true; };\n                  stdenv = stdenv; gcc = gcc;\n                  selectedVersion = selectedVersion;\n                  src = src;};\n    };\n}\n</code></pre> <p>Art\u0131k derivation dosyam\u0131z kendi i\u015fine daha fazla odaklanm\u0131\u015f oldu.</p> <p>Build almay\u0131 ve \u00e7al\u0131\u015ft\u0131rmay\u0131 biliyoruz art\u0131k tekrar yazm\u0131yorum.</p>"},{"location":"nix_package/nix_flake_nedir.html#flakei-githubda-yaynlamak","title":"Flake'i Github'da Yay\u0131nlamak","text":"<p>Github'da bir repo a\u00e7\u0131p i\u00e7ine message-third i\u00e7indeki flake ve derivation dosyalar\u0131n\u0131 upload ediyoruz. Daha sonra bu repo'yu flake olarak kullanmak i\u00e7in alttaki komutu \u00e7al\u0131\u015ft\u0131r\u0131yoruz. Ben kendi Github sayfamda https://github.com/muratcabuk/nix-examples reposunda yay\u0131nlad\u0131m. Ancak siz bu makaleyi okurken main branch'deki kodlar tabi de\u011fi\u015fmi\u015f olacak. <code>message-third</code> \u00f6rne\u011fimizdeki kodu g\u00f6rebilmeniz i\u00e7in message-third ad\u0131nda bir branch olu\u015fturdum. Bu \u00f6rnekte de o branch'i \u00e7a\u011f\u0131rarak kodumuz test edelim.</p> <p>Komutta github adresine ekledi\u011fimiz message-third k\u0131sm\u0131yla branch \u00e7a\u011f\u0131rm\u0131\u015f oluyoruz.</p> <pre><code>nix run github:muratcabuk/nix-examples/message-third --no-write-lock-file\n</code></pre> <p>Komutu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131n\u0131zda flake.nix dosyas\u0131 alt\u0131nda <code>selectedVersion = {version = \"v1.0\";};</code> hangi versiyon yaz\u0131l\u0131ysa onun build al\u0131n\u0131p \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6rebiliriz.</p> <p>Buraya kadar halen NixOS kullanmad\u0131k. Hala asl\u0131nda Nix dilinin k\u0131y\u0131lar\u0131nda dola\u015fmaya devam ediyoruz. Biraz Biraz paket y\u00f6netimine girdik ama halen biraz daha yolumuz var. <code>nix shell</code> komutunu g\u00f6rd\u00fck ancak orada da asl\u0131nda imperative bir kullan\u0131m yapt\u0131k. Yani herhangi bir proje klas\u00f6r\u00fcne girdi\u011fimizde her defas\u0131nda onlarca ba\u011f\u0131ml\u0131l\u0131\u011f\u0131 elimizle manuel kurmam\u0131z tabii ki anlams\u0131z olacakt\u0131r. Yada kendimize bir profile kurmak istedi\u011fimizde tek tek uygulamalar\u0131 kurmak da mant\u0131ks\u0131z olacakt\u0131r. Zaten bunu b\u00fct\u00fcn paket y\u00f6neticileri bu \u015fekilde yap\u0131yor. Nix felsefesine de zaten bu kullan\u0131m ayk\u0131r\u0131 bir durum. \u0130\u015fte bu nedenle flake'leri ve Nix'in mod\u00fcler yap\u0131s\u0131n\u0131 anlamak \u00e7ok \u00f6nemli.Bu sayede manuel yapt\u0131\u011f\u0131m\u0131z her \u015feyi bir nix dosyas\u0131na declarative bir \u015fekilde yazabilece\u011fiz. Ayr\u0131ca NixOS'un mod\u00fcler yap\u0131s\u0131n\u0131 da anlam\u0131\u015f olaca\u011f\u0131z.</p> <p>Bir flake'in ne t\u00fcr \u00e7\u0131kt\u0131lar \u00fcretebildi\u011fini tekrar hat\u0131rlayal\u0131m.</p> <ul> <li>Nix packages</li> <li>Nix development environments</li> <li>NixOS configurations</li> <li>Nix templates</li> </ul> <p>Dolay\u0131s\u0131yla bir profile olu\u015ftururken veya NixOS i\u00e7in bir konfig\u00fcrasyon ve paket y\u00f6netimi olu\u015fturmak istedi\u011fimizde karma\u015fay\u0131 y\u00f6netmek i\u00e7in mod\u00fcler bir yap\u0131ya ihtiyac\u0131m\u0131z olacak. Dolay\u0131s\u0131yla sadece bir paketi bir GitHub reposunda yay\u0131nlamaktan daha fazlas\u0131n\u0131 yapabiliyor olamam\u0131z gerekiyor.</p> <p>Kendimize bi NixOS ortam\u0131 veya bir profile olu\u015fturmak istedi\u011fimizde asl\u0131nda bir \u00e7ok paketin bir arada \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 g\u00f6rece\u011fiz. Bu paketlerin birbirleriyle uyumlu \u00e7al\u0131\u015fmas\u0131 i\u00e7in bir \u00e7ok parametreyi bir arada y\u00f6netmemiz gerekecek. Bu nedenle bir \u00e7ok paketi bir arada y\u00f6netebilece\u011fimiz bir yap\u0131ya ihtiyac\u0131m\u0131z olacak. \u015eimdi elimizdeki repoyu yaz\u0131 devam ederken devaml\u0131 geli\u015ftirip de\u011fi\u015ftirece\u011fiz.</p> <p>Elimizdeki message uygulamas\u0131 i\u00e7in repomuzda bir message-app ad\u0131nda bir klas\u00f6r olu\u015fturup flake.nix ve derivation.nix dosyalar\u0131n\u0131 i\u00e7ine ta\u015f\u0131yoruz. Kod ileride de\u011fi\u015fece\u011fi i\u00e7in message-app ad\u0131nda bir branch olu\u015fturaca\u011f\u0131m. \u0130leri de kodu incelemek istedi\u011finizde bu branch'den bakabilirsiniz.</p> <p>\u015eimdi art\u0131k bi branch'imiz bir de klas\u00f6r\u00fcm\u00fcz var. Branch ad\u0131n\u0131n repo ad\u0131ndan sonra sla\u015f ile ay\u0131rarak yaz\u0131ld\u0131\u011f\u0131n\u0131 biliyoruz. Klas\u00f6r \u00e7a\u011f\u0131rmak i\u00e7nde <code>?dir=message-app</code> ekliyoruz.</p> <pre><code>nix run \"github:muratcabuk/nix-examples/message-app?dir=message-app\" --no-write-lock-file\n</code></pre> <ul> <li> <p>Belirli bir commit ID'si ile \u00e7a\u011f\u0131rmak i\u00e7in   <code>nix run github:repo_hesabi/repo_adi/commit_id</code></p> </li> <li> <p>Tag ile \u00e7a\u011f\u0131rmak i\u00e7in   <code>nix run github:repo_hesabi/repo_adi/tag</code></p> </li> <li> <p>Branch'deki en son commit ile \u00e7a\u011f\u0131rmak i\u00e7in   <code>nix run github:repo_hesabi/repo_adi/branch_adi</code></p> </li> </ul> <p>Ancak tabiiki bu haliyle kurdu\u011fumuz repo b\u00fct\u00fcn paketleri bir birinden ba\u011f\u0131ms\u0131z olarak sunuyor. Bu yukar\u0131 bahsetti\u011fimiz ama\u00e7lara ula\u015fmam\u0131z i\u00e7in yeteli g\u00f6r\u00fcnm\u00fcyor.</p> <p>Bunu i\u00e7in \u00f6ncelikle ayn\u0131 anda birden fazla paketi nas\u0131l yay\u0131nlanabilce\u011fini \u00f6\u011frenmemiz gerekiyor. Bunu da bir sonraki yaz\u0131m\u0131za b\u0131rakal\u0131m.</p> <p>Bu arada e\u011fer resmi repo'ya nas\u0131l paket ekleyebilece\u011finizi merak ediyorsan\u0131z \u015fu sayfadan bakabilirsiniz.</p>"},{"location":"nix_package/nix_flake_nedir.html#kaynaklar","title":"Kaynaklar","text":"<ul> <li>https://zero-to-nix.com/concepts/flakes</li> <li>https://serokell.io/blog/practical-nix-flakes</li> <li>https://nixos.wiki/index.php?title=Flakes</li> <li>https://www.tweag.io/blog/2020-07-31-nixos-flakes/</li> <li>https://nixos.wiki/wiki/Flakes#Introduction</li> <li>https://determinate.systems/posts/nix-run</li> <li>https://nixos.wiki/wiki/Flakes</li> <li>https://ertt.ca/nix/shell-scripts/</li> <li>https://fasterthanli.me/series/building-a-rust-service-with-nix/part-10</li> <li>https://nix.dev/tutorials/file-sets.html</li> <li>https://nixos.wiki/wiki/Nix_Cookbook#Wrapping_packages</li> <li>https://nixos.org/manual/nixpkgs/stable/#part-stdenv</li> <li>https://ryantm.github.io/nixpkgs/builders/trivial-builders/</li> <li>https://serokell.io/blog/practical-nix-flakes#basic-flake-structure</li> <li>https://lantian.pub/en/article/modify-computer/nixos-packaging.lantian/</li> <li>https://github.com/samdroid-apps/nix-articles</li> <li>https://github.com/djhshih/biopkgs/tree/master</li> <li>https://nixos.wiki/wiki/Nixpkgs/Create_and_debug_packages</li> <li>https://nixos.org/guides/nix-pills/generic-builders</li> </ul>"},{"location":"nix_package/nix_paket_yoneticisi.html","title":"Nix Paket Y\u00f6neticisi","text":"<p>Bir \u00f6nceki makalemizde yal\u0131n olarak Nix dilinin temel yap\u0131lar\u0131n\u0131 ve syntax'\u0131n\u0131 \u00f6\u011frendik. Bu makalemizde ise Nix'in varsay\u0131lan paket repo'su ve kaynak kolaksiyonu olan nixpkgs'yi ve bu paket sistemi ile birlikte gelen lib fonksiyonlar\u0131n\u0131 \u00f6\u011frenece\u011fiz. Bunlar\u0131 \u00f6\u011frenebilmek i\u00e7in de nix paket y\u00f6neticisini detayl\u0131 bir \u015fekilde inceleyece\u011fiz.</p> <p>Nix dilinde <code>builtins</code> ve Nixpkgs i\u00e7indeki <code>lib</code> mod\u00fcl\u00fc, temelde farkl\u0131 ama\u00e7lara hizmet eden fonskiyonlar i\u00e7erirler. \u0130\u015flev ve kullan\u0131m a\u00e7\u0131s\u0131ndan temel farklar \u015funlard\u0131r:</p> <p><code>builtins</code></p> <p>Bu, Nix dilinin temel mod\u00fcl\u00fcd\u00fcr ve bir dizi genel ama\u00e7l\u0131 fonksiyon i\u00e7erir. Bu fonksiyonlar, temel veri t\u00fcrleri \u00fczerinde \u00e7al\u0131\u015fmak, hata kontrol\u00fc yapmak, liste i\u015flemleri ger\u00e7ekle\u015ftirmek ve benzeri temel i\u015flemleri ger\u00e7ekle\u015ftirmek i\u00e7in kullan\u0131l\u0131r. \u00d6rnekler aras\u0131nda <code>length</code>, <code>elem</code>, <code>attrNames</code>, <code>concatLists</code> gibi fonksiyonlar yer al\u0131r. Daha \u00f6nce zaten \u00e7ok detayl\u0131 incelemi\u015ftik. \u00d6rne\u011fin:</p> <pre><code>let\n  myList = [1 2 3];\n  listLength = builtins.length myList;\nin\n  listLength  # 3\n</code></pre> <p><code>lib</code> (Nixpkgs i\u00e7inde)</p> <p>Nixpkgs, geni\u015f bir Nix paket koleksiyonunu i\u00e7eren bir depodur ve <code>lib</code> mod\u00fcl\u00fc, paket geli\u015ftirme ve olu\u015fturma s\u00fcre\u00e7lerini kolayla\u015ft\u0131rmak i\u00e7in bir dizi yard\u0131mc\u0131 fonksiyon i\u00e7erir. Bu fonksiyonlar, genellikle paket olu\u015ftururken veya paketler aras\u0131nda ortak i\u015flemleri ger\u00e7ekle\u015ftirirken kullan\u0131l\u0131r. \u00d6rnekler aras\u0131nda <code>fetchurl</code>, <code>buildInputs</code>, <code>stdenv.mkDerivation</code> gibi fonksiyonlar yer al\u0131r. \u00d6rne\u011fin:</p> <pre><code>{ lib, fetchurl }:\n\nlib.mkDerivation rec {\n  pname = \"example\";\n  version = \"1.0\";\n  src = fetchurl {\n    url = \"https://example.com/source.tar.gz\";\n    sha256 = \"...\";\n  };\n}\n</code></pre> <p>Genel olarak, <code>builtins</code> daha genel ama\u00e7l\u0131 ve temel i\u015flemler i\u00e7in kullan\u0131l\u0131rken, <code>lib</code> fonksiyonlar\u0131 genellikle Nix paket olu\u015fturma s\u00fcre\u00e7lerinde ve daha karma\u015f\u0131k senaryolarda kullan\u0131lmaktad\u0131r.</p> <p>\u00d6ncelikle Nix dilinde module, package, channel ve derivation kavramlar\u0131na teorik olarak de\u011finip ard\u0131ndan uygulamalar\u0131m\u0131za ge\u00e7elim.</p>"},{"location":"nix_package/nix_paket_yoneticisi.html#nix-dilinde-package-ve-derivation-kavram","title":"Nix Dilinde Package ve Derivation Kavram\u0131","text":"<p>Nix dilinde \"package\" ve \"derivation\" terimleri farkl\u0131 kavramlar\u0131 ifade eder. \u0130\u015fte bu iki terim aras\u0131ndaki temel farklar:</p> <p>Package (Paket):</p> <ul> <li>\"Package\", genellikle bir yaz\u0131l\u0131m veya k\u00fct\u00fcphanenin kullan\u0131labilir ve y\u00fcklenilebilir bir formunu ifade eder.</li> <li>Bir paket, belirli bir s\u00fcr\u00fcm\u00fc ve yap\u0131land\u0131rmay\u0131 temsil eder. \u00d6rne\u011fin, bir dilin belirli bir s\u00fcr\u00fcm\u00fc, bir k\u00fct\u00fcphanenin belirli bir s\u00fcr\u00fcm\u00fc veya bir uygulaman\u0131n belirli bir yap\u0131land\u0131rmas\u0131 bir paket olabilir.</li> <li>Paketler, genellikle Nixpkgs deposunda tan\u0131mlanan paket tarifleri (package expressions) kullan\u0131larak olu\u015fturulur. Bu tarifler, paketin nas\u0131l derlenece\u011fi, yap\u0131land\u0131r\u0131laca\u011f\u0131 ve y\u00fcklenece\u011fi gibi bilgileri i\u00e7erir.</li> </ul> <p>Derivation (T\u00fcretim):</p> <ul> <li>\"Derivation\", bir paketin nas\u0131l in\u015fa edilece\u011fini ve y\u00fcklenece\u011fini tan\u0131mlayan bir Nix ifadesidir.</li> <li>Bir derivation, bir paket tarifini i\u00e7erir ve bu tarife dayanarak belirli bir s\u00fcr\u00fcm\u00fc, belirli ba\u011f\u0131ml\u0131l\u0131klar\u0131 ve derleme y\u00f6nergelerini i\u00e7eren bir in\u015fa s\u00fcrecini tan\u0131mlar.</li> <li>Derivations, genellikle <code>stdenv.mkDerivation</code> fonksiyonu kullan\u0131larak olu\u015fturulur. Bu fonksiyon, paketin derleme, kurulum ve di\u011fer a\u015famalarda kullan\u0131lacak talimatlar\u0131 belirtmek i\u00e7in kullan\u0131l\u0131r.</li> <li>Derivations, genellikle <code>nix-build</code> veya <code>nix-shell</code> gibi Nix ara\u00e7lar\u0131 kullan\u0131larak in\u015fa edilir ve paketin olu\u015fturulmu\u015f halini sa\u011flarlar.</li> </ul> <p>\u00d6zetle, \"package\" bir kullan\u0131labilir yaz\u0131l\u0131m veya k\u00fct\u00fcphane b\u00fct\u00fcn\u00fcn\u00fc temsil ederken, \"derivation\" bu paketin nas\u0131l in\u015fa edilece\u011fini ve y\u00fcklenece\u011fini tan\u0131mlayan bir Nix ifadesidir. Bir \"package\" genellikle bir \"derivation\" ile olu\u015fturulur. Build ald\u0131\u011f\u0131m\u0131zda drv (derivation) uzant\u0131l\u0131 bir dosya olu\u015fur. Ancak, bu .drv dosyas\u0131, derlenmi\u015f paketin kendisi de\u011fildir, sadece paketin derlenmesi i\u00e7in gerekli talimatlar\u0131 i\u00e7erir. Ger\u00e7ek derlenmi\u015f dosyalar ve k\u00fct\u00fcphaneler, t\u00fcretim (paket olu\u015fturma) sona erdi\u011finde nix-store'da belirli bir benzersiz klas\u00f6re yerle\u015ftirilir. /nix/store dizininde bir \u00e7ok drv uzant\u0131l\u0131 dosya g\u00f6rebilirsiniz. \u0130\u00e7lerine bakacak olursan\u0131z tamda bahsedildi\u011fi gibi baz\u0131 dosya ve klas\u00f6r isimleri ile birlikte konfig\u00fcrasyonlar g\u00f6rebilirsiniz.</p> <p>Kafan\u0131z\u0131n kar\u0131\u015ft\u0131\u011f\u0131n\u0131 tahmin edebiliyorum. Daha \u00f6nce duymad\u0131\u011f\u0131m\u0131z kavramlar, k\u00fct\u00fcphane ve fonksiyon isimleri duyduk ancak merak etmeyin hepsini bu makalede anlayaca\u011f\u0131z.</p> <p>Biz kurulum yapt\u0131\u011f\u0131m\u0131zda da asl\u0131nda bu drv uzant\u0131l\u0131 dosya okunarak program ilgili dizinlere kurulur.</p> <p>Bu s\u00fcre\u00e7 \u015fu ad\u0131mlardan meydana gelir.</p> <ol> <li> <p>Paket Tarifinin Al\u0131nmas\u0131 (<code>fetch</code>): Nix, paketin tarifini almak i\u00e7in Nixpkgs deposundan (<code>import &lt;nixpkgs&gt; {}</code> kullan\u0131larak) veya bir URL, Git deposu gibi kaynaklardan paket tarifini \u00e7eker.</p> </li> <li> <p>Derivation Olu\u015fturma (<code>nix-build</code> veya benzeri ara\u00e7lar kullan\u0131larak): Al\u0131nan paket tarifi, bir \"derivation\"\u0131 (t\u00fcretim) temsil eder. Bu t\u00fcretim, belirli bir s\u00fcr\u00fcm\u00fc, ba\u011f\u0131ml\u0131l\u0131klar\u0131, derleme talimatlar\u0131n\u0131 ve di\u011fer gerekli bilgileri i\u00e7erir. <code>nix-build</code> veya benzeri ara\u00e7lar kullan\u0131larak bu t\u00fcretim in\u015fa edilir.</p> </li> <li> <p>Derivation'\u0131n Olu\u015fturdu\u011fu <code>.drv</code> Dosyas\u0131: Derleme s\u00fcreci tamamland\u0131\u011f\u0131nda, bu s\u00fcre\u00e7 <code>.drv</code> uzant\u0131l\u0131 bir dosya olu\u015fturur. Bu dosya, derlenmi\u015f paketin in\u015fa edildi\u011fi talimatlar\u0131 i\u00e7erir. Ancak, bu dosya hala derlenmi\u015f paketin kendisi de\u011fildir; sadece t\u00fcretim talimatlar\u0131n\u0131 i\u00e7erir.</p> </li> <li> <p>Derleme Sonucu (<code>realize/instantiation</code>): Derleme sonucunda, <code>.drv</code> dosyas\u0131n\u0131n i\u00e7erdi\u011fi talimatlar kullan\u0131larak <code>/nix/store</code> dizininde bir benzersiz klas\u00f6re derlenmi\u015f dosyalar, k\u00fct\u00fcphaneler ve di\u011fer \u00e7\u0131kt\u0131lar yerle\u015ftirilir. Bu s\u00fcre\u00e7, \"realize\" veya \"instantiation\" ad\u0131n\u0131 al\u0131r.</p> </li> <li> <p>Paketin Kullan\u0131labilir Hale Getirilmesi (<code>nix profile</code>, <code>nix shell</code> vs.): Derlenmi\u015f paketin bulundu\u011fu klas\u00f6r, Nix ara\u00e7lar\u0131 (\u00f6rne\u011fin, <code>nix profile</code> veya <code>nix shell</code>) kullan\u0131larak sistemde kullan\u0131labilir hale getirilir. Bu, paketi sistem genelinde kullan\u0131labilir k\u0131lar veya bir \u00f6zel ortam i\u00e7inde kullan\u0131lmas\u0131n\u0131 sa\u011flar.</p> </li> </ol> <p>Bu s\u00fcre\u00e7, Nix'in fonksiyonel ve deklaratif paket y\u00f6netim modelini temsil eder. Paket tarifleri (package expressions) deklaratif bir \u015fekilde paketin nas\u0131l olu\u015fturulaca\u011f\u0131n\u0131 ifade eder, ve bu ifadeleri kullanarak sistemdeki paketleri olu\u015fturmak ve y\u00f6netmek m\u00fcmk\u00fcn olur.</p> <p>Sonu\u00e7 olarak Nix i\u00e7in paket demek asl\u0131nda bir program\u0131n kurulabilmesi i\u00e7in gerekli derleme talimatlar\u0131n\u0131n oldu\u011fu bir dosyad\u0131r. Bu dosya ile program\u0131n kurulumu yap\u0131l\u0131r.</p>"},{"location":"nix_package/nix_paket_yoneticisi.html#flakes-kavram","title":"Flakes Kavram\u0131","text":"<p>Nix Flake, Nix paket y\u00f6neticisinde bir dizi geli\u015fmi\u015f \u00f6zellik sunan bir \u00f6zelliktir. Flake, Nix dilindeki paketleri, mod\u00fclleri ve konfig\u00fcrasyonlar\u0131 daha etkili bir \u015fekilde y\u00f6netmek i\u00e7in tasarlanm\u0131\u015ft\u0131r. Flake, \u00f6zellikle projeleri ve paketleri tan\u0131mlamak, payla\u015fmak ve bir arada tutmak i\u00e7in tasarlanm\u0131\u015f bir yap\u0131 sunar. Flake'lar kullan\u0131larak paket olu\u015fturma, ba\u011f\u0131ml\u0131l\u0131klar\u0131 y\u00f6netme ve da\u011f\u0131tma i\u015flemleri standart hale getirilmi\u015f oluyor. Flake'leri tam kar\u015f\u0131l\u0131\u011f\u0131 olmasa da NodeJs'deki gibi package.json dosyas\u0131 veya dotnet'deki csproj dosyas\u0131na benzetebiliriz. Flake biraz daha geni\u015f kapsaml\u0131 bir kavram bir nevi hem proje dosyam\u0131z hem de \u00e7al\u0131\u015ft\u0131r\u0131labilir kodlar\u0131m\u0131z\u0131n oldu\u011fu bir yap\u0131d\u0131r.</p> <p>\u0130lerleyen ba\u015fl\u0131klarda sadece flake kavram\u0131 ile ilgili bir yaz\u0131m\u0131z olacak zaten. \u015eimdilik bu konuya bu kadar de\u011finece\u011fiz. Amac\u0131m\u0131z sadece uygulamalara ge\u00e7ti\u011fimizde ne neydi, ne i\u015fe yarard\u0131 bunu anlayacak kadar \u00f6\u011frenmek.</p>"},{"location":"nix_package/nix_paket_yoneticisi.html#nixpkgs-tam-olarak-nedir","title":"Nixpkgs tam olarak nedir?","text":"<p>\u00d6ncelikle NixOS'u incelerken dok\u00fcmanlarda s\u0131kl\u0131kla kar\u015f\u0131la\u015faca\u011f\u0131n\u0131z Channel kavram\u0131ndan bahsedelim. Farkl\u0131 repo kaynaklar\u0131na channel diyoruz. Di\u011fer Linux distro'lar\u0131ndaki repo kavram\u0131na benzer bir yap\u0131s\u0131 var diyebiliriz. Channel'lar\u0131 y\u00f6netmek i\u00e7in nix-channel komutu kullan\u0131l\u0131r. Channel'\u0131n di\u011fer Linux da\u011f\u0131t\u0131mlar\u0131ndaki repo kavram\u0131ndan fark\u0131 channel'\u0131n asl\u0131nda ayn\u0131 repo olsa dahi farkl\u0131 versiyon veya branch'i i\u015faret ediyor olmas\u0131d\u0131r. Ancak mant\u0131k olarak yine de ayn\u0131d\u0131r diyebiliriz. Channel web sayfas\u0131na https://channels.nixos.org/ adresinden ula\u015fabilirsiniz. Ayr\u0131ca channel'lar\u0131n durumunu g\u00f6rmek i\u00e7in de \u015fu linki kullnabilirsiniz: https://status.nixos.org/</p> <p>Ancak channel sistemindeki problemler nedeniyle art\u0131k nix registry kullan\u0131l\u0131yor. Bunun temelini de flake yap\u0131s\u0131 olu\u015fturuyor. Flake'ler lock dosyas\u0131 kullanarak ba\u011f\u0131ml\u0131l\u0131klar\u0131 ve versiyonlar\u0131 daha iyi y\u00f6netiyor. \u00d6rnek nix dosyalar\u0131nda nixpkgs ad\u0131yla import etti\u011fimiz modul asl\u0131nda bir flake'dir. Flake web sayfas\u0131 ise bildi\u011fimiz bir GitHub reposudur. Sayfaya https://github.com/NixOS/nixpkgs adresinden ula\u015fabilirsiniz. Bu yap\u0131da ayn\u0131 reponun klonlar\u0131na veya farkl\u0131 branch'lerine eri\u015fmemiz art\u0131k m\u00fcmk\u00fcn. Ne kadar esnek bir yap\u0131 sundu\u011funu anlayabiliyoruz.</p> <p>Bu arada tekrar hat\u0131rlatmak istiyorum. Bu makaleyi yazarken bask\u0131n bir \u015fekilde her yerde <code>nix-*</code> ile ba\u015flayan komutlar g\u00f6receksiniz. Bunlardan biri de <code>nix-channel</code> olacak. Neredeyse makalede kulland\u0131\u011f\u0131m komut ve anlat\u0131mlar i\u00e7in \u00f6zel \u00e7aba sarfetmeniz gerekebilir. Ancak \u015fuan unstable/experimental bile olsa verdi\u011fim komutlar \u00f6yle g\u00f6r\u00fcn\u00fcyor ki Nix'in gelece\u011fi olacak.</p> <p>Biz path olarak nixpkgs'i verdi\u011fimizde asl\u0131nda sistem bu GitHub repo'sunu import ediyor ve root dizininde bulunan flake.nix ile nested bir \u015fekilde yani i\u00e7 i\u00e7e ge\u00e7en b\u00fct\u00fcn flake'lari sisteme tan\u0131t\u0131yor.</p> <p>Hat\u0131rlarsan\u0131z ilk makalemizde path veri tipinden bahsetmi\u015ftik. Bu veri tipi ile bir dizindeki dosya ve klas\u00f6rleri tan\u0131mlayabiliyorduk. E\u011fer import ederken path veri tipini kullan\u0131rsak, bu dizindeki dosya ve klas\u00f6rlerin i\u00e7eri\u011fini import edebiliyoruz.</p> <p>Bundan ba\u015fka Nix dilinde birde lookup path ad\u0131nda bir tan\u0131mlay\u0131c\u0131 var. Lookup (veya search) path belirtilen adresteki dosyalarda tarama yapma ve uygun olanlar\u0131 import etme imkan\u0131 sa\u011fl\u0131yor. E\u011fer <code>import &lt;nixpkgs&gt; {};</code> bir sat\u0131r g\u00f6recek olursak bu asl\u0131nda nixpkgs burada /nix/var/nix/profiles/per-user/root/channels/nixpkgs adresini temsil eder. E\u011fer bu dizine gidecek olursan\u0131z all-packages.nix ad\u0131nda bir dosya g\u00f6receksiniz. Bu dosyada b\u00fct\u00fcn paketlerin kategorilerini oldu\u011fu klas\u00f6r adresleri vard\u0131r. Bu dosyaya bakacak olursak bir \u00e7ok nix path'inin import edildi\u011fini g\u00f6rebiliriz. Yani sistem bir a\u011fa\u00e7 gibi hep bir ba\u015fka dal\u0131 (di\u011fer bir nix dosyas\u0131n\u0131) import eder. import <code>&lt;nixpkgs&gt; {}</code> ifadesi, Nixpkgs deposundaki bir\u00e7ok \u015feyi i\u00e7eri aktar\u0131r. Bu ifade, sadece varsay\u0131lan paketlerle s\u0131n\u0131rl\u0131 de\u011fildir; ayn\u0131 zamanda builtins gibi temel Nix fonksiyonlar\u0131n\u0131 ve lib gibi k\u00fct\u00fcphane mod\u00fcllerini de i\u00e7erir.</p> <p>Bu arada /nix/var/nix/profiles/per-user/root/channels/nixpkgs dizini bile asl\u0131da /nix/store dizinindeki bir klas\u00f6r\u00fcn symbolic linkidir. Bu disinin bir \u00fcst dini yani /nix/var/nix/profiles/per-user/root/channels dizinine gidecek olursan\u0131z birde manifest.ix dosyas\u0131 var. Bu dosyay\u0131 inceleyecek olursak nixpkgs'nin hangi klas\u00f6re linklendi\u011fini g\u00f6rebiliriz. Bu dizin ayn\u0131 zamanda <code>$HOME/.nix-defexpr/channels</code> dizinine de linklenmi\u015fti. Aktif kullan\u0131c\u0131n\u0131n home dizinindeki .nix-defexpr dizini de nixpkgs'nin linklendi\u011fi dizinlerden biridir.</p> <pre><code>[ {\n  meta = { };\n  name = \"nixpkgs\";\n  out = { outPath = \"/nix/store/64bdf02ly4azvh14x139g4k2ip2gciqy-nixpkgs\"; };\n  outPath = \"/nix/store/64bdf02ly4azvh14x139g4k2ip2gciqy-nixpkgs\";\n  outputs = [ \"out\" ];\n  system = \"builtin\";\n  type = \"derivation\";\n  } ]\n</code></pre> <p>Sonu\u00e7 olarak biz <code>import &lt;nixpkgs&gt; {};</code> sat\u0131r\u0131n\u0131 yazd\u0131\u011f\u0131m\u0131zda sistem bahsetti\u011fimiz dizinlerde arama yaparak b\u00fct\u00fcn mod\u00fclleri y\u00fckler. Moduller ile paket bilgilerini al\u0131r\u0131z, derivation'lar ile ile paketleri t\u00fcretiriz ve bu paketleri de nix yard\u0131m\u0131yla kurar\u0131z. Her mod\u00fcl de bir \u00e7al\u0131\u015ft\u0131rabilir bir uygulama olmak durumunda de\u011fildir. nixpkgs i\u00e7inde \u00f6rne\u011fin bir \u00e7ok kullan\u0131\u015fl\u0131 fonksiyon bulunur. Bizzat bu fonksiyonlar kullan\u0131larak paketler olu\u015fturulur. Hatta ileride g\u00f6rece\u011fimiz NixOS bile bu mod\u00fcller sayesinde ayarlan\u0131r.</p> <p>Baz\u0131 \u00f6nemli dizinlere ve dosyalara bir g\u00f6z atal\u0131m.</p> <ul> <li> <p>/etc/nix/nix.conf dosyas\u0131na bir bakal\u0131m. Bu dosya sistemin genelini ve b\u00fct\u00fcn kullan\u0131c\u0131lar\u0131 etkileyecek ayarlar\u0131 i\u00e7erir. Bu dosyada yap\u0131labilecek ayarlar i\u00e7in \u015fu sayfaya bak\u0131labilir.</p> </li> <li> <p>Di\u011fer \u00f6nemli path ise ~/.local/state/nix/profiles dizinidir. Burada ileride g\u00f6rece\u011fimiz nix profile (komutun eski ad\u0131 nix-env) komutu ile kurdu\u011fumuz paketleri i\u00e7in olu\u015fturulan profillerin listesini g\u00f6rebiliriz. Profiles klas\u00f6r\u00fcne bakacak olursak /nix/store/ dizini alt\u0131ndaki klas\u00f6rlere symbolic link at\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6rebiliriz.</p> </li> </ul> <pre><code>total 28K\nlrwxrwxrwx 1 kullanici_grubu kullanici_adi 14 Ara  8 23:54 profile -&gt; profile-6-link\nlrwxrwxrwx 1 kullanici_grubu kullanici_adi 51 Ara  8 22:32 profile-1-link -&gt; /nix/store/kmkkizwfx283fi3qd3hr2chng0vfciqj-profile\nlrwxrwxrwx 1 kullanici_grubu kullanici_adi 51 Ara  8 22:40 profile-2-link -&gt; /nix/store/yjj04vvlp82mwc2k6gvn81p8d5kb6djb-profile\nlrwxrwxrwx 1 kullanici_grubu kullanici_adi 51 Ara  8 22:58 profile-3-link -&gt; /nix/store/f62qw3gch5zn4fghxdanys6awc8qjbfl-profile\nlrwxrwxrwx 1 kullanici_grubu kullanici_adi 51 Ara  8 22:59 profile-4-link -&gt; /nix/store/0cg7hc464p55cj7l9jgpr7x8314jq7hr-profile\nlrwxrwxrwx 1 kullanici_grubu kullanici_adi 51 Ara  8 23:04 profile-5-link -&gt; /nix/store/kmkkizwfx283fi3qd3hr2chng0vfciqj-profile\nlrwxrwxrwx 1 kullanici_grubu kullanici_adi 51 Ara  8 23:54 profile-6-link -&gt; /nix/store/0zdsafjgba7przfxl43vwq8pb9r9xkyb-profile\n</code></pre> <p>Her bir profil dizini alt\u0131nda manifest.json birde manifest.nix ad\u0131nda bir dosya bulunur. Json doyas\u0131n\u0131 <code>nix profile</code> kullan\u0131rken nix dosyas\u0131n\u0131 <code>nix-env</code> kullan\u0131r. Nix profile nix-env in yeni deneysel s\u00fcr\u00fcm\u00fcd\u00fcr. Biz de profil \u00fczerinden devam edece\u011fiz ilerleyen konularda.</p> <p>json dosya i\u00e7eri\u011fine bakt\u0131\u011f\u0131m\u0131zda ilgili kurulum yap\u0131ld\u0131\u011f\u0131nda hangi paketlerin kuruldu\u011funu g\u00f6rebiliriz. Bu asl\u0131nda o profilin state (durum) bilgisidir.</p> <pre><code>cat profile-4-link/manifest.json\n\n{\"elements\":[{\"active\":true,\"attrPath\":\"legacyPackages.x86_64-linux.hello\",\"originalUrl\":\"flake:nixpkgs\",\"outputs\":null,\"priority\":5,\"storePaths\":[\"/nix/store/sbldylj3clbkc0aqvjjzfa6slp4zdvlj-hello-2.12.1\"],\"url\":\"github:NixOS/nixpkgs/09ec6a0881e1a36c29d67497693a67a16f4da573\"},{\"active\":true,\"attrPath\":\"legacyPackages.x86_64-linux.mysql\",\"originalUrl\":\"flake:nixpkgs\",\"outputs\":null,\"priority\":5,\"storePaths\":[\"/nix/store/jklrlmy6zwkp4426n33jz7px2s8aldvq-mariadb-server-10.11.6\",\"/nix/store/zhl095f59vk97sbx3rcmw965zlr45zpy-mariadb-server-10.11.6-man\"],\"url\":\"github:NixOS/nixpkgs/09ec6a0881e1a36c29d67497693a67a16f4da573\"},{\"active\":true,\"attrPath\":\"legacyPackages.x86_64-linux.mysql\",\"originalUrl\":\"github:nixos/nixpkgs/nixpkgs-unstable\",\"outputs\":null,\"priority\":5,\"storePaths\":[\"/nix/store/jklrlmy6zwkp4426n33jz7px2s8aldvq-mariadb-server-10.11.6\",\"/nix/store/zhl095f59vk97sbx3rcmw965zlr45zpy-mariadb-server-10.11.6-man\"],\"url\":\"github:nixos/nixpkgs/09ec6a0881e1a36c29d67497693a67a16f4da573\"},{\"active\":true,\"attrPath\":\"legacyPackages.x86_64-linux.mysql\",\"originalUrl\":\"github:nixos/nixpkgs/nixpkgs-unstable\",\"outputs\":null,\"priority\":5,\"storePaths\":[\"/nix/store/jklrlmy6zwkp4426n33jz7px2s8aldvq-mariadb-server-10.11.6\",\"/nix/store/zhl095f59vk97sbx3rcmw965zlr45zpy-mariadb-server-10.11.6-man\"],\"url\":\"github:nixos/nixpkgs/09ec6a0881e1a36c29d67497693a67a16f4da573\"}],\"version\":2}%\n\n#----------K\u0131salt\u0131ld\u0131\n</code></pre> <p>Aktif profil ise ~/.nix-profile dizinindedir.</p> <pre><code>ls -la ~/ | grep nix-profile\n\nlrwxrwxrwx 1 grop_adi kullanici_adi     50 Eki 16 18:56 .nix-profile -&gt; /home/kullanici_adi/.local/state/nix/profiles/profile\n</code></pre> <p></p> <p>Ayr\u0131ca sistem \u00e7alimaya ba\u015flad\u0131\u011f\u0131nda aktif kullan\u0131c\u0131n\u0131n default profil bilgisi /nix/var/nix/profiles dizinindeki default dosyas\u0131na yaz\u0131l\u0131r.</p> <pre><code>ll /nix/var/nix/profiles\ntotal 4,0K\nlrwxrwxrwx 1 root root 43 Eki 16 16:31 default -&gt; /nix/var/nix/profiles/per-user/root/profile\ndrwxr-xr-x 1 root root  8 Eki 16 16:31 per-user\n</code></pre> <p>Di\u011fer kullan\u0131c\u0131lar\u0131n profile bilgileri de per-user dizinin de bulunabilir. Root i\u00e7in profile dizini de buradad\u0131r.</p> <ul> <li>Di\u011fer \u00f6nemli path ise ~/.nix-defexpr dizinidir. Bu dizinin de i\u00e7eri\u011fine bakacak olursak kulland\u0131\u011f\u0131m\u0131z paket listelerini (channels) burada bulabiliriz.</li> </ul> <pre><code>ll  ~/.nix-defexpr/\n\nlrwxrwxrwx 1 kullanici_grubu kullanici_adi 51 Eki 21 23:04 channels -&gt; /home/kullanici_adi/.local/state/nix/profiles/channels\nlrwxrwxrwx 1 kullanici_grubu kullanici_adi 44 Eki 21 23:04 channels_root -&gt; /nix/var/nix/profiles/per-user/root/channels\n</code></pre> <p>Ayr\u0131ca sistem ilk aya\u011fa kalkt\u0131\u011f\u0131nda burada yer alan nix dosyalar\u0131n\u0131 okur ve \u00e7al\u0131\u015ft\u0131r\u0131r. Genellikle a\u00e7\u0131l\u0131\u015f dosyas\u0131 olarak default.nix ad\u0131nda dosya olu\u015fturulur. Bu dosya kendi i\u00e7inde di\u011fer dosyalar\u0131 da \u00e7a\u011f\u0131rabilir (import edebilir). \u00d6rne\u011fnn ileride g\u00f6rece\u011fimiz overlay dosyalar\u0131n\u0131 buraya ekleyipo default.nix d\u0131syas\u0131na import edebiliriz.</p> <ul> <li>Nix bu kadar profile ve birden fazla kullan\u0131c\u0131y\u0131 y\u00f6netebilmek i\u00e7in sqlite kullan\u0131r. Dosyaya /nix/var/nix/db/db.sqlite dizininden eri\u015filebilir</li> </ul> <p>Nix, paket y\u00f6netimi ve paket t\u00fcretilmesi i\u00e7in kullan\u0131lan bir sistemdir ve bu sistemde SQLite, metadata (meta veri) ve derleme bilgilerini depolamak i\u00e7in kullan\u0131lan bir veritaban\u0131 olarak tercih edilir. SQLite, hafif, ta\u015f\u0131nabilir ve kullan\u0131m\u0131 kolay bir veritaban\u0131 motorudur. Nix, paket y\u00f6netimi ve t\u00fcretilmi\u015f \u00fcr\u00fcnleri izlemek i\u00e7in bu t\u00fcr bir veritaban\u0131na ihtiya\u00e7 duyar.</p> <p>\u0130\u015fte Nix'in SQLite kullan\u0131m\u0131ndaki baz\u0131 avantajlar:</p> <ol> <li> <p>Hafif ve Ta\u015f\u0131nabilir: SQLite, hafif bir veritaban\u0131 motorudur ve tek bir dosya i\u00e7inde depolanabilir. Bu, sistemde ek bir sunucu veya b\u00fcy\u00fck bir yap\u0131land\u0131rmaya ihtiya\u00e7 olmadan kullan\u0131m\u0131 kolay ve ta\u015f\u0131nabilir bir \u00e7\u00f6z\u00fcm sunar.</p> </li> <li> <p>Yerel Depolama: SQLite, paket bilgilerini ve t\u00fcretilmi\u015f \u00fcr\u00fcn bilgilerini yerel bir depoda (\u00f6rne\u011fin <code>/nix/store</code>) saklamak i\u00e7in kullan\u0131l\u0131r. Bu, paketlerin ve t\u00fcretilmi\u015f \u00fcr\u00fcnlerin h\u0131zl\u0131 ve yerel bir \u015fekilde eri\u015filebilir olmas\u0131n\u0131 sa\u011flar.</p> </li> <li> <p>\u0130zolasyon ve G\u00fcvenlik: Her Nix paketi, kendi \u00f6zel <code>/nix/store</code> dizininde saklan\u0131r ve SQLite veritaban\u0131 bu paketlerin metadata ve derleme bilgilerini izler. Bu izolasyon, paketlerin birbirinden ba\u011f\u0131ms\u0131z olmas\u0131n\u0131 ve bir paketin di\u011ferine m\u00fcdahale etmesini engeller.</p> </li> <li> <p>H\u0131zl\u0131 Sorgular ve \u0130ndeksleme: SQLite, sorgular ve indeksleme konusunda iyi bir performans sergiler. Bu, Nix'in paket bilgilerini h\u0131zl\u0131 bir \u015fekilde sorgulamas\u0131na ve t\u00fcretilmi\u015f \u00fcr\u00fcnlerle ilgili bilgileri etkili bir \u015fekilde y\u00f6netmesine olanak tan\u0131r.</p> </li> </ol> <p>D\u0130kkat ederseniz halen NixOS i\u015flemi sistemine halen hi\u00e7 de\u011finmedik. Anlayebilece\u011finiz \u00fczere Nix paket y\u00f6neticisinin temel derdi hakikaten paket y\u00f6netimi mevzusunu \u00e7\u00f6zebilmek. B\u00fct\u00fcn Linux distro'lar\u0131nda kullan\u0131labilecek, farkl\u0131 ortamlar\u0131n izole bir iekilde oluturulabildi\u011fi ve deklaratif olarak tekrar tekrar kurulum yapabilen bir paket y\u00f6neticisi zannediyorum hepimizn hayalidir.</p> <p>Evet bu yaz\u0131m\u0131da bu kadar. Nix paket y\u00f6netcisini teori ve consept olarak incelemi\u015f olduk. Bir sonraki yaz\u0131m\u0131zda shelli pofile ve develop gibi kavramlar\u0131 ve komutlar\u0131n\u0131 g\u00f6rece\u011fiz. Art\u0131k Nix paket y\u00f6neticisinin bize sundu\u011fu kolayl\u0131klar\u0131 deneyimleyebilece\u011fiz.</p> <p>Nix'in resmi paket reposu ve bu repo'yu Nix paket y\u00f6neticisinin nas\u0131l y\u00f6netti\u011fini daha detayl\u0131 anlamak isterseniz resmi readme dosyas\u0131n\u0131 ve katk\u0131da bulunmak isteyenler i\u00e7in haz\u0131rlanm\u0131\u015f contributing dosyas\u0131n\u0131 okuman\u0131z\u0131 tavsite ederim.</p>"},{"location":"nix_package/nix_paket_yoneticisi.html#kaynaklar","title":"Kaynaklar","text":"<ul> <li>https://nix.dev/concepts/flakes</li> <li>https://nix.dev/manual/nix/2.18/command-ref/new-cli/nix3-flake</li> <li>https://www.zknotes.com/page/flake.nix%20instead%20of%20nix%20channels</li> <li>https://nix.dev/tutorials/module-system/module-system</li> <li>https://nix.dev/concepts/faq</li> <li>https://github.com/orgs/nix-community/repositories?type=all</li> </ul>"},{"location":"nix_package/nix_shell_ve_profile.html","title":"Nix Shell ve Profile","text":"<p>Bu makalede yine \u00f6ncekilerde yapt\u0131\u011f\u0131m\u0131z gibi ufak \u00f6rneklerle mevzuyu anlamaya \u00e7al\u0131\u015faca\u011f\u0131z. Bir sonraki yaz\u0131m\u0131zda da nix dosyalar\u0131 \u00fczeriden daha karma\u015f\u0131k \u00f6rnekler yapaca\u011f\u0131z.</p>"},{"location":"nix_package/nix_shell_ve_profile.html#nix-shell-ve-nix-run-kullanm","title":"Nix Shell ve Nix Run Kullan\u0131m\u0131","text":"<p>Nix shell hakk\u0131nda resmi dok\u00fcmanlara bakacak olursan\u0131z development ortam\u0131 olu\u015fturmak i\u00e7in kullan\u0131l\u0131r der. \u00d6zellikle biden fazla dilde ve birden fazla versiyonla \u00e7al\u0131\u015f\u0131yorsan\u0131z hakikaten \u00e7ok kullan\u0131\u015fl\u0131. Yaz\u0131l\u0131m geli\u015ftirme d\u0131\u015f\u0131nda ba\u015fka bir alan gelmiyor akl\u0131ma ancak ayn\u0131 arac\u0131n farkl\u0131 versiyonlar\u0131yla \u00e7al\u0131\u015f\u0131yorsan\u0131z kullan\u0131\u015fl\u0131 olabilir. Ayr\u0131ca sonraki makalelerimizde g\u00f6rece\u011fimiz \u00fczere shell'i nix dosyalar\u0131 ile kullanmak da m\u00fcmk\u00fcn. Bu sayede sisteminizde ilgili yaz\u0131l\u0131mlar\u0131 devaml\u0131 kurulu tutmak zorunda de\u011filsiniz.</p> <p>\u0130sterseniz biraz al\u0131\u015ft\u0131rma yapal\u0131m. Bu makalede amac\u0131m\u0131z cli \u00fczerinden komutlarla bir \u015feyler yaparak shell'i anlamaya \u00e7al\u0131\u015fmak. Bir sonraki makalemizde nix dosyalar\u0131 ile declarative olarak yapaca\u011f\u0131z ayn\u0131 \u00f6rnekleri.</p> <p>\u015eimdi Python version 2 ile bir uygulama geli\u015ftirece\u011fimizi ve bunu sadece ilgili dizindeyken kullanaca\u011f\u0131m\u0131z\u0131 varsayal\u0131m. Usul\u00fcndendir \u00f6nce uygulamay\u0131 arayal\u0131m.resmi paket sayfas\u0131ndan da arama yapabilirsiniz. Dikkat etmeniz gereken konu biz channel kullanm\u0131yoruz flake \u00fczerinden gidiyoruz bundan dolay\u0131 alttaki adresleri kullanmal\u0131s\u0131n\u0131z. Options'lar\u0131 hen\u00fcz g\u00f6rmedik ama ileride de\u011finece\u011fiz.</p> <ul> <li>Package ararken: search.nixos.org/flakes?type=packages</li> <li>Options ararken: search.nixos.org/flakes?type=options</li> </ul> <p>Repl kullan\u0131rken de arama yapabiliriz.</p> <pre><code>nix repl\n:load &lt;nixpkgs&gt;\n\n# Added 19423 variables.\n# \u00f6rne\u011fin firef yaz\u0131p tab a basacak olursak  alttaki gibi bir liste g\u00f6rece\u011fiz.\n\nfire               firectl           firefox-bin-unwrapped    firefox-esr-unwrapped     firestarter\nfirebase-tools     firefly-desktop   firefox-devedition       firefox-mobile            firewalld\n</code></pre> <p>Ancak biz komut sat\u0131r\u0131n\u0131 kullanarak \u00e7al\u0131\u015faca\u011f\u0131z. Aramada \u00f6ncelikle nerede arama yapaca\u011f\u0131m\u0131z\u0131 s\u00f6yl\u00fcyoruz. Burada nixpkgs ile Nix'in standart repo'sunda arama yapt\u0131\u011f\u0131m\u0131z\u0131 ve python2 ile de arad\u0131\u011f\u0131m\u0131z kelimeyi belirtiyoruz.</p> <p>Arama sonucunda legacyPackages yazd\u0131\u011f\u0131na bakmay\u0131n yani burada sanki eski bir repo \u00fczerinde arama yap\u0131yormu\u015fuz gibi g\u00f6r\u00fcn\u00fcyor ama \u00f6yle de\u011fil asl\u0131nda sadece k\u00f6t\u00fc bir isimlendirme diyebiliriz.</p> <p>Bu arada biz arama yaparken hangi repo'da arma yapt\u0131\u011f\u0131m\u0131z belirtmeliyiz. Bunun i\u00e7in arama yapaca\u011f\u0131m\u0131z repo ad\u0131n\u0131 nixpkgs olarak yazd\u0131k ancak unutmayal\u0131m bu sadece GitHub'daki bir adres. Asl\u0131nda Github'da NixOS kullan\u0131c\u0131s\u0131n\u0131n nixpkgs adl\u0131 reposunda arama yap\u0131yoruz. komutun uzun halide a\u015fa\u011f\u0131da yaz\u0131yor.</p> <pre><code>nix search nixpkgs python   # veya nix search github:NixOS/nixpkgs#python\n\n# sonu\u00e7\n\n# ---------------- k\u0131salt\u0131ld\u0131\n\n# * legacyPackages.x86_64-linux.python2 (2.7.18.7)\n#   A high-level dynamically-typed programming language\n\n# * legacyPackages.x86_64-linux.python27 (2.7.18.7)\n#   A high-level dynamically-typed programming language\n\n# * legacyPackages.x86_64-linux.python27Full (2.7.18.7)\n#   A high-level dynamically-typed programming language\n\n# * legacyPackages.x86_64-linux.python2Full (2.7.18.7)\n#   A high-level dynamically-typed programming language\n\n# --------------- k\u0131salt\u0131ld\u0131\n</code></pre> <p>Evet arad\u0131\u011f\u0131m\u0131z\u0131 bulduk art\u0131k y\u00fckleyebiliriz. Listede ilk s\u0131radaki python2 paketini kuruyoruz.\u015eunu unutmamam\u0131z gerekiyor asl\u0131nda nixpkgs bir flake ve onun bir output'u python2'yi kuruyoruz. Arada neden # i\u015fareti oldu\u011funu ileride daha detayl\u0131 inceleyece\u011fiz.</p> <pre><code>nix shell nixpkgs#python2\n</code></pre> <p>Ancak bu komutu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda hata ald\u0131k. Hatan\u0131n detaylar\u0131n\u0131 inceleyecek olursak alttaki mesaj\u0131 g\u00f6rece\u011fiz.</p> <pre><code>error: Package \u2018python-2.7.18.7\u2019 in /nix/store/fjvkr94j3lwca8y66zccn15rjwzqn0rd-source/pkgs/development/interpreters/python/cpython/2.7/default.nix:335 is marked as insecure, refusing to evaluate.\n\nKnown issues:\n        - Python 2.7 has reached its end of life after 2020-01-01. See https://www.python.org/doc/sunset-python-2/.\n\n       You can install it anyway by allowing this package, using the\n       following methods:\n\n       a) To temporarily allow all insecure packages, you can use an environment\n          variable for a single invocation of the nix tools:\n\n            $ export NIXPKGS_ALLOW_INSECURE=1\n\n          Note: When using `nix shell`, `nix build`, `nix develop`, etc with a flake,\n                then pass `--impure` in order to allow use of environment variables.\n\n       b) for `nixos-rebuild` you can add \u2018python-2.7.18.7\u2019 to\n          `nixpkgs.config.permittedInsecurePackages` in the configuration.nix,\n          like so:\n\n            {\n              nixpkgs.config.permittedInsecurePackages = [\n                \"python-2.7.18.7\"\n              ];\n            }\n\n       c) For `nix-env`, `nix-build`, `nix-shell` or any other Nix command you can add\n          \u2018python-2.7.18.7\u2019 to `permittedInsecurePackages` in\n          ~/.config/nixpkgs/config.nix, like so:\n\n            {\n              permittedInsecurePackages = [\n                \"python-2.7.18.7\"\n              ];\n            }\n</code></pre> <p>Hata bize g\u00fcvenli olmayan bir paketi y\u00fcklemeye \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z s\u00f6yl\u00fcyor. Bunun sebebini a\u00e7\u0131k\u00e7a s\u00f6ylemi\u015f \u00e7\u00fcnk\u00fc Python 2.7 yak\u0131nda tedav\u00fclden kalkacakm\u0131\u015f. Ama tabii ki biz yine de kurmak isteyece\u011fiz.</p> <p>Ayr\u0131ca bir paketi kuramamam\u0131z\u0131n ba\u015fka sebepleri de olabilir.</p> <ul> <li>Bozuk paketler</li> <li>Paketi kurdu\u011fumuz sitem pakete uyumlu olmayabilir</li> <li>Paket free olmayabilir</li> <li>Paket g\u00fcvenilir olamayabilir.</li> </ul> <p>Sadece bu durum i\u00e7in \u00e7\u00f6zmek istiyorsak Kurulum yapmadan \u00f6nce alttaki komutlar\u0131 \u00e7al\u0131\u015ft\u0131rmal\u0131y\u0131z.</p> <pre><code>export NIXPKGS_ALLOW_BROKEN=1\nexport NIXPKGS_ALLOW_UNSUPPORTED_SYSTEM=1\nexport NIXPKGS_ALLOW_UNFREE=1\nexport NIXPKGS_ALLOW_INSECURE=1\n</code></pre> <p>Bizim durumumuz insecure uygulama oldu\u011fu i\u00e7in sonuncu se\u00e7enekle devam ediyoruz. Hata mesaj\u0131nda ayr\u0131ca environment variable'\u0131 kullanabilmek i\u00e7in impure etiketini de komutumuza eklememiz gerekti\u011fi s\u00f6ylenmi\u015f.</p> <p>Tam bu noktada pure ve impure kavramlar\u0131nda de\u011finelim. Bir nix expression, flake, paket vb art\u0131k nix ilgili ne varsa :) bulundu\u011fu ortama vay kullan\u0131c\u0131ya ba\u011fl\u0131 bir kod i\u00e7ermiyorsa buna pure diyoruz. E\u011fer Nix d\u0131\u015f\u0131nda bir yerlere dokunuyorsa veya ba\u011f\u0131ml\u0131l\u0131\u011f\u0131 vs varsa o zaman impure diyoruz. Burada da hata mesaj\u0131nda denildi\u011fi gibi environment variable kullan\u0131m\u0131 gerekti\u011fi i\u00e7in impure eklememiz isteniyor. Bu arada default olan pure'dur.</p> <pre><code>export NIXPKGS_ALLOW_INSECURE=1\nnix shell nixpkgs#python2 --impure\n</code></pre> <p>Art\u0131k Python'\u0131 kurabiliyoruz. \u015eimdi denildi\u011fi gibi,</p> <ul> <li>sadece bu dizinde mi kullanabiliyoruz,</li> <li>sadece burada kullanabiliyorsak bunu nas\u0131l yapabiliyor</li> <li>ve terminali kapatt\u0131\u011f\u0131m\u0131zda neler oluyor gibi sorular\u0131n cevab\u0131n\u0131 ara\u015ft\u0131ral\u0131m.</li> </ul> <p>\u00d6ncelikle hakikaten Python 2.7 \u00e7al\u0131\u015f\u0131yor mu buna bakal\u0131m. Yine ayn\u0131 dizinde a\u00e7t\u0131\u011f\u0131m\u0131z terminal de <code>python2</code> komutunu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda python repl'ine giri\u015f yapm\u0131\u015f olmal\u0131y\u0131z. \u00c7\u0131kmak i\u00e7in <code>exit()</code> fonksiyonunu \u00e7al\u0131\u015ft\u0131r\u0131yoruz.</p> <p>Bu terminal a\u00e7\u0131kken ba\u015fka bir terminal a\u00e7\u0131p python2 \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131n\u0131zda \u00e7al\u0131\u015fmad\u0131\u011f\u0131n\u0131 g\u00f6rebilirsiniz. Hatta ayn\u0131 dizinde bile \u00e7al\u0131\u015ft\u0131rsan\u0131z \u00e7al\u0131\u015fmayacak. Asl\u0131nda Nix burada ilgili paketi sistemimize kuruyor ve biz terminalde nix shell komutu ile \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda bizim ad\u0131m\u0131za shell i\u00e7inde kurdu\u011fumuz paketleri PATH olarak tan\u0131ml\u0131yor.</p> <p>Bunu denemek i\u00e7in isterseniz ayn\u0131 dizinde <code>nix shell</code> komutundan \u00f6nce <code>cat $PATH</code> komutunu \u00e7al\u0131\u015ft\u0131r\u0131n birde <code>nix shell</code> komutundan sonra \u00e7al\u0131\u015ft\u0131r\u0131n. Alttaki gibi bir sat\u0131r\u0131 da listede g\u00f6r\u00fcyor olacaks\u0131n\u0131z.</p> <pre><code>/home/kullanici_adiniz/.nix-profile/bin:/nix/var/nix/profiles/default/bin:/nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7\n</code></pre> <p>Terminalden \u00e7\u0131k\u0131p tekrar girdi\u011fimizde python2 komutunun \u00e7al\u0131\u015ft\u0131r\u0131lmad\u0131\u011f\u0131n\u0131 g\u00f6rebilirsiniz. Tekrar kurulum komutu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131n\u0131zda \u00e7ok h\u0131zl\u0131 kuruldu\u011funu g\u00f6rebilirsiniz. \u00c7\u00fcnk\u00fc bir \u00e7ok ba\u011f\u0131ml\u0131l\u0131k zaten store'da oldu\u011fu i\u00e7in ilki kadar yava\u015f olmayacakt\u0131r.</p> <p>Ayr\u0131ca Nix belirli aral\u0131kla kendi garbage collector'\u00fc ile sistemde kullan\u0131lmayan veya bozuk paketleri temizler.</p> <p>Garbage collection'\u0131 manuel tetiklemek i\u00e7in nix store gc komutu kullan\u0131l\u0131r.</p> <pre><code># Delete unreachable paths in the Nix store:\nnix store gc\n\n# Delete up to 1 gigabyte of garbage:\n nix store gc --max 1G\n</code></pre> <p><code>nix shell</code> komutunu alttaki gibi kullanmak da m\u00fcmk\u00fcn.</p> <pre><code>nix shell 'github:NixOS/nixpkgs/23.11#'{vim,tree}\n</code></pre> <p>Bir de <code>nix run</code> komutu var bunun da yapt\u0131\u011f\u0131 paketi kurup do\u011frudan \u00e7al\u0131\u015ft\u0131rmak ba\u015fka da bir alameti farikas\u0131 yok. Mesela alttaki kodda do\u011frudan git clone komutu \u00e7al\u0131\u015ft\u0131r\u0131lm\u0131\u015f.</p> <pre><code>nix run nixpkgs#git clone git@github.com:ryan4yin/nix-config.git\n</code></pre> <p>Bu \u015fekilde nix shell'i anl\u0131k bir \u015feyi test etmek i\u00e7in kullanabilirsiniz. Ancak tabii ki shell bu kadar de\u011fil her defas\u0131ndan diyelim ki projenizde gerekli 8-10 adet paketi elle kurman\u0131z anlams\u0131z olacakt\u0131r. Bunu da declarative yolla nix dosyas\u0131nda yazarak te seferde yapmak m\u00fcmk\u00fcn. Bu kullan\u0131m\u0131 da sonraki makalelerimizde g\u00f6rece\u011fiz.</p>"},{"location":"nix_package/nix_shell_ve_profile.html#nix-profile-kullanm","title":"Nix Profile Kullan\u0131m\u0131","text":"<p>Profile'in shell'den fark\u0131 sistem restart olduktan sonra da paketleri saklamas\u0131d\u0131r.</p> <p>Profile'leri bir kullan\u0131c\u0131 profili gibi d\u00fc\u015f\u00fcnmemeliyiz. Daha \u00e7ok sistemin belli bir stat'ini tutan bir yap\u0131d\u0131r. Bir kullan\u0131c\u0131n\u0131n birden fazla profili olabilir. Alttaki \u015fekil bunu \u00e7ok g\u00fczel anlatm\u0131\u015f.</p> <p></p> <p>Sistemde profile komutu ile her kurulum yapt\u0131\u011f\u0131m\u0131zda state de\u011fi\u015fikli\u011fi ile bir profile olu\u015fur. Profiller store \u00fczeriden symbolic linklerle ayn\u0131 paketin birden fazla versiyonu ile \u00e7al\u0131\u015fabilir. Yani bir \u00e7ok kullan\u0131c\u0131 ve profile i\u00e7in tekrar tekrar ayn\u0131 paketin kurulumu yap\u0131lmaz. Bir pakete ihtiya\u00e7 kalmad\u0131\u011f\u0131nda da garbage collection ile silinir.</p> <p>\u00d6ncelikle h\u0131zl\u0131ca bir komutlar\u0131 inceleyelim.</p> <ul> <li>nix profile diff-closures: \u0130ki profil aras\u0131ndaki farklar\u0131 g\u00f6sterir.</li> <li>nix profile history: profilin b\u00fct\u00fcn ge\u00e7mi\u015fini g\u00f6sterir. Profilde her bir hareket soran\u0131 bir history kayd\u0131 olu\u015fur.</li> <li>nix profile install: Profile paket kurar.</li> <li>nix profile list: Profildeki kurulu paketleri listeler.</li> <li>nix profile remove: Profilden paket siler.</li> <li>nix profile rollback: \u00d6zellikle belirtilmezse bir \u00f6nceki versiyona ge\u00e7i\u015f yapar.</li> <li>nix profile upgrade: Paketleri en son flake versiyonuna y\u00fckseltir.</li> <li>nix profile wipe-history: Aktif olmayan yani a\u00e7\u0131k oturumda kullan\u0131lmayan di\u011fer profilleri siler.</li> </ul> <p>closure: Nix closure, bir paketin ba\u011f\u0131ml\u0131l\u0131klar\u0131yla birlikte birle\u015ftirilmi\u015f bir dizin yap\u0131s\u0131d\u0131r. Bu, bir paketin tamam\u0131n\u0131 ve ona ba\u011fl\u0131 t\u00fcm ba\u011f\u0131ml\u0131l\u0131klar\u0131 i\u00e7erir.</p> <p>\u015eimdide biraz al\u0131\u015ft\u0131rma yapal\u0131m.</p> <p>\u015eimdi de mesela NodeJs, Python ve Git kurmay\u0131 deneyelim.</p> <pre><code>nix search nixpkgs nodejs\n\n# sonu\u00e7\n\n# * legacyPackages.x86_64-linux.nodejs-18_x (18.19.0)\n# Event-driven I/O framework for the V8 JavaScript engine\n\n# * legacyPackages.x86_64-linux.nodejs-slim (20.10.0)\n# Event-driven I/O framework for the V8 JavaScript engine\n\n# * legacyPackages.x86_64-linux.nodejs-slim-18_x (18.19.0)\n# Event-driven I/O framework for the V8 JavaScript engine\n\n# * legacyPackages.x86_64-linux.nodejs-slim_18 (18.19.0)\n# Event-driven I/O framework for the V8 JavaScript engine\n\n# * legacyPackages.x86_64-linux.nodejs-slim_20 (20.10.0)\n# Event-driven I/O framework for the V8 JavaScript engine\n\n# * legacyPackages.x86_64-linux.nodejs-slim_21 (21.5.0)\n</code></pre> <p>Biz nodejs-slim_18 versiyonunu kural\u0131m</p> <pre><code>nix profile install nixpkgs#nodejs-slim_18\nnix profile install nixpkgs#python2 --impure\n</code></pre> <p>\u00d6ncelikle hemen <code>~/.nix-profile</code> dizinine yani aktif profile klas\u00f6r\u00fcm\u00fcze bi bakal\u0131m. Art\u0131k sadece manifest.json dosyam\u0131z yok. Dikkat ederseniz</p> <pre><code>ll ~/.nix-profile\n\ndr-xr-xr-x 1 root root 250 Oca  1  1970 bin\ndr-xr-xr-x 1 root root  26 Oca  1  1970 include\ndr-xr-xr-x 1 root root 128 Oca  1  1970 lib\n-r--r--r-- 1 root root 577 Oca  1  1970 manifest.json\ndr-xr-xr-x 1 root root  30 Oca  1  1970 share\n</code></pre> <p>Bir de bin klas\u00f6r\u00fcne bakal\u0131m. G\u00f6rebildi\u011fimiz gibi kurulumu yapt\u0131\u011f\u0131m\u0131z NodeJs ve Python2 ile ilgili b\u00fct\u00fcn binary'ler buraya sembolik link olarak ba\u011flanm\u0131\u015f. Asl\u0131nda b\u00fct\u00fcn binary ve di\u011fer k\u00fct\u00fcphaneler store'a kaydediliyor.</p> <pre><code>ll ~/.nix-profile/bin\n\n# total 64K\n# lrwxrwxrwx 1 root root 68 Oca  1  1970 2to3 -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/2to3\n# lrwxrwxrwx 1 root root 76 Oca  1  1970 corepack -&gt; /nix/store/k748i73qqihzqc4d4671jgxx8828n06m-nodejs-slim-18.19.0/bin/corepack\n# lrwxrwxrwx 1 root root 68 Oca  1  1970 idle -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/idle\n# lrwxrwxrwx 1 root root 72 Oca  1  1970 node -&gt; /nix/store/k748i73qqihzqc4d4671jgxx8828n06m-nodejs-slim-18.19.0/bin/node\n# lrwxrwxrwx 1 root root 67 Oca  1  1970 pdb -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/pdb\n# lrwxrwxrwx 1 root root 70 Oca  1  1970 pdb2.7 -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/pdb2.7\n# lrwxrwxrwx 1 root root 69 Oca  1  1970 pydoc -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/pydoc\n# lrwxrwxrwx 1 root root 70 Oca  1  1970 python -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/python\n# lrwxrwxrwx 1 root root 71 Oca  1  1970 python2 -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/python2\n# lrwxrwxrwx 1 root root 73 Oca  1  1970 python2.7 -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/python2.7\n# lrwxrwxrwx 1 root root 80 Oca  1  1970 python2.7-config -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/python2.7-config\n# lrwxrwxrwx 1 root root 78 Oca  1  1970 python2-config -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/python2-config\n# lrwxrwxrwx 1 root root 77 Oca  1  1970 python-config -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/python-config\n# lrwxrwxrwx 1 root root 72 Oca  1  1970 smtpd.py -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/smtpd.py\n# lrwxrwxrwx 1 root root 73 Oca  1  1970 smtpd.pyc -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/smtpd.pyc\n# lrwxrwxrwx 1 root root 73 Oca  1  1970 smtpd.pyo -&gt; /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7/bin/smtpd.pyo\n</code></pre> <p>Peki bu binary'leri nas\u0131l kullanaca\u011f\u0131z. Yani sonu\u00e7ta \u015fuan NixOS kullanm\u0131yorsak ve kulland\u0131\u011f\u0131m\u0131z Linux da\u011f\u0131t\u0131m\u0131nda da NodeJs'in farkl\u0131 bir versiyonu kuruluysa sistem onu \u00e7al\u0131\u015ft\u0131racakt\u0131r. Bunun i\u00e7inde <code>nix shell</code> komutunu kullanabilir. Zaten kendi makinenizde bir Node s\u00fcr\u00fcm\u00fc kurulu ise terminalde <code>nix shell nixpkgs#nodejs-slim_18</code> komutu ile NodeJs 18'i active edebilirsiniz. Bu durumda tekrar kurulum yap\u0131lmayaca\u011f\u0131n\u0131 sadece PAth tan\u0131mlamas\u0131 yap\u0131laca\u011f\u0131n\u0131 hat\u0131rlayal\u0131m.</p> <p>\u015eimdi de Git'i kurabiliriz.</p> <pre><code>nix search nixpkgs#git\n# * legacyPackages.x86_64-linux.git (2.42.0)\n\nnix profile install nixpkgs#git\n</code></pre> <p>Tekrar bin dizinie bakacak olursak</p> <pre><code>ll ~/.nix-profile/bin\n\n# sonu\u00e7\n# ------------------------K\u0131salt\u0131ld\u0131\nlrwxrwxrwx 1 root root 62 Oca  1  1970 git -&gt; /nix/store/31ypk253113v59lslsx8nbqpx794rlan-git-2.42.0/bin/git\nlrwxrwxrwx 1 root root 79 Oca  1  1970 git-credential-netrc -&gt; /nix/store/31ypk253113v59lslsx8nbqpx794rlan-git-2.42.0/bin/git-credential-netrc\nlrwxrwxrwx 1 root root 72 Oca  1  1970 git-cvsserver -&gt; /nix/store/31ypk253113v59lslsx8nbqpx794rlan-git-2.42.0/bin/git-cvsserver\n# --------------------- K\u0131salt\u0131ld\u0131\n</code></pre> <p>\u015eimdi de profile history'ye bi g\u00f6z atal\u0131m. Dikkat ederseniz her kurdu\u011fumuzda profile yeni bir versiyon eklenmi\u015f. Aktif profilimiz \u00fczerindeki de\u011fi\u015fiklikleri listeliyor. Bu arada burada g\u00f6stermiyorum ancak b\u00fcy\u00fck ihtimal kendi ekran\u0131n\u0131zda listede aktif olarak kulland\u0131\u011f\u0131n\u0131z versiyonu daha renkli g\u00f6receksiniz.</p> <pre><code>nix profile history\n\n# sonu\u00e7\n\nVersion 1 (2023-12-08):\nflake:nixpkgs#legacyPackages.x86_64-linux.hello: \u2205 -&gt; 2.12.1\n\nVersion 2 (2023-12-08) &lt;- 1:\nflake:nixpkgs#legacyPackages.x86_64-linux.mysql: \u2205 -&gt; 10.11.6, 10.11.6-man\n\nVersion 3 (2023-12-08) &lt;- 2:\ngithub:nixos/nixpkgs/nixpkgs-unstable#legacyPackages.x86_64-linux.mysql: \u2205 -&gt; 10.11.6, 10.11.6-man\n\nVersion 4 (2023-12-08) &lt;- 3:\ngithub:nixos/nixpkgs/nixpkgs-unstable#legacyPackages.x86_64-linux.mysql: \u2205 -&gt; 10.11.6, 10.11.6-man\n\nVersion 5 (2023-12-08) &lt;- 4:\nflake:nixpkgs#legacyPackages.x86_64-linux.mysql: 10.11.6, 10.11.6-man -&gt; \u2205\ngithub:nixos/nixpkgs/nixpkgs-unstable#legacyPackages.x86_64-linux.mysql: 10.11.6, 10.11.6-man -&gt; \u2205\ngithub:nixos/nixpkgs/nixpkgs-unstable#legacyPackages.x86_64-linux.mysql: 10.11.6, 10.11.6-man -&gt; \u2205\n\nVersion 6 (2023-12-08) &lt;- 5:\nflake:nixpkgs#legacyPackages.x86_64-linux.hello: 2.12.1 -&gt; \u2205\n\nVersion 7 (2024-01-09) &lt;- 6:\nflake:nixpkgs#legacyPackages.x86_64-linux.nodejs-slim_18: \u2205 -&gt; 18.19.0\n\nVersion 8 (2024-01-09) &lt;- 7:\nflake:nixpkgs#legacyPackages.x86_64-linux.python2: \u2205 -&gt; 2.7.18.7\n\nVersion 9 (2024-01-09) &lt;- 8:\nflake:nixpkgs#legacyPackages.x86_64-linux.git: \u2205 -&gt; 2.42.0\n</code></pre> <p>Sistemdeki profil listesini alal\u0131m</p> <pre><code>nix profile list\n\n# sonu\u00e7\n\nIndex:              0\nFlake attribute:    legacyPackages.x86_64-linux.nodejs-slim_18\nOriginal flake URL: flake:nixpkgs\nLocked flake URL:   github:NixOS/nixpkgs/24fe8bb4f552ad3926274d29e083b79d84707da6\nStore paths:        /nix/store/k748i73qqihzqc4d4671jgxx8828n06m-nodejs-slim-18.19.0\n\nIndex:              1\nFlake attribute:    legacyPackages.x86_64-linux.python2\nOriginal flake URL: flake:nixpkgs\nLocked flake URL:   github:NixOS/nixpkgs/24fe8bb4f552ad3926274d29e083b79d84707da6\nStore paths:        /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7\n\nIndex:              2\nFlake attribute:    legacyPackages.x86_64-linux.git\nOriginal flake URL: flake:nixpkgs\nLocked flake URL:   github:NixOS/nixpkgs/24fe8bb4f552ad3926274d29e083b79d84707da6\nStore paths:        /nix/store/31ypk253113v59lslsx8nbqpx794rlan-git-2.42.0\n</code></pre> <p>\u015eimdide profilden Git'i silelim. Bunun i\u00e7in Nix listesindeki Store path adresini kullan\u0131yoruz.</p> <pre><code>nix profile remove /nix/store/31ypk253113v59lslsx8nbqpx794rlan-git-2.42.0\n</code></pre> <p>\u015eimdi listeye bir bakal\u0131m</p> <pre><code>nix profile list\nIndex:              0\nFlake attribute:    legacyPackages.x86_64-linux.nodejs-slim_18\nOriginal flake URL: flake:nixpkgs\nLocked flake URL:   github:NixOS/nixpkgs/24fe8bb4f552ad3926274d29e083b79d84707da6\nStore paths:        /nix/store/k748i73qqihzqc4d4671jgxx8828n06m-nodejs-slim-18.19.0\n\nIndex:              1\nFlake attribute:    legacyPackages.x86_64-linux.python2\nOriginal flake URL: flake:nixpkgs\nLocked flake URL:   github:NixOS/nixpkgs/24fe8bb4f552ad3926274d29e083b79d84707da6\nStore paths:        /nix/store/a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7\n</code></pre> <p>Bir de history'ye bakal\u0131m. Dikkat ederseniz <code>2.42.0 -&gt; \u2205</code> diye bir tan\u0131m var. Bu da Git'in kald\u0131r\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6steriyor.</p> <pre><code>nix profile history\n\n# ----------------- k\u0131salt\u0131ld\u0131\n\nVersion 10 (2024-01-09) &lt;- 9:\nflake:nixpkgs#legacyPackages.x86_64-linux.git: 2.42.0 -&gt; \u2205\n</code></pre> <p>\u015eimdi profilimizdeki bir versiyonu geri y\u00fckleyelim mesela amac\u0131m\u0131z Python'\u0131n y\u00fcklenmedi\u011fi ve onun \u00fczerine GoLang'\u0131n kuruldu\u011fu bir durum olsun. Bu bende history'dei 6 numaral\u0131 versiyon. Sizde farkl\u0131 olabilir.</p> <pre><code>nix profile rollback --to 6\n</code></pre> <p>tekrar history'ye bakacak olursan\u0131z \u00fczerinde oldu\u011funuz versiyonun aktif oldu\u011funu g\u00f6receksiniz.</p> <p>\u015eimdi tam buradayken GoLang'\u0131 kurup bir de history'ye \u00f6yle bakal\u0131m. \u00d6ncelikle GoLang'\u0131 arayal\u0131m sonrada kural\u0131m.</p> <pre><code>nix search nixpkgs#go\n# * legacyPackages.x86_64-linux.go (1.21.5)\n# The Go Programming language\n\nnix profile install nixpkgs#go\n</code></pre> <p>\u015eimdi history'ye bakal\u0131m</p> <pre><code>nix profile histrory\n\n# -------------------- k\u0131salt\u0131ld\u0131\n\n# Version 6 (2023-12-08) &lt;- 5:\n# flake:nixpkgs#legacyPackages.x86_64-linux.hello: 2.12.1 -&gt; \u2205\n\n# Version 7 (2024-01-09) &lt;- 6:\n# flake:nixpkgs#legacyPackages.x86_64-linux.nodejs-slim_18: \u2205 -&gt; 18.19.0\n\n# Version 8 (2024-01-09) &lt;- 7:\n# flake:nixpkgs#legacyPackages.x86_64-linux.python2: \u2205 -&gt; 2.7.18.7\n\n# Version 9 (2024-01-09) &lt;- 8:\n# flake:nixpkgs#legacyPackages.x86_64-linux.git: \u2205 -&gt; 2.42.0\n\n# Version 10 (2024-01-09) &lt;- 9:\n# flake:nixpkgs#legacyPackages.x86_64-linux.git: 2.42.0 -&gt; \u2205\n\n# Version 11 (2024-01-10) &lt;- 10:\n# flake:nixpkgs#legacyPackages.x86_64-linux.go: \u2205 -&gt; 1.21.5\n# flake:nixpkgs#legacyPackages.x86_64-linux.hello: \u2205 -&gt; 2.12.1\n# flake:nixpkgs#legacyPackages.x86_64-linux.nodejs-slim_18: 18.19.0 -&gt; \u2205\n# flake:nixpkgs#legacyPackages.x86_64-linux.python2: 2.7.18.7 -&gt; \u2205\n</code></pre> <p>Yeni eklenen ve bende aktif olan versiyon 11'de Go'nun kuruldu\u011funu ve versiyon 6'da iken kurulum yapt\u0131\u011f\u0131m\u0131z i\u00e7in aradaki NodeJs ve Python2'nin silindi\u011fini g\u00f6rebilirsiniz.</p> <p>Hatta bunu profilimizdeki bin klas\u00f6r\u00fcnden de test edelim. G\u00f6rece\u011finiz \u00fczere profilimizden silinmi\u015f.</p> <pre><code>ll ~/.nix-profile/bin\n\ntotal 12K\nlrwxrwxrwx 1 root root 60 Oca  1  1970 go -&gt; /nix/store/6qd8p8gilzgplpk2ni3109m0k71r21s7-go-1.21.5/bin/go\nlrwxrwxrwx 1 root root 63 Oca  1  1970 gofmt -&gt; /nix/store/6qd8p8gilzgplpk2ni3109m0k71r21s7-go-1.21.5/bin/gofmt\nlrwxrwxrwx 1 root root 66 Oca  1  1970 hello -&gt; /nix/store/sbldylj3clbkc0aqvjjzfa6slp4zdvlj-hello-2.12.1/bin/hello\n</code></pre> <p>\u015eimdi birde store'a bakal\u0131m. Profilimizden gitmi\u015f olams\u0131na ra\u011fmen halen Python2'nin halen store'da oldu\u011funu g\u00f6rebiliriz. Bunun birka\u00e7 sebebi olabilir</p> <ul> <li>Ba\u015fka bir kullan\u0131c\u0131 bu versiyonu kullan\u0131yor olabilir.</li> <li>Sistem kulaln\u0131yor olabilir. Yanibir paket i\u00e7in belki bu versiyon gereklidir.</li> <li>Garbage collection hen\u00fcz \u00e7al\u0131\u015fmam\u0131\u015f olabilir.</li> <li>Son olarak yukardakiler olmasa bile bizim profile'de bir versiyonu kullan\u0131yor olabiliriz.</li> </ul> <pre><code>ll /nix/store/ | grep python-2\n\n\ndr-xr-xr-x 1 root       root         58 Oca  1  1970 a55nhyb3n13bdx1swv5dz3zm3lhikmfd-python-2.7.18.7\n-r--r--r-- 1 root       root       7,9K Oca  1  1970 rfnbbfml49p3lmh92jd3mlqzjq1fg6aj-python-2.7.18.7.drv\n</code></pre> <p>Bu durumda bize son madde uygun g\u00f6r\u00fcn\u00fcyor yani bizim profilimizde history'de Python2 kurulu g\u00f6r\u00fcn\u00fcyor. O zaman iddiam\u0131za g\u00f6re history'yi temizler ve garbage collertor'\u00fc de \u00e7al\u0131\u015ft\u0131racak olursak hakiakten Python2'nin silindi\u011fini g\u00f6rmemiz gerekiyor.</p> <pre><code># aktif olamayan b\u00fct\u00fcn history'leri silelim\nnix profile wipe-history\n\n# garbage collector'\u00fc \u00e7al\u0131\u015ft\u0131ral\u0131m\nnix store gc\n\n# store'a bakal\u0131m\n\nll /nix/store/ | grep python-2\n</code></pre> <p>Sonu\u00e7ta Python2'nin silindi\u011fini g\u00f6rd\u00fck.</p> <p>Son olarak herhangi bir paketi veya b\u00fct\u00fcn paketleri upgrade etmek i\u00e7in de <code>nix profile upgrade</code> komutu kullan\u0131l\u0131r.</p> <pre><code>nix profile upgrade '.*'\n\nnix profile upgrade packages.x86_64-linux.hello\n\nnix profile upgrade 0 # profile idex numaras\u0131\n</code></pre> <p>Evet profile i\u00e7in de bu kadar yeterli. Tabi profilleri de declarative yolla yani bir nix dosyas\u0131yla kullanmak m\u00fcmk\u00fcn bunu da bir sonraki makalelerimizde g\u00f6rece\u011fiz.</p>"},{"location":"nix_package/nix_shell_ve_profile.html#diger-temel-baz-komutlar","title":"Di\u011fer Temel Baz\u0131 Komutlar","text":"<ul> <li>nix run: Uygulamay\u0131 build al\u0131r ve \u00e7al\u0131\u015ft\u0131r\u0131r. Mesela flake ile bir derivative yazd\u0131k ve \u00e7al\u0131\u015ft\u0131rmak isityoruz diyelim. packages.\\&lt;system&gt;.default komutu ie \u00e7al\u0131\u015ft\u0131rabiliriz. veya hali haz\u0131rda nixpkgs i\u00e7indeki bir uygulamay\u0131 \u00e7al\u0131\u015ft\u0131rmak i\u00e7in packages.\\&lt;system&gt;.\\&lt;name&gt;</li> <li>nix search: Paket aramak i\u00e7in kullan\u0131l\u0131r.</li> <li>nix copy: Store i\u00e7indeki dosya ve klas\u00f6rleri kopyalamak i\u00e7in kullan\u0131l\u0131r.</li> <li>nix edit: Nix paketini d\u00fczenlemek i\u00e7in kullan\u0131l\u0131r.</li> <li>nix store add: Bir dizini Nix Store'a ekler.</li> <li>store add --mode flat: Bir dosyay\u0131 store'a ekler.</li> <li>nix store cat: Nix deposundaki bir dosyan\u0131n i\u00e7eri\u011fini stdout'a yazd\u0131r\u0131r. Linux^daki cat komutu gibi.</li> <li>nix store delete: Nix Store'dan bir dizin veya klas\u00f6r\u00fc siler.</li> <li>nix store diff-closures: iki Nix kapan\u0131\u015f\u0131 (closure) aras\u0131ndaki farklar\u0131 g\u00f6sterir. Nix closure, bir paketin ba\u011f\u0131ml\u0131l\u0131klar\u0131yla birlikte birle\u015ftirilmi\u015f bir dizin yap\u0131s\u0131d\u0131r. Bu, bir paketin tamam\u0131n\u0131 ve ona ba\u011fl\u0131 t\u00fcm ba\u011f\u0131ml\u0131l\u0131klar\u0131 i\u00e7erir.Komutun temel amac\u0131, iki closure aras\u0131ndaki paket ve s\u00fcr\u00fcm farklar\u0131n\u0131 belirlemektir. Yani, bir paketin bir versiyonundan di\u011ferine veya bir kapan\u0131\u015ftan di\u011ferine hangi paketlerin eklenip kald\u0131r\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6sterir. Bu bilgi, paketlerin ve ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131n g\u00fcncellenmesi veya de\u011fi\u015ftirilmesi durumlar\u0131nda faydal\u0131 olabilir.</li> <li>nix store dump-path: Bir store yolunu NAR format\u0131nda stdout'a serile\u015ftirir.</li> <li>nix store gc: Nix Store'daki gereksiz dosyalar\u0131 temizler.</li> <li>nix store info: Store hakk\u0131nda bilgi verir</li> <li>nix store ls - Nix store'daki bir yol hakk\u0131nda bilgi g\u00f6ster. Linux'deki ls komutu gibi.</li> <li>nix store ping: Bir store'a eri\u015filebilir mi diye test eder. Buna uzak store'larda dahil. \u00f6rne\u011fin <code>nix store ping --store https://cache.nixos.org</code></li> <li>nix store prefetch-file: Bir dosyay\u0131 Nix Store'a indirir.</li> <li>nix registry add: - add/replace flake in user flake registry</li> <li>nix registry list: - list available Nix flakes</li> <li>nix registry pin: - pin a flake to its current version or to the current version of a flake URL</li> <li>nix registry remove: - remove flake from user flake registry</li> <li>nix upgrade-nix: nix paket y\u00f6neticisini stabil en son s\u00fcr\u00fcme upgrade etmek i\u00e7in kullan\u0131l\u0131r. Bunu ayr\u0131ca sadece tek bir profile i\u00e7in yapmak da m\u00fcmk\u00fcn. \u00f6rne\u011fin <code>nix upgrade-nix --profile ~alice/.local/state/nix/profiles/profile</code>.</li> <li>nix why-depends: Bir paketin di\u011fer bir pakete neden ba\u011fl\u0131 oldu\u011fu ara\u015ft\u0131rmak i\u00e7in kullan\u0131l\u0131r</li> </ul> <p>\u00f6rne\u011fin altta thunderbird ile glib aras\u0131ndaki ba\u011f\u0131ml\u0131l\u0131k ara\u015ft\u0131r\u0131lm\u0131\u015ft\u0131.</p> <pre><code>nix why-depends --all nixpkgs#thunderbird nixpkgs#glib\n\n# Sonu\u00e7\n/nix/store/97i88qcprk3ylam7b2ppkr94yj5hxm0r-thunderbird-115.6.0\n\u2514\u2500\u2500\u2500/nix/store/pag0sz7012misn9pckd6my9gvayl5q9h-xdg-utils-unstable-2022-11-06\n    \u2514\u2500\u2500\u2500/nix/store/7m55djnyz4x0lcffn6c38j57bzpj1a6g-glib-2.78.1-bin\n</code></pre> <p>Bu makalemiz de bu kadar. Bir sonraki makalemizde Nix Flake kavram\u0131n\u0131 detayl\u0131 olarak inceleyece\u011fiz. Devam edebilmemiz i\u00e7in art\u0131k Flake'i anlamam\u0131z gerekiyor.</p>"},{"location":"nix_package/nix_shell_ve_profile.html#referanslar","title":"Referanslar","text":"<ul> <li>https://nix.dev/concepts/flakes</li> <li>https://nix.dev/manual/nix/2.18/command-ref/new-cli/nix3-flake</li> <li>https://www.zknotes.com/page/flake.nix%20instead%20of%20nix%20channels</li> <li>https://ryantm.github.io/nixpkgs/using/configuration/</li> <li>https://zero-to-nix.com/start/nix-search</li> </ul>"},{"location":"nix_package/override_ve_overlay.html","title":"Override ve Overlay","text":"<p>Override'in T\u00fcrk\u00e7e ge\u00e7ersiz k\u0131lmak anlam\u0131na geliyor. Nix dilinde paketlerin ve paket setlerinin de\u011fi\u015ftirilmesi ve geni\u015fletilmesi i\u00e7in kullan\u0131lan iki \u00f6nemli kavramd\u0131r. Bir mod\u00fcl veya bir paketin baz\u0131 \u00f6zelliklerini de\u011fi\u015ftirerek, silerek veya yeni \u00f6zellikler ekleyerek daha esnek paket y\u00f6netimi yapmam\u0131za olanak tan\u0131rlar.</p> <p>Bunu yapmak i\u00e7in Nix hem builtins hem de nixpkgs i\u00e7indeki lib k\u00fct\u00fcphanelerinde bir \u00e7ok fonksiyon sunar. Asl\u0131nda tan\u0131m olarak kolay ancak uygulamas\u0131 biraz karma\u015f\u0131k daha do\u011frusu nerede ve nas\u0131l yapaca\u011f\u0131m\u0131z\u0131 anlamak ve bulmak biraz zor.</p> <p>Bir de hat\u0131rlatma yapay\u0131m. \u0130lk yaz\u0131lar\u0131m\u0131zda hat\u0131rlarsan\u0131z Nix dilinin immutable (yani de\u011fi\u015ftirilemez) oldu\u011fundan bahsetmi\u015ftik. Fonksiyonel programlama dillerinde kod yazm\u0131\u015f olanlar buna zaten a\u015finad\u0131r. Yada son zamanlarda y\u00fckseli\u015fte olan Rust dili de yine immutable de\u011fi\u015fkenlere sahiptir aksi belirtilmedik\u00e7e. Bunun bir \u00e7ok faydas\u0131 var ama \u015fuan konumuz bu de\u011fil. As\u0131l vurgulamak istedi\u011fim Nix dilinde asl\u0131nda bir set'in de\u011ferlerini asl\u0131nda silemeyiz veya de\u011fi\u015ftiremeyiz. Burada yap\u0131lan yeni bir set olu\u015fturmakt\u0131r asl\u0131nda. \u00d6zellikle OOP d\u00fcnyas\u0131ndan gelen arkada\u015flar\u0131n buna bende dahil al\u0131\u015fmas\u0131 biraz zaman al\u0131yor bu duruma. Normalde bir liste eleman\u0131n\u0131 Java veya C# dillerinde de\u011fi\u015ftirmek \u00e7ok kolayd\u0131r. Ancak burada her \u015fey fonksiyon dolay\u0131s\u0131yla biz donen her de\u011feri ba\u015fka bir de\u011fi\u015fkene atarken de\u011fi\u015ftiriyoruz. Bundan dolay\u0131 override ve overlay i\u015flemleri i\u00e7in Nix dilinde farkl\u0131 farkl\u0131 fonksiyonlar. Ama\u00e7lar\u0131 bu i\u015flemleri yapabilmemizin muhtemel oldu\u011fu yerlerde i\u015fimizi kolayla\u015ft\u0131rmak.</p> <p>Bu durumda override etmeyi d\u00fc\u015f\u00fcnd\u00fc\u011f\u00fcm\u00fcz veri tipini bilmemiz gerekiyor. Bir set ile mesela bir string'i farkl\u0131 yollarla override edebiliriz. Amac\u0131m detaya girip kafan\u0131z\u0131 kar\u0131\u015ft\u0131rmak de\u011fil sade bir override yazmak istedi\u011fimizde nereden ba\u015flayaca\u011f\u0131m\u0131z\u0131 anlamak. Veri tipini \u00f6\u011frendikten sonra da ona uygulayaca\u011f\u0131m\u0131z fonksiyonu veya varsa di\u011fer yollar\u0131 bulup uygulamak. Mesela amac\u0131m\u0131z bir derivation'\u0131 override etmekse bunun i\u00e7in overrideDerivation fonksiyonunu kullanabiliriz. Amac\u0131m\u0131z bir paketi override etmekse bunun i\u00e7in overrideAttrs veya override fonksiyonunu kullanabiliriz. Yada do\u011frudan bir set \u00fczerinde i\u015flem yapmaksa belki bir fonksiyon kullanmam\u0131za gerek olmayabilir. \u0130lk yaz\u0131lar\u0131m\u0131zda anlatt\u0131\u011f\u0131m\u0131z setler \u00fczerinde i\u015flem yapma konular\u0131na bakabilirsiniz.</p> <ul> <li>Overlay: Birden \u00e7ok paketi veya mod\u00fcl\u00fc override etmek i\u00e7in kullan\u0131l\u0131r. Tabi birden \u00e7ok paketi veya mod\u00fcl\u00fc override edebilen tekini de edebilir.</li> <li>Override: Tek bir paket veya mod\u00fcl \u00fczerinde de\u011fi\u015fiklik yapmak i\u00e7in kullan\u0131l\u0131r.</li> </ul> <p>Kullan\u0131mlar\u0131mdan edindi\u011fim sonu\u00e7 overlay'\u0131 anlamak ve uygulamak daha kolay. Ancak yine de \u00e7ok spesifik durumlarda mecburen salt override kullanmam\u0131z gerekebiliyor.</p>"},{"location":"nix_package/override_ve_overlay.html#override","title":"Override","text":"<p>Basit uygulamalardan karma\u015f\u0131\u011fa do\u011fru gidelim. Bir klas\u00f6r i\u00e7inde message-app ad\u0131nda bir klas\u00f6r a\u00e7al\u0131m. Klas\u00f6r i\u00e7inde default.nix ad\u0131nda bir dosya olu\u015fturup alttaki kodlar\u0131 kopyalayal\u0131m. Ben de kendi repo'mda override-derivation ad\u0131nda bir klas\u00f6rde bu i\u015flemleri yap\u0131yorum.</p>"},{"location":"nix_package/override_ve_overlay.html#pkgoverridederivation","title":"<code>&lt;pkg&gt;.overrideDerivation</code>","text":"<pre><code>{nixpkgs ? {}}:\n        nixpkgs.stdenv.mkDerivation (finalAttrs: {\n              name = \"message-app\";\n              version = \"v1.0\";\n\n              description = \"merhaba d\u00fcnya\";\n\n              src = builtins.fetchTarball {\n                      url = \"https://github.com/muratcabuk/simple-message-app-with-c/archive/refs/tags/${finalAttrs.version}.tar.gz\";\n                      sha256 = \"sha256:1aai9xdkgq2vd0ch10gxhg53qfv4ny2x3jgxlq4r9nrn4g9r8s1z\";\n                    };\n\n              buildInputs = [ nixpkgs.gcc ];\n              buildPhase = \"gcc -o message-app ${finalAttrs.src}/message.c\";\n              installPhase = \"mkdir -p $out/bin; install -t $out/bin message-app\";\n\n              meta = with nixpkgs.lib; {\n                    description = \"Simple Message App with C\";\n                    license = licenses.mit;\n                    version =  \"${finalAttrs.version}\";\n                };\n        })\n</code></pre> <p>message-app klas\u00f6r\u00fc ile ayn\u0131 dizinde flake.nix ad\u0131nda bir dosya a\u00e7\u0131p i\u00e7in alttaki kodlar\u0131 kopyalayal\u0131m.</p> <pre><code>{\n  description = \"Flake i\u00e7in \u00f6rnek paketler\";\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  };\n\n  outputs ={ self, nixpkgs, ... }:\n    let\n        pkgs = import nixpkgs {};\n\n        packages = rec {\n            x86_64-linux.default = (pkgs.callPackage ./message-app {version = \"v1.0\";}).overrideDerivation( oldAttrs: rec { version = \"v3.0-preview\";} );\n            x86_64-linux.message-app = x86_64-linux.default;\n\n            aarch64-linux.message-app =  import ./message-app {version = \"v3.0\";};\n        };\n\n    in\n    {\n        packages = packages;\n    };\n}\n</code></pre> <p>Default paketini callPackage fonksiyonu ile i\u00e7eri al\u0131rken parantez i\u00e7ine al\u0131nd\u0131\u011f\u0131na dikkat edin. Parantez ile bu i\u015fleme \u00f6ncelik verilmesini s\u00f6ylemi\u015f oluyoruz. Buj fonksiyon bildi\u011fimiz gibi bize derivative d\u00f6nd\u00fcr\u00fcyor. Bu tipi override edebilmemiz i\u00e7in de Nix bize overrideDerivation ad\u0131nda bir fonksiyon sunuyor. Bu fonksiyon veri olarak bir anonim fonksiyon al\u0131yor. Bu fonksiyonun ilk parametresi olan oldAttrs ise \u00fczerinde i\u015flem yapt\u0131\u011f\u0131m\u0131z derivative'in attribute'lar\u0131na eri\u015fmek i\u00e7in kullan\u0131l\u0131r.</p> <p>Bu \u00f6rnekte oldAttrs parametresi ile version attribute'una eri\u015fip de\u011fi\u015ftirdik. Ancak dikkat ederseniz paket import ederken v1.0 dedik ama override ederken v3.0-preview kulland\u0131k. Zaten b\u00f6yle bir versiyona destek vermedi\u011fimiz default.nix'den belli oluyor. Bu durumda e\u011fer override i\u015flemi derivation i\u015fleminden \u00f6nce oluyorsa yazd\u0131\u011f\u0131m\u0131z kod \u00e7al\u0131\u015fmayacakt\u0131r. Versiyon 1'de hat\u0131rlarsan\u0131z uygulamam\u0131z kullan\u0131c\u0131dan sadece tek bir metin al\u0131p onu ekrana yaz\u0131yordu.</p> <pre><code>nix run  .# --impure\n# komutu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131zda uygulama tek bir input al\u0131p onu akrana yazacakt\u0131r.\n# Yani kodumuz hata vermedi. Demek ki overrideDerivation derivate i\u015fleminden sonra \u00e7al\u0131\u015f\u0131yor.\n</code></pre> <p>Buradan override i\u015fleminin build i\u015fleminden sonra \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 g\u00f6rebiliyoruz. Peki hakikaten b\u00f6yle mi acaba? Yani bu durum hakikaten override i\u015fleminin build i\u015fleminden sonra \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 ispat eder mi? Evet eder \u00e7\u00fcnk\u00fc default.nix dosyas\u0131na bakacak olursak hakikaten versiyon bilgisini kaynak kodu \u00e7ekerken kullan\u0131yoruz. Dolay\u0131s\u0131yla e\u011fer sadece metadata bilgisi olarak de\u011fi\u015ftirmek istedi\u011fimiz attribute'lar varsa overrrideDerivation fonksiyonunu kullanabiliriz. Mesela hakikaten v1.0 dan paket olu\u015fturmak istiyoruz ancak tam release olmad\u0131\u011f\u0131 i\u00e7in version bilgisini de\u011fi\u015ftirmek istiyoruz. Veya ad\u0131n\u0131 farkl\u0131 bir \u015fekilde g\u00f6stermek istiyoruz. bu gibi durumlar kullan\u0131labilir.</p>"},{"location":"nix_package/override_ve_overlay.html#pkgoverrideattrs","title":"<code>&lt;pkg&gt;.overrideAttrs</code>","text":"<p>Bunun i\u00e7in sadece flake.nix dosyas\u0131n\u0131 alttaki gibi de\u011fi\u015ftiriyoruz. \u00d6nce test edelim sonra da ne d\u00f6nd\u00fc\u011f\u00fcn\u00fc anlamaya \u00e7al\u0131\u015fal\u0131m. Halen default.nix dosyam\u0131zda v1.0 versiyonunun yaz\u0131l\u0131 oldu\u011funu unutmayal\u0131m.</p> <pre><code># flake\n\n{\n  description = \"Flake i\u00e7in \u00f6rnek paketler\";\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  };\n  outputs ={ self, nixpkgs, ... }:\n    let\n\n\n        pkgs = import nixpkgs {};\n\n        packages = rec {\n           x86_64-linux.default = (pkgs.callPackage ./message-app {nixpkgs = pkgs;}).overrideAttrs (\n                                                      finalAttrs: previousAttrs: rec{\n                                                                      version = \"v3.0\";\n                                                                      src = builtins.fetchTarball {\n                                                                                url = \"https://github.com/muratcabuk/simple-message-app-with-c/archive/refs/tags/${version}.tar.gz\";\n                                                                                sha256 = \"sha256:1a4a2i32da9shc2d3i1ndarmla97bald7lgs1vjmwyjlry0mk4m7\";};\n                                                                                  });\n\n\n\n            x86_64-linux.message-app = x86_64-linux.default;\n\n            aarch64-linux.message-app =  import ./message-app {version = \"v3.0\";};\n        };\n\n    in\n    {\n        packages = packages;\n    };\n}\n</code></pre> <p>Alttaki gibi test etti\u011fimizde art\u0131k v3.0 versiyonunun kullan\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6rece\u011fiz.</p> <pre><code>nix run  .# --impure\n# art\u0131k v3.0 versiyonunun kullan\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6rece\u011fiz.\n</code></pre> <p>Peki buradaki finalAttrs ve previousAttrs ne anlama geliyor? finalAttrs, override i\u015flemi yap\u0131lan set'in son hali anlam\u0131na gelir. previousAttrs ise override i\u015flemi yap\u0131lmadan \u00f6nceki set'in hali anlam\u0131na gelir. Al\u0131nda biz her atama yapt\u0131\u011f\u0131m\u0131zda derivative'i de\u011fi\u015ftiriyoruz. E\u011fer biz de\u011fi\u015ftirmeden bir \u00f6nceki de\u011ferlere ihtiyac\u0131m\u0131z varsa previousAttrs kullan\u0131yoruz o de\u011feri okumak i\u00e7in. Yada biz de\u011fi\u015ftirdikten sonraki bir de\u011feri okumak istiyorsak finalAttrs kullan\u0131yoruz.</p> <p>Baz\u0131 kaynaklarda finalAttrs yerine self, previousAttrs yerine super kullan\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6rebilirsiniz. Burada bilmemiz gereken ilk parametre de\u011fi\u015ftikten sonra yeni hali, ikinci parametre ise de\u011fi\u015fmeden \u00f6nceki hali temsil eder.</p>"},{"location":"nix_package/override_ve_overlay.html#pkgoverride","title":"<code>&lt;pkg&gt;.override</code>","text":"<p>Nixpkgs 'de neredeyse b\u00fct\u00fcn paketlerde override fonksiyonu bulunur. Yani bu durumda override fonksiyonunu kulland\u0131\u011f\u0131m\u0131z paket bize sunuyor olmal\u0131. Dolay\u0131s\u0131yla \u015fu haliyle biz kendi paketimizde override fonksiyonunu kullanamay\u0131z. Kullan\u0131m\u0131 tamamen overrideAttrs fonksiyonu ile ayn\u0131. Zaten internette bir \u00e7ok \u00f6rnek bulabilirsiniz. Zaten resmi dok\u00fcmanlara'da bakarsan\u0131z overrideAttrs fonksiyonunun override fonksiyonundan daha \u00e7ok kullan\u0131ld\u0131\u011f\u0131n\u0131 hatta \u00f6nerildi\u011fini de g\u00f6rebilirsiniz.</p>"},{"location":"nix_package/override_ve_overlay.html#pkgmakeoverradable","title":"<code>&lt;pkg&gt;.makeOverradable</code>","text":"<p>Bu ise normal bir bir fonksiyonu override edilebilir hale getirir. Normal \u015fartlarda Nix dilinde mkDerivative fonksiyonu da dahil bir fonksiyonu set'ler gibi override edemezsiniz. Ancak yeni bir versiyonunu yazmam\u0131z gerekir. Buna daha \u00f6nce de\u011finmi\u015ftik. MkDerivative fonksiyonu \u00f6zel bir fonksiyon oldu\u011fu i\u00e7in dil i\u00e7inde derivative \u00fczeriden bunu override edebilmemiz m\u00fcmk\u00fcn k\u0131l\u0131nm\u0131\u015f. Orada da b\u00fcy\u00fck ihtimal arkada sistem asl\u0131nda fonksiyonun build al\u0131nma s\u00fcrecinde yap\u0131lacaklarla ilgili derivative'deki attribute'lar\u0131 de\u011fi\u015ftiriyor. Asl\u0131nda biz fonksiyonu de\u011fil fonksiyonun \u00e7al\u0131\u015fmasa sonucunda olu\u015fan derivative de\u011ferlerini de\u011fi\u015ftiriyoruz. Yada ikinci ihtimal ki bu daha y\u00fcksek bir ihtimal sistem bizden alt\u0131\u011f\u0131 parametrelere g\u00f6re yeni bir derivative olu\u015fturuyor. Nas\u0131l yapt\u0131\u011f\u0131 \u00e7ok \u00f6nemli de\u011fil asl\u0131nda bizim i\u00e7in. Bizim i\u00e7in \u00f6nemli olan fonksiyonun sonucunu de\u011fi\u015ftirebilmek.</p> <p>Baz\u0131 durumlarda basit bir fonksiyonu da override edilebilir yapmam\u0131z gerekebilir. Ancak tabii ki halen b\u00fct\u00fcn kurallar ge\u00e7erli yani bir fonksiyon immutable'd\u0131r yani kendini veya i\u00e7indeki bir parametreyi veya yapt\u0131\u011f\u0131 i\u015fin bir k\u0131sm\u0131n\u0131 do\u011frudan de\u011fi\u015ftiremeyiz. Burada ayarlayabildi\u011fimiz sadece sonucu de\u011fi\u015ftirmek.</p> <p>Resmi sayfas\u0131ndaki \u00f6rne\u011fi do\u011frudan al\u0131yorum.</p> <p>Repl i\u00e7inden \u00f6rne\u011fi test edebilirsiniz.</p> <pre><code>f = { a, b }: { result = a+b; };\nc = lib.makeOverridable f { a = 1; b = 2; };\n# c.result = 3\n\n(c.override { a = 4; }).result\n# result 6 olacakt\u0131r\n</code></pre> <p>G\u00f6rd\u00fc\u011f\u00fcm\u00fcz \u00fczere biz asl\u0131nda f fonksiyonunu override etmedik. Halen fonksiyon ayn\u0131 i\u015flemi yap\u0131yor. Ancak elimizde ki s\u0131nucun parametre de\u011ferlieni de\u011fi\u015ftirerek farkl\u0131 sonu\u00e7lar olu\u015furabiliyoruz.</p> <p>Buraya kadar sadece kendi yazd\u0131\u011f\u0131m\u0131z tek bir paketi override etmeyi \u00f6\u011frendik. \u015eimdi birde bir veya daha fazla paketi overlay ile nas\u0131l override edebilece\u011fimize bakal\u0131m. Ard\u0131ndan Nix repo'lar\u0131ndaki veya di\u011fer repo'lardaki paketleri nas\u0131l override edebilece\u011fimize bakal\u0131m.</p>"},{"location":"nix_package/override_ve_overlay.html#overlay","title":"Overlay","text":"<p>Overlay basit\u00e7e iki parametre (final, prev veya self, super) alan ve geriye bir paket seti d\u00f6nd\u00fcren fonksiyondur.</p> <p>\u00d6ncelikle overlay kavram\u0131n\u0131 biraz inceleyelim. Daha sonra uygulamalara ge\u00e7eriz.</p> <p>En basit haliyle overlay <code>final: prev: { f = final.&lt;pkg&gt;; }</code> \u015feklinde yaz\u0131l\u0131r. Di\u011fer bir \u015fekliyle <code>final: prev: { f = prev.&lt;pkg&gt;; }</code> \u015feklinde de yaz\u0131labilir. \u015eu haliyle bu yaz\u0131mla bir \u015fey de\u011fi\u015ftirmiyoruz tabii ki sadece de\u011fi\u015ftirme yaparken paketin \u00f6nceki haline ve son haline ula\u015fmak i\u00e7in kullan\u0131yoruz. Alttaki kullan\u0131mla bir paketin de\u011fi\u015fimden \u00f6nceki haline eri\u015fip onu de\u011fi\u015ftirip daha sonra yeni halini (final) d\u00f6nd\u00fcr\u00fcyoruz.</p> <pre><code>final: prev: {\n  pkg_name = prev.pkg_name.override { ... };\n  myPackage = final.pkg_name;\n}\n</code></pre> <p>Ancak mesela alttaki \u00f6rnekte infinite recursion durumu olu\u015fur. Yani sonsuz d\u00f6ng\u00fcye girer. \u00c7\u00fcnk\u00fc final ifadesi preview ifadesi \u00fczerine kurulur. E\u011fer son durumdan (final) tekrar son durum (final) olu\u015fturmaya \u00e7al\u0131\u015f\u0131rsak sonsuz d\u00f6ng\u00fcye gireriz.</p> <pre><code>final: prev: firefox = final.firefox.override { ... };\n</code></pre> <p>Alttaki \u00f6rnekte de birden fazla paket \u00fczerinden i\u015flem yap\u0131l\u0131yor. Burada da self son hali prev ise \u00f6nceki hali temsil eder.</p> <pre><code>self: super:\n{\n  boost = super.boost.override {\n    python = self.python3;\n  };\n  rr = super.callPackage ./pkgs/rr {\n    stdenv = self.stdenv_32bit;\n  };\n}\n</code></pre> <p>Alttaki \u00f6rnek de ise dah \u00f6nce de yapt\u0131\u011f\u0131m\u0131z gibi bir paketin kayna\u011f\u0131n\u0131 ve versiyonu de\u011fi\u015ftiriyoruz.</p> <pre><code>self: super: {\n    &lt;pkg&gt; = super.&lt;pkg&gt;.overrideAttrs (prev: {\n      version = \"v2.0\";\n      src = pkgs.fetchFromGitHub {\n        owner = \"username\";\n        repo = \"repo_name\";\n        sha256 = cha2560000000000000000;\n      };\n    });\n  }\n</code></pre> <p>\u00d6rneklerden de anlayaca\u011f\u0131n\u0131z \u00fczere en ba\u015fta dedi\u011fimiz gibi <code>final: prev: { .......... }</code> \u015feklinde bir kal\u0131p. Ancak hala tam olarak nedir tam olarak ne oldu\u011fu belli de\u011fil gibi. Teknik olarak evet bir fonksiyon ama ever bir override ise zaten farkl\u0131 farkl\u0131 fonksiyonlar var ve neden overlay diye bir isim?</p> <p>Asl\u0131nda overlay tam salt olarak bir override yani bir de\u011fi\u015fkeni al\u0131p de\u011fi\u015ftirmek gibi bir i\u015flem yapm\u0131yor. Override kelimesinin T\u00fcrk\u00e7e kar\u015f\u0131l\u0131\u011f\u0131 isim olarak katman, \u00f6rt\u00fc ve fiil olarak \u00f6rtmek, \u00fcst\u00fcn\u00fc kapatmak gibi anlamlara geliyor. \u015eu sayfada birazdan anlataca\u011f\u0131m katman mant\u0131\u011f\u0131n\u0131 daha detayl\u0131 inceleyebilirsiniz. G\u00f6rselleri ve anlat\u0131m\u0131 da ayn\u0131 sayfadan ald\u0131m.</p> <p>Alttaki gibi mod\u00fcl ile Firefox'u build ald\u0131\u011f\u0131m\u0131z\u0131 ve nixpkgs ile // operat\u00f6r\u00fc ile merge etti\u011fimizi d\u00fc\u015f\u00fcnelim. Asl\u0131nda paketlerde 71. versiyon yok biz ekledik. Resimde belki g\u00f6r\u00fcnm\u00fcyordur alttaki katmanda firefox 70.1 versiyonunun oldu\u011fu yaz\u0131yor. Hatta 71 versiyonunda farkl\u0131 olarak pulseaudio paketi hi\u00e7 kullan\u0131lmam\u0131\u015f.</p> <pre><code>let\n  nixpkgs = import &lt;nixpkgs&gt; {};\n  custom = {\n    firefox = derive(\"71\", nixpkgs.zlib, nixpkgs.gcc, nixpkgs.stdenv)\n  }\nin\n  nixpkgs // custom\n</code></pre> <p>Bu haliyle bile asl\u0131nda bir overlay yapm\u0131\u015f olduk. Yepyeni bir Firefox paketini b\u00fct\u00fcn di\u011fer uygulamalar\u0131 koruyarak nixpkgs'ye eklemi\u015f olduk. Daha do\u011frusu \u00f6nceki versiyonun yerine koymu\u015f olduk. E\u011fer farkl\u0131 bir isim vermi\u015f olsayd\u0131k \u00f6rne\u011fin firefox_custom o zaman nixpkgs i\u00e7inde hem firefox hem de firefox_custom ad\u0131ndan iki paketimiz olacakt\u0131.</p> <p><sup>1</sup></p> <p>Dikkat ederseniz stdenv paketinin hi\u00e7bir pakete ba\u011f\u0131ml\u0131l\u0131\u011f\u0131 yok. Firefox ve zlib paketleri ise ortak gcc paketine ba\u011f\u0131ml\u0131.</p> <p>\u015eimdi bir \u015fekilde art\u0131k gcc paketinin 8.1.1 versiyonunu kullanmak istedi\u011fimizi varsayal\u0131m. Haliyle bu versiyonu da sisteme koymam\u0131z gerekiyor. bu durumda eski veriyonla \u00e7al\u0131\u015fan Firefox ve onda ba\u011f\u0131ml\u0131 olan zlib bu durumdan etkilenmeyecektir. Bu da Nix'i g\u00fc\u00e7l\u00fc k\u0131lan \u00f6zelliklerden birisi.</p> <p><sup>2</sup></p> <p>Her ekledi\u011fimiz katman \u00f6nceki ba\u011f\u0131ml\u0131l\u0131klar\u0131 bozmuyor. Burada a\u00e7\u0131k\u00e7a g\u00f6r\u00fclece\u011fi \u00fczere ba\u011f\u0131ml\u0131l\u0131klar directed acyclic graph (DAG) olarak \u00e7al\u0131\u015f\u0131r. T\u00fcrk\u00e7esi \"y\u00f6nlendirilmi\u015f d\u00f6ng\u00fcsel olmayan grafik\" olarak \u00e7evrilebilir. Yani bu ba\u011f\u0131ml\u0131l\u0131k yap\u0131s\u0131 hi\u00e7bir zaman bir d\u00f6ng\u00fc olu\u015fturmaz. Her ekedi\u011fimiz de\u011fi\u015fiklik sistemi bir sonraki katmna g\u00f6t\u00fcr\u00fcr.</p> <p><sup>3</sup></p> <p>Son tahlilde elimizde alttakine benzer bir yap\u0131 olu\u015facakt\u0131r.</p> <p></p> <p>Yani velhas\u0131l kelam overlay asl\u0131nda override'\u0131n daha \u00f6tesinde bir kavramd\u0131r. Ancak us\u00fcl olmu\u015f paket de\u011fi\u015fikli\u011finin anlat\u0131ld\u0131\u011f\u0131 yerlerde overlay'den bahsetmek ki bizde \u00f6yle yapt\u0131k. Ancak bence Nix paket y\u00f6neticisi nedir sorusunun hemen alt\u0131nda bu konuya de\u011finilebilirdi.</p> <p>\u015eimdi de overlay'i nas\u0131l kullanaca\u011f\u0131m\u0131za bakal\u0131m.</p> <p>Konuyu mimar\u0131ndan dinlemek isterseniz Youtube sunumunu NixCov 2017 izleyebilirsiniz.</p>"},{"location":"nix_package/override_ve_overlay.html#overlayi-manuel-olarak-uygulamak","title":"Overlay'i Manuel Olarak Uygulamak","text":"<ul> <li>import \\ { overlays = [ overlay1 overlay2 ]; } <li>let pkgs = (nixpkgs.legacyPackages.${system}.extend overlay1).extend overlay2</li> <li>let pkgs = import nixpkgs { inherit system; overlays = [ overlay1 overlay2 ]; }</li> <p>Art\u0131k tek paket \u00fczeriden de\u011fil t\u00fcm paketler \u00fczerinden i\u015flem yapt\u0131\u011f\u0131m\u0131za dikkat edin. \u00d6ncelikle paketleri veya paketi se\u00e7ip sonra i\u015flem yap\u0131yoruz. Yada paket se\u00e7meyip yeni paket de ekleyebiliriz. Veya bir paketin \u00f6zelliklerini de\u011fi\u015ftirebilir yeni \u00f6zellikler ekleyebiliriz.</p> <p>\u015eimdi isterseniz overlay'in asl\u0131nda salt bir override i\u015flemi olmad\u0131\u011f\u0131n\u0131 anlamak i\u00e7in kodumuzda biraz de\u015fiklik yapal\u0131m. Yeni bir klas\u00f6r olu\u015ftural\u0131m. Ben repo'mda overlay-simple ad\u0131nda bir klas\u00f6r a\u00e7t\u0131m. Klas\u00f6r i\u00e7ine yine message.nix ad\u0131nda bir dosya olu\u015fturup alttaki kodlar\u0131 kopyal\u0131yoruz.</p> <pre><code>{ pkgs, version? \"v1.0\" }:\n\n    let\n      simpleMessageAppSrc = \"https://github.com/muratcabuk/simple-message-app-with-c/archive/refs/tags/${version}.tar.gz\";\n\n      shaSet = {v10=\"sha256:1aai9xdkgq2vd0ch10gxhg53qfv4ny2x3jgxlq4r9nrn4g9r8s1z\";\n                v20=\"sha256:11p3c793yjpm4z4j9shlidbii7wd0kf9qflx8jqhhnwwhqf93mam\";\n                v30=\"sha256:1a4a2i32da9shc2d3i1ndarmla97bald7lgs1vjmwyjlry0mk4m7\";};\n\n      shaVer = builtins.concatStringsSep \"\" (pkgs.lib.strings.splitString \".\" \"${version}\");\n\n      versionSha = builtins.getAttr shaVer shaSet;\n\n      # Simple Message App'in kaynak dizini\n      src = builtins.fetchTarball {\n        url = simpleMessageAppSrc;\n        sha256 = versionSha;\n      };\n    in\n\n        pkgs.stdenv.mkDerivation (finalAttrs: {\n              name = \"message\";\n              version = \"${version}\";\n\n              src = src;\n\n              buildInputs = [ pkgs.gcc ];\n              buildPhase = \"gcc -o message ${src}/message.c\";\n              installPhase = \"mkdir -p $out/bin; install -t $out/bin message\";\n\n              meta = with pkgs.lib; {\n                    description = \"Simple Message App with C\";\n                    license = licenses.mit;\n                    version =  \"${version}\";\n                };\n        })\n</code></pre> <p>ayn\u0131 dizine flake.nix dosyam\u0131z\u0131 da ekleyip alttaki kodlar\u0131 kopyalayal\u0131m.</p> <pre><code>{\n  description = \"Flake i\u00e7in \u00f6rnek paketler\";\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  };\n  outputs ={ self, nixpkgs, ... }:\n  let\n\n      overlay = (final: prev: { default = import ./message.nix {pkgs = final; version = \"v3.0\";}; });\n\n      system = \"x86_64-linux\";\n\n      pkgs = import nixpkgs { inherit system; overlays = [overlay];};\n\n      packages.x86_64-linux.default = pkgs.default;\n\n\n  in\n  {\n    inherit packages;\n  };\n}\n</code></pre> <p>Kodu alttaki komutla test etti\u011fimizde message uygulamas\u0131nda v1.0 yazm\u0131\u015f olmam\u0131za ra\u011fmen art\u0131k v3.0 versiyonunun kullan\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6rece\u011fiz. Zaten message.nix dosyam\u0131z bir fonksiyon ve version diye bir parametre var ve biz bunu ne atarsak ona g\u00f6re build al\u0131n\u0131yor paketimiz.</p> <pre><code>nix run .#dedault --impure\n</code></pre> <p>Kodu inceledi\u011fimizde \u00f6nceki kodlar\u0131m\u0131zdan farkl\u0131 olarak paket y\u00fckleme i\u015fini overlay \u00fczerinden yap\u0131yoruz. Asl\u0131nda overlay kullanmasak bile y\u00fckledi\u011fimiz paketin bir overlay olu\u015fturdu\u011funu \u00fcstte anlatm\u0131\u015ft\u0131k. Burada overlay i\u015flemini a\u00e7\u0131k\u00e7a yap\u0131yoruz. B\u00f6ylece y\u00fckleme i\u015fi yap\u0131l\u0131rken araya girme \u015fans\u0131m\u0131z da oluyor. Bu sayede asl\u0131nda pkgs'ye overlay uygulayarak kendi paketimizi paketler i\u00e7ine eklemi\u015f oluyoruz. Override kavram\u0131 \u00fczerinden bakacak olursak mevzuya, pkgs i\u00e7indeki paketlerimizi g\u00fcncellemi\u015f yani override yapm\u0131\u015f oluyoruz.</p> <p>Overlay'yi <code>pkgs = import nixpkgs { inherit system; overlays = [overlay];};</code> sat\u0131r\u0131 ile uygulam\u0131\u015f oluyoruz. Bu durumda overlay i\u00e7inde <code>pkgs = final</code> tan\u0131m\u0131nda final keyword'\u00fc ile asl\u0131nda pkgs'nin son halini i\u015faret etmi\u015f oluyoruz.</p> <p>Bu arada b\u00fct\u00fcn kodlar\u0131 GitHub sayfamda bulabilirsiniz.</p> <p>\u015eimdide repo'muzdaki paketleri nas\u0131l overlay ile toplu halde ve farkl\u0131 sistemleri de destekleyecek \u015fekilde y\u00fckleyebiliriz ona bakal\u0131m.</p> <p>Kendi Github sayfamda nix-examples repo'sunda overlay-example branch'inde overlay \u00f6rne\u011finin t\u00fcm kodunu g\u00f6rebilirsiniz.</p> <p>As\u0131l odaklanmam\u0131z gereken overlay ve flake dosyalar\u0131m\u0131z\u0131 burada inceleyece\u011fiz zaten.</p> <p>Overlay'imizi art\u0131k ba\u015fka \u00f6rneklerde de g\u00f6rebilece\u011finiz \u00fczere overlay.nix dosyas\u0131na ta\u015f\u0131d\u0131k. \u0130lk \u00f6rne\u011fimizden farkl\u0131 olarak bu sefer overlay.nix dosyas\u0131nda bir \u00e7ok paketi overlay ile y\u00fckl\u00fcyoruz. Ayr\u0131ca hello ad\u0131ndaki bir paketi de nixpkgs'den y\u00fckleyip override ediyoruz. Asl\u0131nda flake dosyas\u0131nda altta g\u00f6rebilece\u011finiz \u00fczere hello paketinin son versiyonunu da y\u00fckl\u00fcyoruz. \u00d6rnek olmas\u0131 a\u00e7\u0131s\u0131ndan 2 farkl\u0131 versiyonu override ve overlay yard\u0131m\u0131yla nas\u0131l kullanabilece\u011fimizi de g\u00f6relim istedim. Tabi burada \u015funu bilmemiz gerekiyor, e\u011fer nixpkgs alt\u0131ndaki hello derivative fonksiyonu hello uygulamas\u0131n\u0131n 2.9 versiyonunu build al\u0131p bize veremeyecek \u015fekilde olsayd\u0131 o zaman build s\u00fcrecini de override etmek zorunda kalacakt\u0131r.</p> <pre><code># overlay\nfinal: prev: {\n              defaultapp = import ./pkgs/default {pkgs = final;};\n              defaultfile = import ./pkgs/defaultfile {pkgs = final;};\n              defaultalt = import ./pkgs/defaultalt{pkgs=final;};\n              nixapp = import ./pkgs/nixapp { pkgs = final; };\n              message = (import ./pkgs/message {pkgs = final; version = \"v3.0\";});\n              testapp = (import ./pkgs/testapp {pkgs = final; version = \"v3.0\";});\n              hello-custom = final.hello.overrideAttrs (old: rec {\n                name = \"hello-custom\";\n                version = \"2.9\";\n                      src = final.fetchurl {\n                      url = \"mirror://gnu/hello/hello-${version}.tar.gz\";\n                      sha256 = \"sha256-7Lt6IhQZbFf/k0CqcUWOFVmr049tjRaWZoRpNd8ZHqc=\";\n                      };});\n              }\n</code></pre> <p>Flake dosyam\u0131zda ise alttaki gibi overlay'i uyguluyoruz. Paketlerimizi iki farkl\u0131 sistem i\u00e7in olu\u015fturuyoruz</p> <p>Her sistem i\u00e7in do\u011fal olarak iki farkl\u0131 paket olu\u015fturmam\u0131z gerekiyor. Bundan dolay\u0131 pkgs de\u011fi\u015fkenini her sistem i\u00e7in ayr\u0131 ayr\u0131 olu\u015fturuyoruz. <code>forAllsystems</code> fonksiyonu ile de bu i\u015flemi yap\u0131yoruz. Overlay ile override edilen paketler de dahil b\u00fct\u00fcn paketlere y\u00fcklendikten sonra packages ile d\u0131\u015far\u0131ya output olarak a\u00e7\u0131l\u0131yor.</p> <pre><code># flake\n{\n  description = \"Flake i\u00e7in \u00f6rnek paketler\";\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  };\n  outputs ={ self, nixpkgs, ... }:\n  let\n      forAllSystems = nixpkgs.lib.genAttrs [\n        \"aarch64-linux\"\n        \"x86_64-linux\"\n      ];\n\n      overlays = [(import ./overlay.nix)];\n\n      packages = forAllSystems (system:\n          let\n            pkgs = import nixpkgs {\n              inherit system;\n              overlays = overlays;\n            };\n          in {\n            default = pkgs.defaultapp;\n            defaultfile = pkgs.defaultfile;\n            defaultalt = pkgs.defaultalt;\n            nixapp = pkgs.nixapp;\n            message = pkgs.message;\n            testapp = pkgs.testapp;\n            hello = pkgs.hello;\n            hello-custom = pkgs.hello-custom;\n            }\n        );\n  in\n  {\n    inherit packages;\n  };\n}\n</code></pre>"},{"location":"nix_package/override_ve_overlay.html#overlayi-otomatik-olarak-uygulamak","title":"Overlay'i Otomatik Olarak Uygulamak","text":"<p>Kullan\u0131c\u0131 Baz\u0131nda Uygulamak</p> <p><code>~/.config/nixpkgs/overlays.nix</code> dizininde, yani kullan\u0131c\u0131n\u0131n home dizinindeki <code>.config</code> klas\u00f6r\u00fcnde nixpkgs klas\u00f6r\u00fc alt\u0131nda overlays.nix dosyas\u0131na overlay'leri ekleyebiliriz. B\u00f6ylece sistem otomatik olarak y\u00fckleyecektir.</p> <p>Yada alttaki dizinlerde default.nix ad\u0131nda bir dosya olu\u015fturup yine ayn\u0131 dizinde olu\u015fturdu\u011fumuz overlay'leri ekleyebiliriz.</p> <pre><code>ll  ~/.nix-defexpr/\n\nlrwxrwxrwx 1 kullanici_grubu kullanici_adi 51 Eki 21 23:04 channels -&gt; /home/kullanici_adi/.local/state/nix/profiles/channels\nlrwxrwxrwx 1 kullanici_grubu kullanici_adi 44 Eki 21 23:04 channels_root -&gt; /nix/var/nix/profiles/per-user/root/channels\n</code></pre> <p>System Baz\u0131nda Uygulamak</p> <p>Sisteme path olarak nixpkgs-overlays kullan\u0131larak <code>NIX_PATH=\"$NIX_PATH:nixpkgs-overlays=/etc/nixos/overlays\"</code> dizini eklenir. Ve bu dizin alt\u0131nda overlay'ler eklenir.</p> <p>Bu arada otomatik y\u00fckleme yaparken <code>~/.config/nixpkgs/overlays/*.nix</code> \u015feklinde joker karakter de kullanabiliriz.</p> <p>Bu path'lar\u0131n baz\u0131lar\u0131n\u0131n tan\u0131m\u0131n\u0131 nixpkgs repo'unda da g\u00f6rebilirsiniz. Daha \u00f6nce ilk yaz\u0131lar\u0131m\u0131zda bu \u00f6ze path'lere de\u011finmi\u015ftik. Mesela alttaki kod blo\u011fu <code>pkgs/top-leve/impure.nix</code> dizininde g\u00f6rebilirsiniz. Resmi GitHub sayfas\u0131nda \u015fu adreste de g\u00f6rebilirsiniz.</p> <pre><code>      pathOverlays = try (toString &lt;nixpkgs-overlays&gt;) \"\";\n      homeOverlaysFile = homeDir + \"/.config/nixpkgs/overlays.nix\";\n      homeOverlaysDir = homeDir + \"/.config/nixpkgs/overlays\";\n</code></pre> <p>Otomatik olarak uygulama metodunu kullanaca\u011f\u0131n\u0131z\u0131 zannetmiyorum. En az\u0131nda bu yaz\u0131y\u0131 yazd\u0131\u011f\u0131m ana kadar ben kullanma ihtiyac\u0131 duymad\u0131m. Bu nedenle burayla alakal\u0131 \u00f6rnek yapmayaca\u011f\u0131m. Bunu da kendinizi test etmek i\u00e7in \u00f6dev olsun diyelim.</p> <p>Bir sonraki yaz\u0131m\u0131zda art\u0131k kendi paketlerimizi ve Nix repo'sundaki paketleri kullanarak kendimize nas\u0131l profile veya development ortamlar\u0131 olu\u015fturabilece\u011fimizi g\u00f6rece\u011fiz. Daha \u00f6nce g\u00f6rd\u00fc\u011f\u00fcm\u00fcz <code>nix shell ve nix profile</code> gibi komutlar\u0131 declarative yolla y\u00f6netmeyi ve daha \u00f6nce g\u00f6rmedi\u011fimiz <code>nix develop</code> komutunu da g\u00f6rece\u011fiz.</p>"},{"location":"nix_package/override_ve_overlay.html#referanslar","title":"Referanslar","text":"<ul> <li>https://ryantm.github.io/nixpkgs/using/overrides/#chap-overrides</li> <li>https://ryantm.github.io/nixpkgs/using/overlays/#chap-overlays</li> <li>https://bobvanderlinden.me/customizing-packages-in-nix/</li> </ul> <ol> <li> <p>Resim Kayna\u011f\u0131 \u21a9</p> </li> <li> <p>Resim Kayna\u011f\u0131 \u21a9</p> </li> <li> <p>Resim Kayna\u011f\u0131 \u21a9</p> </li> </ol>"}]}